<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NT4 Neural-Net Engine: c_Construct_Text_Server Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NT4 Neural-Net Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classc___construct___text___server-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">c_Construct_Text_Server Class Reference<div class="ingroups"><a class="el" href="group___construct___text___server.html">Construct_Text_Server</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This is a handshake based text interface for the engine.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="c___construct___text___server_8h_source.html">c_Construct_Text_Server.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91e72ee70d44afeed04735216db62d8b" id="r_a91e72ee70d44afeed04735216db62d8b"><td class="memItemLeft" align="right" valign="top"><a id="a91e72ee70d44afeed04735216db62d8b" name="a91e72ee70d44afeed04735216db62d8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>c_Construct_Text_Server</b> (std::string p_Autoexec=&quot;../autoexec.ssv&quot;)</td></tr>
<tr class="separator:a91e72ee70d44afeed04735216db62d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e40ed359999d48fbfddf03ac01cd1f6" id="r_a5e40ed359999d48fbfddf03ac01cd1f6"><td class="memItemLeft" align="right" valign="top"><a id="a5e40ed359999d48fbfddf03ac01cd1f6" name="a5e40ed359999d48fbfddf03ac01cd1f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>save_Config</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a5e40ed359999d48fbfddf03ac01cd1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7397fa9e3af6a037892b2de02c418e1d" id="r_a7397fa9e3af6a037892b2de02c418e1d"><td class="memItemLeft" align="right" valign="top"><a id="a7397fa9e3af6a037892b2de02c418e1d" name="a7397fa9e3af6a037892b2de02c418e1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_Config</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a7397fa9e3af6a037892b2de02c418e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bd06749848baf527092f651a6e12c6" id="r_a19bd06749848baf527092f651a6e12c6"><td class="memItemLeft" align="right" valign="top"><a id="a19bd06749848baf527092f651a6e12c6" name="a19bd06749848baf527092f651a6e12c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_Base_Charge</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a19bd06749848baf527092f651a6e12c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0090998135650b1f494515c84970a688" id="r_a0090998135650b1f494515c84970a688"><td class="memItemLeft" align="right" valign="top"><a id="a0090998135650b1f494515c84970a688" name="a0090998135650b1f494515c84970a688"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_Modifier_Charge</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a0090998135650b1f494515c84970a688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d63afec6412f91179b6e7942aaafee" id="r_a37d63afec6412f91179b6e7942aaafee"><td class="memItemLeft" align="right" valign="top"><a id="a37d63afec6412f91179b6e7942aaafee" name="a37d63afec6412f91179b6e7942aaafee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_Action_Potential_Threshold</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a37d63afec6412f91179b6e7942aaafee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d986ee8f1edd1252f2ace33184f85" id="r_a026d986ee8f1edd1252f2ace33184f85"><td class="memItemLeft" align="right" valign="top"><a id="a026d986ee8f1edd1252f2ace33184f85" name="a026d986ee8f1edd1252f2ace33184f85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_Charging_Tier</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a026d986ee8f1edd1252f2ace33184f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64b053a95c371b033fa3b8c3954c20" id="r_afc64b053a95c371b033fa3b8c3954c20"><td class="memItemLeft" align="right" valign="top"><a id="afc64b053a95c371b033fa3b8c3954c20" name="afc64b053a95c371b033fa3b8c3954c20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_Construct_Connection</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:afc64b053a95c371b033fa3b8c3954c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9415f7f676338089c401e02a5b9c28" id="r_aeb9415f7f676338089c401e02a5b9c28"><td class="memItemLeft" align="right" valign="top"><a id="aeb9415f7f676338089c401e02a5b9c28" name="aeb9415f7f676338089c401e02a5b9c28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>output_Construct_Connections</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:aeb9415f7f676338089c401e02a5b9c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c20c9867bfe49129a75abb255da65a" id="r_aa1c20c9867bfe49129a75abb255da65a"><td class="memItemLeft" align="right" valign="top"><a id="aa1c20c9867bfe49129a75abb255da65a" name="aa1c20c9867bfe49129a75abb255da65a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>round_Up_Input</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:aa1c20c9867bfe49129a75abb255da65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28103a516fd578098996a07110e6821a" id="r_a28103a516fd578098996a07110e6821a"><td class="memItemLeft" align="right" valign="top"><a id="a28103a516fd578098996a07110e6821a" name="a28103a516fd578098996a07110e6821a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pull_From_Lower_Connection</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a28103a516fd578098996a07110e6821a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ee3025ca344b19dd886681ae5d35a" id="r_a374ee3025ca344b19dd886681ae5d35a"><td class="memItemLeft" align="right" valign="top"><a id="a374ee3025ca344b19dd886681ae5d35a" name="a374ee3025ca344b19dd886681ae5d35a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pull_From_Lower_Connections</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a374ee3025ca344b19dd886681ae5d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f33bb198e109085a4408345a0adf3c" id="r_ac7f33bb198e109085a4408345a0adf3c"><td class="memItemLeft" align="right" valign="top"><a id="ac7f33bb198e109085a4408345a0adf3c" name="ac7f33bb198e109085a4408345a0adf3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pull_From_Upper_Index</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:ac7f33bb198e109085a4408345a0adf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475eb56659e2ddb166163704d42bafc4" id="r_a475eb56659e2ddb166163704d42bafc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a475eb56659e2ddb166163704d42bafc4">set_Type</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a475eb56659e2ddb166163704d42bafc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of a given node.  <br /></td></tr>
<tr class="separator:a475eb56659e2ddb166163704d42bafc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c1608480eecd776b3bd4a182956a47" id="r_af9c1608480eecd776b3bd4a182956a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9c1608480eecd776b3bd4a182956a47">add_Axon_Index</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:af9c1608480eecd776b3bd4a182956a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a given NID to an Axon on the given Hillock.  <br /></td></tr>
<tr class="separator:af9c1608480eecd776b3bd4a182956a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09404fc5ad69a0b09826d03b21dd2bc1" id="r_a09404fc5ad69a0b09826d03b21dd2bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09404fc5ad69a0b09826d03b21dd2bc1">set_Dendrites</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a09404fc5ad69a0b09826d03b21dd2bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dendrites of the node.  <br /></td></tr>
<tr class="separator:a09404fc5ad69a0b09826d03b21dd2bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e8fcbb11b03289e2a011cf464224fa" id="r_ae1e8fcbb11b03289e2a011cf464224fa"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1e8fcbb11b03289e2a011cf464224fa">does_Upper_Tier_Connection_Exist</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ae1e8fcbb11b03289e2a011cf464224fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the axons to see if an upper tier connection exists, if found returns the NID, if not returns 0.  <br /></td></tr>
<tr class="separator:ae1e8fcbb11b03289e2a011cf464224fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740c907e03325e299d611e270bb6e40" id="r_af740c907e03325e299d611e270bb6e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af740c907e03325e299d611e270bb6e40">does_Lower_Connection_Exist</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:af740c907e03325e299d611e270bb6e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given node has dendrites that match the given nodes in the given order.  <br /></td></tr>
<tr class="separator:af740c907e03325e299d611e270bb6e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae006adef321f75481453c3478006d68d" id="r_ae006adef321f75481453c3478006d68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae006adef321f75481453c3478006d68d">bind_State</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ae006adef321f75481453c3478006d68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a node to a quanta of data, the state of the input, as uint64_t.  <br /></td></tr>
<tr class="separator:ae006adef321f75481453c3478006d68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9516daf43b865cb75bb98949b375ab49" id="r_a9516daf43b865cb75bb98949b375ab49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9516daf43b865cb75bb98949b375ab49">bp_O</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a9516daf43b865cb75bb98949b375ab49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern represented by this node.  <br /></td></tr>
<tr class="separator:a9516daf43b865cb75bb98949b375ab49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e20c3d32f5b1eb8e4f83f0299b4e470" id="r_a4e20c3d32f5b1eb8e4f83f0299b4e470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e20c3d32f5b1eb8e4f83f0299b4e470">output_Node_Raw</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a4e20c3d32f5b1eb8e4f83f0299b4e470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the ugly raw info dump for the node.  <br /></td></tr>
<tr class="separator:a4e20c3d32f5b1eb8e4f83f0299b4e470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c3b3e6c10ba5c94c7047dbd18e9e8" id="r_a2f0c3b3e6c10ba5c94c7047dbd18e9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f0c3b3e6c10ba5c94c7047dbd18e9e8">output_Node_Char</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a2f0c3b3e6c10ba5c94c7047dbd18e9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the node address to char() and outputs it.  <br /></td></tr>
<tr class="separator:a2f0c3b3e6c10ba5c94c7047dbd18e9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af800a27f84cbcbaaf20778342fef8bb5" id="r_af800a27f84cbcbaaf20778342fef8bb5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af800a27f84cbcbaaf20778342fef8bb5">new_Node</a> ()</td></tr>
<tr class="memdesc:af800a27f84cbcbaaf20778342fef8bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to differentiate a new construct, allocates a state tree to handle a state-node space.  <br /></td></tr>
<tr class="separator:af800a27f84cbcbaaf20778342fef8bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692f286375b7b06c646a8f5f549b49d0" id="r_a692f286375b7b06c646a8f5f549b49d0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692f286375b7b06c646a8f5f549b49d0">new_State_Node</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a692f286375b7b06c646a8f5f549b49d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node, binds it to a state, sets the type to 0 or 3 depending, and adds the node to the state tree with the state registered.  <br /></td></tr>
<tr class="separator:a692f286375b7b06c646a8f5f549b49d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48748e63a8fc09caec37456702194a6c" id="r_a48748e63a8fc09caec37456702194a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48748e63a8fc09caec37456702194a6c">create_Connections</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a48748e63a8fc09caec37456702194a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a connection between nodes.  <br /></td></tr>
<tr class="separator:a48748e63a8fc09caec37456702194a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f472fb6461e3a1460b81e20b5e43c94" id="r_a9f472fb6461e3a1460b81e20b5e43c94"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f472fb6461e3a1460b81e20b5e43c94">does_Upper_Tier_Connection_Exist_Network</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a9f472fb6461e3a1460b81e20b5e43c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an upper tier node exists, functionally the same as does_Upper_Tier_Connection_Exist on the node, but this includes error handling.  <br /></td></tr>
<tr class="separator:a9f472fb6461e3a1460b81e20b5e43c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00c38697a0af6242ebe8d03f3622edc" id="r_ab00c38697a0af6242ebe8d03f3622edc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab00c38697a0af6242ebe8d03f3622edc">get_Upper_Tier_Node</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ab00c38697a0af6242ebe8d03f3622edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an upper tier node based on the given legs, will create it if not found.  <br /></td></tr>
<tr class="separator:ab00c38697a0af6242ebe8d03f3622edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e2882099251f5f94fafa9598955e5d" id="r_a90e2882099251f5f94fafa9598955e5d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90e2882099251f5f94fafa9598955e5d">does_State_Node_Exist</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a90e2882099251f5f94fafa9598955e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a state node exists in the given construct index then return it, otherwise return 0.  <br /></td></tr>
<tr class="separator:a90e2882099251f5f94fafa9598955e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87101ad825a93638ec15d1c9411f10c6" id="r_a87101ad825a93638ec15d1c9411f10c6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87101ad825a93638ec15d1c9411f10c6">get_State_Node</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a87101ad825a93638ec15d1c9411f10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a node in the given Construct is bound to the given state, if not the node is created &amp; the NID returned, if found the NID is returned.  <br /></td></tr>
<tr class="separator:a87101ad825a93638ec15d1c9411f10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c506f9322c7310f679f0944a5943d30" id="r_a7c506f9322c7310f679f0944a5943d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c506f9322c7310f679f0944a5943d30">output_Backpropagated_Symbols</a> ()</td></tr>
<tr class="memdesc:a7c506f9322c7310f679f0944a5943d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through every node and outputs their <a class="el" href="#a9516daf43b865cb75bb98949b375ab49" title="Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern ...">bp_O()</a>  <br /></td></tr>
<tr class="separator:a7c506f9322c7310f679f0944a5943d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e0d6bff658785121a684187f9e3e38" id="r_ab9e0d6bff658785121a684187f9e3e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9e0d6bff658785121a684187f9e3e38">output_Backpropagated_Symbol_NID</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ab9e0d6bff658785121a684187f9e3e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds given NID and outputs the <a class="el" href="#a9516daf43b865cb75bb98949b375ab49" title="Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern ...">bp_O()</a>.  <br /></td></tr>
<tr class="separator:ab9e0d6bff658785121a684187f9e3e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa850c7ca8094730d117ef52c0bb63f93" id="r_aa850c7ca8094730d117ef52c0bb63f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa850c7ca8094730d117ef52c0bb63f93">encode</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:aa850c7ca8094730d117ef52c0bb63f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the current input of the given Construct.  <br /></td></tr>
<tr class="separator:aa850c7ca8094730d117ef52c0bb63f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7c049185d08bb31ffd5a54564572ad" id="r_adc7c049185d08bb31ffd5a54564572ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7c049185d08bb31ffd5a54564572ad">query</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:adc7c049185d08bb31ffd5a54564572ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the network with the current input set for the given construct, evaluates the input set and stores the results in the output traces, gathered using 'gather_Output'.  <br /></td></tr>
<tr class="separator:adc7c049185d08bb31ffd5a54564572ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d33fb55089f40f7b4821750c1cedcbb" id="r_a6d33fb55089f40f7b4821750c1cedcbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d33fb55089f40f7b4821750c1cedcbb">query_Spacial</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a6d33fb55089f40f7b4821750c1cedcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the network with the current input set of the given Construct, but the input index determines what leg is charged.  <br /></td></tr>
<tr class="separator:a6d33fb55089f40f7b4821750c1cedcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a9a9996d29030fc6165ff49eeb79cf" id="r_ac3a9a9996d29030fc6165ff49eeb79cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3a9a9996d29030fc6165ff49eeb79cf">query_Given_Index</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ac3a9a9996d29030fc6165ff49eeb79cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the network with the current input set, however, every input node is charged using the given index.  <br /></td></tr>
<tr class="separator:ac3a9a9996d29030fc6165ff49eeb79cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6b56adab575328125b8650ff74ac6d" id="r_a0d6b56adab575328125b8650ff74ac6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d6b56adab575328125b8650ff74ac6d">query_Given_Legs</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a0d6b56adab575328125b8650ff74ac6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the network using the current input set of the given Construct, however, an array of legs is passed that signifies whether or not each individual leg is to be charged and every input queried to all axon_hillocks/legs set to fire.  <br /></td></tr>
<tr class="separator:a0d6b56adab575328125b8650ff74ac6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a44fd1ad282b65fd014292c39c66bbe" id="r_a6a44fd1ad282b65fd014292c39c66bbe"><td class="memItemLeft" align="right" valign="top"><a id="a6a44fd1ad282b65fd014292c39c66bbe" name="a6a44fd1ad282b65fd014292c39c66bbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>submit_Set</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a6a44fd1ad282b65fd014292c39c66bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42ad6252407a2a611c6a05bf4d0704f" id="r_ad42ad6252407a2a611c6a05bf4d0704f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad42ad6252407a2a611c6a05bf4d0704f">get_Treetop_NID</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ad42ad6252407a2a611c6a05bf4d0704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the treetop node for a given construct and puts it in the output file for that construct.  <br /></td></tr>
<tr class="separator:ad42ad6252407a2a611c6a05bf4d0704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb7d938b9748a1a89b9e07fc822be06" id="r_a1cb7d938b9748a1a89b9e07fc822be06"><td class="memItemLeft" align="right" valign="top"><a id="a1cb7d938b9748a1a89b9e07fc822be06" name="a1cb7d938b9748a1a89b9e07fc822be06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_Treetop_NID_To_Other_Input</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a1cb7d938b9748a1a89b9e07fc822be06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dd21a221a907189867c9de4795189f" id="r_a35dd21a221a907189867c9de4795189f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35dd21a221a907189867c9de4795189f">gather_Given_Trace</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a35dd21a221a907189867c9de4795189f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a single trace from a given node, puts it in the output file for the given construct.  <br /></td></tr>
<tr class="separator:a35dd21a221a907189867c9de4795189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b72cfd11215badc3a4b9b2481525d5" id="r_ac0b72cfd11215badc3a4b9b2481525d5"><td class="memItemLeft" align="right" valign="top"><a id="ac0b72cfd11215badc3a4b9b2481525d5" name="ac0b72cfd11215badc3a4b9b2481525d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_Given_Pattern_As_Number</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:ac0b72cfd11215badc3a4b9b2481525d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8037394004a42a8b735c6b19280ba" id="r_a11e8037394004a42a8b735c6b19280ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e8037394004a42a8b735c6b19280ba">gather_All_Traces</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a11e8037394004a42a8b735c6b19280ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all the traces through a given construct.  <br /></td></tr>
<tr class="separator:a11e8037394004a42a8b735c6b19280ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9ddfbfdb1b7121e644b7d09ca52740" id="r_a5b9ddfbfdb1b7121e644b7d09ca52740"><td class="memItemLeft" align="right" valign="top"><a id="a5b9ddfbfdb1b7121e644b7d09ca52740" name="a5b9ddfbfdb1b7121e644b7d09ca52740"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gather_All_Traces_uint</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a5b9ddfbfdb1b7121e644b7d09ca52740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eebf315113910670ef8f01b5bebc9f" id="r_ad4eebf315113910670ef8f01b5bebc9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4eebf315113910670ef8f01b5bebc9f">reset_Input</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ad4eebf315113910670ef8f01b5bebc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wipe the input array of a given construct.  <br /></td></tr>
<tr class="separator:ad4eebf315113910670ef8f01b5bebc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be6c291b0c5ad8be48b09bc144bed68" id="r_a3be6c291b0c5ad8be48b09bc144bed68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be6c291b0c5ad8be48b09bc144bed68">set_State_Nodes_Index</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a3be6c291b0c5ad8be48b09bc144bed68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the index for the given Construct state_Node_Tree.  <br /></td></tr>
<tr class="separator:a3be6c291b0c5ad8be48b09bc144bed68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ecf7c8d1e5a740d9a33fe12d10a5ad" id="r_a04ecf7c8d1e5a740d9a33fe12d10a5ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04ecf7c8d1e5a740d9a33fe12d10a5ad">set_Input</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a04ecf7c8d1e5a740d9a33fe12d10a5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the input of a given construct to the given input string.  <br /></td></tr>
<tr class="separator:a04ecf7c8d1e5a740d9a33fe12d10a5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d02da651068631fb3407d219d0c0d8e" id="r_a5d02da651068631fb3407d219d0c0d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d02da651068631fb3407d219d0c0d8e">set_Input_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a5d02da651068631fb3407d219d0c0d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input of a given construct to the given array of uint64_t values.  <br /></td></tr>
<tr class="separator:a5d02da651068631fb3407d219d0c0d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f6d41f7606e828a95f21b1806cad1d" id="r_ae9f6d41f7606e828a95f21b1806cad1d"><td class="memItemLeft" align="right" valign="top"><a id="ae9f6d41f7606e828a95f21b1806cad1d" name="ae9f6d41f7606e828a95f21b1806cad1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_2D_Input_uint</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:ae9f6d41f7606e828a95f21b1806cad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2ac52514074d3c2c66dccaa4d4e909" id="r_aac2ac52514074d3c2c66dccaa4d4e909"><td class="memItemLeft" align="right" valign="top"><a id="aac2ac52514074d3c2c66dccaa4d4e909" name="aac2ac52514074d3c2c66dccaa4d4e909"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_3D_Input_uint</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:aac2ac52514074d3c2c66dccaa4d4e909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc16f0b743a80c04e0e47fd83ffb97bb" id="r_acc16f0b743a80c04e0e47fd83ffb97bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc16f0b743a80c04e0e47fd83ffb97bb">output_Scaffold</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:acc16f0b743a80c04e0e47fd83ffb97bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the scaffold as node IDs.  <br /></td></tr>
<tr class="separator:acc16f0b743a80c04e0e47fd83ffb97bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af346f81c04d6cfa0712ca66db150cd89" id="r_af346f81c04d6cfa0712ca66db150cd89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af346f81c04d6cfa0712ca66db150cd89">output_Input</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:af346f81c04d6cfa0712ca66db150cd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the input of the given construct to the console.  <br /></td></tr>
<tr class="separator:af346f81c04d6cfa0712ca66db150cd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833cfaa472bf0da4bd535545d531cbad" id="r_a833cfaa472bf0da4bd535545d531cbad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a833cfaa472bf0da4bd535545d531cbad">output_Input_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a833cfaa472bf0da4bd535545d531cbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the input of the given construct to the console, but as uint.  <br /></td></tr>
<tr class="separator:a833cfaa472bf0da4bd535545d531cbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1031c653941bdb9c55e6c8aca08bf40" id="r_ae1031c653941bdb9c55e6c8aca08bf40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1031c653941bdb9c55e6c8aca08bf40">output_Output</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ae1031c653941bdb9c55e6c8aca08bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output trace set is output.  <br /></td></tr>
<tr class="separator:ae1031c653941bdb9c55e6c8aca08bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9279e34a8b5696e5f1ae82d4c22f305e" id="r_a9279e34a8b5696e5f1ae82d4c22f305e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9279e34a8b5696e5f1ae82d4c22f305e">output_Output_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a9279e34a8b5696e5f1ae82d4c22f305e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output trace set is output as uint64_t.  <br /></td></tr>
<tr class="separator:a9279e34a8b5696e5f1ae82d4c22f305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c3f4474c46f982f07317f9e6c274e3" id="r_a23c3f4474c46f982f07317f9e6c274e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23c3f4474c46f982f07317f9e6c274e3">output_Scaffold_Char</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a23c3f4474c46f982f07317f9e6c274e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the scaffold as characters typecase from the ID.  <br /></td></tr>
<tr class="separator:a23c3f4474c46f982f07317f9e6c274e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a353a9fb4ae478baa66f0014869544" id="r_ae8a353a9fb4ae478baa66f0014869544"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8a353a9fb4ae478baa66f0014869544">register_Construct</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ae8a353a9fb4ae478baa66f0014869544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a Construct with the neural net engine of the given architecture and name desired.  <br /></td></tr>
<tr class="separator:ae8a353a9fb4ae478baa66f0014869544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5e745eb4e47fee0064ca92aa0c2ed" id="r_ae2a5e745eb4e47fee0064ca92aa0c2ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2a5e745eb4e47fee0064ca92aa0c2ed">load_Input</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ae2a5e745eb4e47fee0064ca92aa0c2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the input file associated with the given construct into the input array.  <br /></td></tr>
<tr class="separator:ae2a5e745eb4e47fee0064ca92aa0c2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd245de8b70cde87aeec9ef5f9ee7e2" id="r_addd245de8b70cde87aeec9ef5f9ee7e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd245de8b70cde87aeec9ef5f9ee7e2">load_Input_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:addd245de8b70cde87aeec9ef5f9ee7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the input file associated with the given construct into the input array as uint.  <br /></td></tr>
<tr class="separator:addd245de8b70cde87aeec9ef5f9ee7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d09c754a3899a0b1c75a57624e3715" id="r_a94d09c754a3899a0b1c75a57624e3715"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94d09c754a3899a0b1c75a57624e3715">gather_Given_Node</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a94d09c754a3899a0b1c75a57624e3715"><td class="mdescLeft">&#160;</td><td class="mdescRight">This outputs the patterns as string when given a node ID (NID).  <br /></td></tr>
<tr class="separator:a94d09c754a3899a0b1c75a57624e3715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6662cc0306ac130aaa444daf461e5028" id="r_a6662cc0306ac130aaa444daf461e5028"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6662cc0306ac130aaa444daf461e5028">gather_Given_Node_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a6662cc0306ac130aaa444daf461e5028"><td class="mdescLeft">&#160;</td><td class="mdescRight">This outputs the patterns as an array of uint64_t when given a node ID (NID).  <br /></td></tr>
<tr class="separator:a6662cc0306ac130aaa444daf461e5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace28357789021a38f7a2eda4b5cfc569" id="r_ace28357789021a38f7a2eda4b5cfc569"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace28357789021a38f7a2eda4b5cfc569">gather_All_Nodes</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ace28357789021a38f7a2eda4b5cfc569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all of the nodes to the given constructs output.  <br /></td></tr>
<tr class="separator:ace28357789021a38f7a2eda4b5cfc569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade341194e7e36688780577a8394029df" id="r_ade341194e7e36688780577a8394029df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade341194e7e36688780577a8394029df">gather_All_Nodes_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ade341194e7e36688780577a8394029df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all of the nodes to the given constructs output as an array of uint64_t.  <br /></td></tr>
<tr class="separator:ade341194e7e36688780577a8394029df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0aa5a19bde777d70075936f32e8574" id="r_a7e0aa5a19bde777d70075936f32e8574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e0aa5a19bde777d70075936f32e8574">gather_Output</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a7e0aa5a19bde777d70075936f32e8574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as char.  <br /></td></tr>
<tr class="separator:a7e0aa5a19bde777d70075936f32e8574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22244e0f8ca7d9dd0a2d024878196e48" id="r_a22244e0f8ca7d9dd0a2d024878196e48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22244e0f8ca7d9dd0a2d024878196e48">gather_Output_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a22244e0f8ca7d9dd0a2d024878196e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as uint64_t.  <br /></td></tr>
<tr class="separator:a22244e0f8ca7d9dd0a2d024878196e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f78ebe85659943e8acbcddf9241b29" id="r_ad7f78ebe85659943e8acbcddf9241b29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7f78ebe85659943e8acbcddf9241b29">gather_Treetop_Node</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:ad7f78ebe85659943e8acbcddf9241b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node.  <br /></td></tr>
<tr class="separator:ad7f78ebe85659943e8acbcddf9241b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01af422b47451f4761ea60e74b59eb16" id="r_a01af422b47451f4761ea60e74b59eb16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01af422b47451f4761ea60e74b59eb16">gather_Treetop_Node_uint</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a01af422b47451f4761ea60e74b59eb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node, the output pattern will be uint64_t.  <br /></td></tr>
<tr class="separator:a01af422b47451f4761ea60e74b59eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd787a6e3a33287c796d314f26795a3" id="r_a7dd787a6e3a33287c796d314f26795a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dd787a6e3a33287c796d314f26795a3">gather_Treetop_NID</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a7dd787a6e3a33287c796d314f26795a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the current treetop node from the CAN Scaffold (if one exists) and outputs the NID to the output file.  <br /></td></tr>
<tr class="separator:a7dd787a6e3a33287c796d314f26795a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace487ecd8487fd6067328068d8d8e7bd" id="r_ace487ecd8487fd6067328068d8d8e7bd"><td class="memItemLeft" align="right" valign="top"><a id="ace487ecd8487fd6067328068d8d8e7bd" name="ace487ecd8487fd6067328068d8d8e7bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gather_Treetops</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:ace487ecd8487fd6067328068d8d8e7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011c9a43a83319a0041c71e9ed00502" id="r_ad011c9a43a83319a0041c71e9ed00502"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad011c9a43a83319a0041c71e9ed00502">output_Node_Network</a> ()</td></tr>
<tr class="memdesc:ad011c9a43a83319a0041c71e9ed00502"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterates through every node outputting them to the console.  <br /></td></tr>
<tr class="separator:ad011c9a43a83319a0041c71e9ed00502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659a1d8e9f942ea65a0e675000759478" id="r_a659a1d8e9f942ea65a0e675000759478"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a659a1d8e9f942ea65a0e675000759478">output_Node</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a659a1d8e9f942ea65a0e675000759478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a given node as defined by the passed NID to the console.  <br /></td></tr>
<tr class="separator:a659a1d8e9f942ea65a0e675000759478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb0b312172cf044fc9454bd4b9f9f75" id="r_a6cb0b312172cf044fc9454bd4b9f9f75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb0b312172cf044fc9454bd4b9f9f75">output_Constructs</a> ()</td></tr>
<tr class="memdesc:a6cb0b312172cf044fc9454bd4b9f9f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the constructs currently registered.  <br /></td></tr>
<tr class="separator:a6cb0b312172cf044fc9454bd4b9f9f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c25f72831938747ca959cc423e2985" id="r_a07c25f72831938747ca959cc423e2985"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c25f72831938747ca959cc423e2985">clear_Output</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a07c25f72831938747ca959cc423e2985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wipes and output file for a given construct, CLS for the output file.  <br /></td></tr>
<tr class="separator:a07c25f72831938747ca959cc423e2985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d6675fb0650c609d6f89940bd1c487" id="r_a67d6675fb0650c609d6f89940bd1c487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d6675fb0650c609d6f89940bd1c487">output_Newline</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a67d6675fb0650c609d6f89940bd1c487"><td class="mdescLeft">&#160;</td><td class="mdescRight">You give it a construct ID and it outputs a newline to the output file associated with that construct.  <br /></td></tr>
<tr class="separator:a67d6675fb0650c609d6f89940bd1c487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905b0083a314f165d0ec3277704a73a1" id="r_a905b0083a314f165d0ec3277704a73a1"><td class="memItemLeft" align="right" valign="top"><a id="a905b0083a314f165d0ec3277704a73a1" name="a905b0083a314f165d0ec3277704a73a1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>write_Text</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:a905b0083a314f165d0ec3277704a73a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6f27d2f8ef5575b1baf91d3ed45ee2" id="r_a2d6f27d2f8ef5575b1baf91d3ed45ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d6f27d2f8ef5575b1baf91d3ed45ee2">save</a> (std::ifstream *p_File)</td></tr>
<tr class="memdesc:a2d6f27d2f8ef5575b1baf91d3ed45ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief  <br /></td></tr>
<tr class="separator:a2d6f27d2f8ef5575b1baf91d3ed45ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecda355f7fad19a0d05a0ba6f951e28d" id="r_aecda355f7fad19a0d05a0ba6f951e28d"><td class="memItemLeft" align="right" valign="top"><a id="aecda355f7fad19a0d05a0ba6f951e28d" name="aecda355f7fad19a0d05a0ba6f951e28d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>load</b> (std::ifstream *p_File)</td></tr>
<tr class="separator:aecda355f7fad19a0d05a0ba6f951e28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e7529b9409186f7c4daff83c0b238e" id="r_a88e7529b9409186f7c4daff83c0b238e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88e7529b9409186f7c4daff83c0b238e">run</a> ()</td></tr>
<tr class="memdesc:a88e7529b9409186f7c4daff83c0b238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main loop for the neuro-server.  <br /></td></tr>
<tr class="separator:a88e7529b9409186f7c4daff83c0b238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a handshake based text interface for the engine. </p>
<p>File-Based Command Control System for Asynchronous Standalone Neural-Net Engine Control:</p>
<p>Text-Based Command Execution:</p><ul>
<li>Commands are represented as text strings that specify actions or operations to be performed by the system or process.</li>
<li>Each command is associated with a specific functionality or operation within the system.</li>
</ul>
<p>File I/O:</p><ul>
<li>Input and output operations are performed using files as the medium of communication.</li>
<li>Commands are read from input files, and outputs, returns, and status indicators are written to output files, though some commands do output to the console.</li>
<li>This method facilitates asynchronous communication between systems, as they can read from and write to files independently.</li>
</ul>
<p>Handshake Protocol:</p><ul>
<li>A handshake protocol is used to establish communication or synchronize actions between systems.</li>
<li>In this context, a flag file serves as a mechanism for signaling the readiness or completion of certain operations, namely that the user has written a command sequence to 'Control_Panel.ssv' that is ready to be interpreted..</li>
<li>The content of the flag file is used to indicate the status of the control panel, allowing the system to either wait or act accordingly.</li>
</ul>
<p>Flag File:</p><ul>
<li>A flag file is a small file used to signal the status or state of the system.</li>
<li>It typically contains simple data or metadata, such as a single value or indicator, to convey information. In the <a class="el" href="namespace_n_t4.html" title="This is the namespace which encapsulates the NT4 Neural-Net Engine and the interfaces.">NT4</a> text interface it is a boolean value.</li>
<li>Flag files are used as synchronization primitives to coordinate activities between systems.</li>
</ul>
<p>Control Panel:</p><ul>
<li>The control panel represents a set of commands or instructions that can be executed by the system or process.</li>
<li>It is stored in a separate file (e.g., Control_Panel.ssv), which contains a sequence of commands or directives to be processed.</li>
</ul>
<p>Interpretation and Execution:</p><ul>
<li>The system interprets commands read from the control file (e.g., Control_Panel.ssv) and executes them sequentially.</li>
<li>Command execution may involve performing operations on data, manipulating the state of the system, or interacting with external resources.</li>
</ul>
<p>Status Checking and Control Flow:</p><ul>
<li>The system periodically checks the status of a flag file (e.g., Control_Panel_Flag.ssv) to determine if there are new commands to execute or if certain operations have completed.</li>
<li>Based on the status indicated by the flag file, the system may initiate specific actions, continue processing, or wait for further instructions.</li>
</ul>
<p>Startup and 'autoexec.ssv':</p><ul>
<li>For 'booting up' the system interprets the commands found in 'autoexec.ssv' sequentially. This allows for shell scripting a startup sequence.</li>
</ul>
<p>Custom Commands:</p><ul>
<li>A script file placed in "./Scripts/" can be called by simply entering the filename as you would a command token. A file can call other files so you can create dependency hell for yourself if you wish, but with the added complexity of ML. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af9c1608480eecd776b3bd4a182956a47" name="af9c1608480eecd776b3bd4a182956a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c1608480eecd776b3bd4a182956a47">&#9670;&#160;</a></span>add_Axon_Index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::add_Axon_Index </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a given NID to an Axon on the given Hillock. </p>
<p>Note this is selecting a hillock not assigning an axonal ID, if the index doesn't exist then exist it with resize_Axon_Hillocks()</p>
<p>add_axon_index NID Axon_NID HILLOCK_INDEX </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID (NID) of the node being manipulated. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>AXON_NID The NID of the node that the axon will reference. </td></tr>
    <tr><td class="paramname">int</td><td>INDEX The hillock the axon is put onto, not the axon ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>The nodes keep track of which dendrite their upper connections are connected to by encoding them into respective "axon hillocks". Basically we take whichever dendrite index the connection is connected to and create an axonic group that represents those connections to legs of that index. This allows for advanced search of the networks including time-series and more.</p>
<p>Example Usage:</p>
<p>Adding an axonic connection to node 42 on axon hillock 5 of node 16 to represent that it is Dendrite[5] on the node above. We will use output_Node_Raw after setting the axon to show the result. This assumes no previous axonic connections or dendrites and it is a quanta bound state node with the state set to the uint64_t value 99. </p><pre class="fragment">output_Node_Raw 16
add_Axon_Index 16 42 5
output_Node_Raw 16
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 16 RC: 1 Type: 0  State { 99 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 16 RC: 1 Type: 0  State { 99 } --- Dendrites:  --- Axon_Hillock_Count: 6  Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;0&gt;:  Axons[3] &lt;0&gt;:  Axons[4] &lt;0&gt;:  Axons[5] &lt;1&gt;: [0] 42
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash.</li>
<li>Invalid axon IDs will not cause an immediate crash, but any function which touches the axons will crash when attemting to reference the invalid axon NIDs. </li>
</ul>

</div>
</div>
<a id="ae006adef321f75481453c3478006d68d" name="ae006adef321f75481453c3478006d68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae006adef321f75481453c3478006d68d">&#9670;&#160;</a></span>bind_State()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::bind_State </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a node to a quanta of data, the state of the input, as uint64_t. </p>
<p>bind_State NID STATE </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID of the node being manipulated. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NID The state of the input, the current quanta, or element, of information being encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>At the interface between the networks internal node structure and the exterior information space exists the state tier, this is the interface where outside information binds to nodes to allow for communication coherently across the internal/external space. Outside you have the information to be encoded, this information is composed of differentiated information, the smallest piece of coherent information that the abstractions are built upon is the quanta. This quanta is a pixel, a character, an integer, a scalar value. A quantifiable and discrete piece of information which forms the basis of the patterns of information you will be encoding/decoding from the neural matrix. This doesn't have to be low level abstraction wise, only that is has a hash or scalar abstraction that can be cast to uint64. It could represent the hash of a full 3D body scan as easily as a scalar value from a thermal sensor.</p>
<p>This function binds the state to the node to form the interface, an absolutely crucial function to the distributed symbol neural networks.</p>
<p>Example Usage:</p>
<p>We will bind the uint state 1234321 to node 10, outputting the node before and after the operation using 'output_Node_Raw 10'. </p><pre class="fragment">output_Node_Raw 10
bind_State 10 1234321
output_Node_Raw 10
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 10 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 10 RC: 1 Type: 0  State { 1234321 } --- Dendrites:  --- Axon_Hillock_Count: 0
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash. </li>
</ul>

</div>
</div>
<a id="a9516daf43b865cb75bb98949b375ab49" name="a9516daf43b865cb75bb98949b375ab49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9516daf43b865cb75bb98949b375ab49">&#9670;&#160;</a></span>bp_O()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::bp_O </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern represented by this node. </p>
<p>bp_O NID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID of the node who's information symbol is being output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>The patterns that are encoded, the traces, are encoded in a deterministic and hierarchical manner. This allows us the oppurtunity to craft algorithms to "walk" the structure down and retrieve the original input pattern stored in the relationships of the nodes on the various tiers, or layers, or abstraction.</p>
<p>This function outputs the full symbol represented by the node given. It walks the tree to output the pattern perfectly as it was originally encoded.</p>
<p>Example Usage:</p>
<p>In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 1-9 have already been created so our first node will be NID 10. This results in 4 nodes created, 3 state tier nodes { 10, 11, 12 } and 1 upper tier treetop node { 13 }. We will output all the nodes, then demonstrate the bp_O. </p><pre class="fragment">output_Node_Raw 10
output_Node_Raw 11
output_Node_Raw 12
output_Node_Raw 13
bp_O 13
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 10 RC: 1 Type: 0  State { 64 } --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] &lt;1&gt;: 13
Node_ID (NID) 11 RC: 1 Type: 0  State { 128 } --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] &lt;0&gt;:  Axons[1] &lt;1&gt;: 13
Node_ID (NID) 12 RC: 1 Type: 0  State { 256 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;1&gt;: 13
Node_ID (NID) 13 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 10 [1] 11 [2] 12 --- Axon_Hillock_Count: 0
&lt;=- 13 * [double(64), 64]  [double(128), 128]  [double(256), 256] -=&gt;
</pre><ul>
<li>Note that the 'double(n)' in the real output is the actual cast value and not the typecast definition.</li>
</ul>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash.</li>
<li>If you crash when calling this and the node is valid then check your dendrites. </li>
</ul>

</div>
</div>
<a id="a07c25f72831938747ca959cc423e2985" name="a07c25f72831938747ca959cc423e2985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c25f72831938747ca959cc423e2985">&#9670;&#160;</a></span>clear_Output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::clear_Output </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wipes and output file for a given construct, CLS for the output file. </p>
<p>clear_Output CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The ID of the construct who's output file is getting deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Opens the output file associated with the given construct using truncate (ios::ate) to wipe the file.</p>
<p>Used in scripting for manipulating the output files through the engine to wipe them, or manually, but this allows obtuse control through the engine.</p>
<p>Example Usage:</p>
<p>Here we setup a construct, encode a string, gather the treetop node into the output file, output the output, wipe the output using this function, then recheck the output file to make sure: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 Night Gaunt /end/
encode 0
gather_Treetop_Node 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">11 2 11 1 2 3 4 5 6 7 8 9 10 5 0 11 Night Gaunt
</pre><p> Now we use this function to wipe the file: </p><pre class="fragment">clear_Output 0
</pre><p> Output: Contents of "./Output/ExaCon.Output.ssv":</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a48748e63a8fc09caec37456702194a6c" name="a48748e63a8fc09caec37456702194a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48748e63a8fc09caec37456702194a6c">&#9670;&#160;</a></span>create_Connections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::create_Connections </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a connection between nodes. </p>
<p>create_Connections TO_NID COUNT FROM_NIDS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>TO_NID This is the node that all the lower nodes connect to, the one that receives the dendritic connections. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODE_COUNT The number of nodes to connect to the upper tier node. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODES The array of node NIDs that are the lower nodes, they receive the axonic connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>p_To forms dendritic connections to p_From, and on p_From you have the axonic connections. This function uses set_Dendrites on the upper tier node and sets the axon for the lower nodes to create the two way connection. The doubly linked tiered nodes.</p>
<p>Example Usage:</p>
<p>In this example we have an upper tier node we created with the NID 100, and 5 lower nodes with NIDs { 10, 20, 30, 40, 50 }. We assume no nodes have any connections as of yet. We will be outputting the nodes before and after. </p><pre class="fragment">output_Node_Raw 10
output_Node_Raw 20
output_Node_Raw 30
output_Node_Raw 40 
output_Node_Raw 50
output_Node_Raw 100

create_Connections 100 5 10 20 30 40 50

output_Node_Raw 10
output_Node_Raw 20
output_Node_Raw 30
output_Node_Raw 40
output_Node_Raw 50
output_Node_Raw 100
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 10 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 20 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 30 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 40 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 50 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 100 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0

Node_ID (NID) 10 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] &lt;1&gt;: 100
Node_ID (NID) 20 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] &lt;0&gt;:  Axons[1] &lt;1&gt;: 100
Node_ID (NID) 30 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;1&gt;: 100
Node_ID (NID) 40 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;0&gt;:   Axons[2] &lt;1&gt;: 100
Node_ID (NID) 50 RC: 1 Type: 0  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;0&gt;:   Axons[2] &lt;0&gt;:   Axons[2] &lt;1&gt;: 100
Node_ID (NID) 100 RC: 1 Type: 0  State { 0 } --- Dendrites: [0] 10 [1] 20 [2] 30 [3] 40 [4] 50  --- Axon_Hillock_Count: 0
</pre><p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>This does nothing for setting or binding states, or setting node types, this function is purely to create these connections.</li>
<li>Passing invalid nodes will cause it to crash when it tries to call the NULL object to create either dendrite or axon connections. </li>
</ul>

</div>
</div>
<a id="af740c907e03325e299d611e270bb6e40" name="af740c907e03325e299d611e270bb6e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af740c907e03325e299d611e270bb6e40">&#9670;&#160;</a></span>does_Lower_Connection_Exist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool c_Construct_Text_Server::does_Lower_Connection_Exist </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given node has dendrites that match the given nodes in the given order. </p>
<p>does_Lower_Connection_Exist NID NODE_COUNT NODES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID of the node being manipulated. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODES The array of NIDs to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>This function returns a 1 (true) or 0 (false) depending on whether the dendrites match the given nodes or not.</td></tr>
  </table>
  </dd>
</dl>
<p>This takes a given node and a set of node IDs (NIDs) to check. It checks each dendrite leg against the given node list to see if they all match or not. If one is found that doesn't match it return 0 immediately. Used during encoding to find out whether a compound higher tier symbol has been encoded yet.</p>
<p>Example Usage:</p>
<p>We will check node 75 which has the dendrites { 5, 6, 7 } to see if it matches the given dendrite set { 5, 6, 8 }, which we know it does not. Then we will output a newline in the output file and check node 76 which in this example has the dendrites { 5, 6, 8 } which match the given set outputting 1 to the RETURN_FILE. Before checking each node we'll output it to show the dendrites so you can see them yourself. </p><pre class="fragment">output_Node_Raw 75
does_Lower_Connection_Exist 75 3 5 6 8
newline returns
output_Node_Raw 76
does_Lower_Connection_Exist 76 3 5 6 8
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0
Node_ID (NID) 76 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 8 --- Axon_Hillock_Count: 0
</pre><p> Contents of the RETURN_FILE: </p><pre class="fragment">0
1
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash.</li>
<li>If the given node count exceeds the dendrite count you will cause it to crash. This is due to the function assuming the count will not exceed the number of defined dendrites and iterates trustfully through it. This is by design as this function will be called many often and is a potential bottleneck. </li>
</ul>

</div>
</div>
<a id="a90e2882099251f5f94fafa9598955e5d" name="a90e2882099251f5f94fafa9598955e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e2882099251f5f94fafa9598955e5d">&#9670;&#160;</a></span>does_State_Node_Exist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::does_State_Node_Exist </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a state node exists in the given construct index then return it, otherwise return 0. </p>
<p>does_State_Node_Exist CONSTRUCT_ID STATE </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>NID The node that represents the state passed to this function. Passes the NID back if found, if not found it passes back 0.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks the state tree of a given construct to see if the state is registered and bound to a node within that state space.</p>
<p>Example Usage:</p>
<p>We have a state node registered to construct 3 with the state 123. This state node is NID 50. We run 'does_State_Node_Exist 2 123' which returns the NID 50 as it found the node bound to the state '123' registered within construct 2's fractal state tree. </p><pre class="fragment">does_State_Node_Exist 2 123
</pre><p> Output:</p>
<p>Contents of the RETURN_FILE: </p><pre class="fragment">50
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>This assumes the [CONSTRUCT_ID] is valid </li>
</ul>

</div>
</div>
<a id="ae1e8fcbb11b03289e2a011cf464224fa" name="ae1e8fcbb11b03289e2a011cf464224fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e8fcbb11b03289e2a011cf464224fa">&#9670;&#160;</a></span>does_Upper_Tier_Connection_Exist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::does_Upper_Tier_Connection_Exist </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the axons to see if an upper tier connection exists, if found returns the NID, if not returns 0. </p>
<p>does_Upper_Tier_Connection_Exist NODE_COUNT NODES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODES The array of NIDs to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>NID This function return the NID of a node matching the description, returns 0 if none are found.</td></tr>
  </table>
  </dd>
</dl>
<p>This is used during encoding and performing a query. It traverses the connections in the given NID's first axon hillock. For each of these connections it does a does_Lower_Connection_Exist to see if that node matches. By searching the first legs we keep the search limited to only those with the possiblity to match the search string of connections. We know this is the case because if the first node in a string of nodes has an upper tier connection then that gives us a connection to a node that at least shares index[0] with our current lower-tier node and by checking every other dendrite index of the upper tier node against the respective index in the passed node array we can know for sure if our current pattern exists yet. After checking all of the upper tier connections on axon hillock 0 if we come up with no confirmed connections we know that the current arrangement of nodes hasn't been encoded into a higher tier node symbol yet.</p>
<p>Example Usage:</p>
<p>We will use the example containing a set of nodes { 5 6 7 }, node 5 has 2 axonic connections with the second having the correct configuration of legs meaning we found it. This second node has the NID 75, we know node 75 has the correct connection so we output it manually to show the node data. </p><pre class="fragment">output_Raw_Node 75
does_Upper_Tier_Connection_Exist 3 5 6 7
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0
</pre><p> Contents of the RETURN_FILE: </p><pre class="fragment">75
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash. </li>
</ul>

</div>
</div>
<a id="a9f472fb6461e3a1460b81e20b5e43c94" name="a9f472fb6461e3a1460b81e20b5e43c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f472fb6461e3a1460b81e20b5e43c94">&#9670;&#160;</a></span>does_Upper_Tier_Connection_Exist_Network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::does_Upper_Tier_Connection_Exist_Network </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an upper tier node exists, functionally the same as does_Upper_Tier_Connection_Exist on the node, but this includes error handling. </p>
<p>does_Upper_Tier_Connection_Exist_Network NODE_COUNT NODES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODES The array of NIDs to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>NID This function return the NID of a node matching the description, returns 0 if none are found.</td></tr>
  </table>
  </dd>
</dl>
<p>This is used during encoding and performing a query. It traverses the connections in the given NID's first axon hillock. For each of these connections it does a does_Lower_Connection_Exist to see if that node matches. By searching the first legs we keep the search limited to only those with the possiblity to match the search string of connections. We know this is the case because if the first node in a string of nodes has an upper tier connection then that gives us a connection to a node that at least shares index[0] with our current lower-tier node and by checking every other dendrite index of the upper tier node against the respective index in the passed node array we can know for sure if our current pattern exists yet. After checking all of the upper tier connections on axon hillock 0 if we come up with no confirmed connections we know that the current arrangement of nodes hasn't been encoded into a higher tier node symbol yet.</p>
<p>Example Usage:</p>
<p>We will use the example containing a set of nodes { 5 6 7 }, node 5 has 2 axonic connections with the second having the correct configuration of legs meaning we found it. This second node has the NID 75, we know node 75 has the correct connection so we output it manually to show the node data. </p><pre class="fragment">output_Raw_Node 75
does_Upper_Tier_Connection_Exist_Network 3 5 6 7
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0
</pre><p> Contents of the RETURN_FILE: </p><pre class="fragment">75
</pre><p> Error Handling:</p>
<ul>
<li>This function makes sure that the first node on the submitted node set is not NULL before calling does_Upper_Tier_Connection_Exist. This command is safer than the direct node 'does_Upper_Tier_Connection_Exist'.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None </li>
</ul>

</div>
</div>
<a id="aa850c7ca8094730d117ef52c0bb63f93" name="aa850c7ca8094730d117ef52c0bb63f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa850c7ca8094730d117ef52c0bb63f93">&#9670;&#160;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::encode </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the current input of the given Construct. </p>
<p>encode CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to use when encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This encodes the p_Input data, if the nodes aren't found they are created, used for training. How it does this is determined by what type of construct it is. Different constructs can have different structures depending on whether they are many to one, 2d pyramidal, 3d pyramidal, stiched based, etc.</p>
<p>To encode a construct you must first have input loaded into it. Once the input is loaded then calling this will encode the input pattern into a construct. The way to use this is to first get input to the construct, then you tell it to encode the input, then you can use gather, output, and other functions to access the results.: </p><pre class="fragment"> Get Input: set_Input | set_Input_uint | load_Input
 Do something with the Input: encode
 Get your Output: gather_X | output_X 
</pre><p> Example Usage:</p>
<ul>
<li>First we create a construct of the type Many_To_One named ExaCon for Example Construct.</li>
<li>Then we use set_Input_uint to load the uint array { 10, 15, 20 } into ExaCon's input.</li>
<li>After the input is set we call encode on ExaCon, which is construct ID [0].</li>
<li>We then use output_Scaffold to view the encoded trace.</li>
<li><p class="startli">This example is a Many_To_One, which means all state nodes (Tier[0]) are connected to a single upper tier (Tier[1]) treetop node.</p>
<p class="startli">register_Construct Many_To_One ExaCon set_Input_uint 0 5 3 10 15 20 encode 0 output_Scaffold 0 output_Node_Network gather_All_Nodes 0</p>
</li>
</ul>
<p>Output: </p><pre class="fragment"> __COMMAND__| output_Scaffold CONSTRUCT_ID |
  --==   CAN_Scaffold   ==--
 &lt;- Tier[0] -&gt;
   [0]  &lt;&gt; 1
   [1]  &lt;&gt; 2
   [2]  &lt;&gt; 3
 &lt;- Tier[1] -&gt;
   [0]  &lt;&gt; 4

 __COMMAND__| output_node_network |
 Node_ID (NID): 0  RC: 1 Type: 0 State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
 Node_ID (NID): 1  RC: 2 Type: 0 State { 10 } --- Dendrites:  --- Axon_Hillock_Count: 1 Axons[0] &lt;1&gt;:  [0] 4
 Node_ID (NID): 2  RC: 2 Type: 0 State { 15 } --- Dendrites:  --- Axon_Hillock_Count: 2 Axons[0] &lt;0&gt;:  Axons[1] &lt;1&gt;:  [0] 4
 Node_ID (NID): 3  RC: 2 Type: 0 State { 20 } --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;1&gt;:  [0] 4
 Node_ID (NID): 4  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 2 [2] 3 --- Axon_Hillock_Count: 0
</pre><ul>
<li><p class="startli">Here is another example, except this time we're encoding the phrase "the quick brown fox jumped over the lazy dog" to show language being encoded.</p>
<p class="startli">register_Construct Many_To_One ExaCon set_Input 0 the quick brown fox jumps over the lazy dog encode 0 output_Scaffold 0 gather_All_Nodes 0</p>
</li>
</ul>
<p>Output: </p><pre class="fragment">0 1 0 0 1
1 3 0 32 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 t
2 3 0 33 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 h
3 4 0 34 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 1 28 1 e
4 9 0 40 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 0 1 28 0 0 0 1 28 0 0 0 0 1 28 1
5 2 0 5 0 0 0 0 1 28 1 q
6 3 0 22 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 u
7 2 0 7 0 0 0 0 0 0 1 28 1 i
8 2 0 8 0 0 0 0 0 0 0 1 28 1 c
9 2 0 9 0 0 0 0 0 0 0 0 1 28 1 k
10 2 0 11 0 0 0 0 0 0 0 0 0 0 1 28 1 b
11 3 0 30 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 r
12 5 0 42 0 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 1 28 0 0 0 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 o
13 2 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 w
14 2 0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 n
15 2 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 f
16 2 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 x
17 2 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 j
18 2 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 m
19 2 0 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 p
20 2 0 25 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 s
21 2 0 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 v
22 2 0 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 l
23 2 0 37 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 a
24 2 0 38 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 z
25 2 0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 y
26 2 0 41 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 d
27 2 0 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 g
28 2 43 1 2 3 4 5 6 7 8 9 4 10 11 12 13 14 4 15 12 16 4 17 6 18 19 20 4 12 21 3 11 4 1 2 3 4 22 23 24 25 4 26 12 27 0 43 the quick brown fox jumps over the lazy dog
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Whitespace is weird when doing text input through set_Input! It reads from the text file using "file &gt;&gt; tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. </li>
</ul>

</div>
</div>
<a id="ace28357789021a38f7a2eda4b5cfc569" name="ace28357789021a38f7a2eda4b5cfc569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace28357789021a38f7a2eda4b5cfc569">&#9670;&#160;</a></span>gather_All_Nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_All_Nodes </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers all of the nodes to the given constructs output. </p>
<p>gather_All_Nodes CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's output will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Loops through each node and gathers them into the output file associated with the given construct.</p>
<p>Example Usage:</p>
<p>Register a construct and encode the string 'qwerty': </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 qwerty /end/
encode 0
</pre><p> Now use this function to gather all the nodes to the output file associated with the given construct: </p><pre class="fragment">gather_All_Nodes 0
</pre><p>Output:</p>
<p>Contents of "./ExaCon.Output.ssv": </p><pre class="fragment">0 1 0 0 1
1 2 0 1 1 7 1 q
2 2 0 2 0 1 7 1 w
3 2 0 3 0 0 1 7 1 e
4 2 0 4 0 0 0 1 7 1 r
5 2 0 5 0 0 0 0 1 7 1 t
6 2 0 6 0 0 0 0 0 1 7 1 y
7 2 6 1 2 3 4 5 6 0 6 qwerty
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="ade341194e7e36688780577a8394029df" name="ade341194e7e36688780577a8394029df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade341194e7e36688780577a8394029df">&#9670;&#160;</a></span>gather_All_Nodes_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_All_Nodes_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers all of the nodes to the given constructs output as an array of uint64_t. </p>
<p>gather_All_Nodes_uint CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's output will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Loops through each node and gathers them into the output file associated with the given construct, the output states/patterns are uint64_t.</p>
<p>Example Usage:</p>
<p>Register a construct and encode the array { 499, 500, 501 }: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 3 499 500 501
encode 0
</pre><p> Now use this function to gather all the nodes to the output file associated with the given construct: </p><pre class="fragment">gather_All_Nodes_uint 0
</pre><p>Output:</p>
<p>Contents of "./ExaCon.Output.ssv": </p><pre class="fragment">0 1 0 0 1 0
1 2 0 1 1 4 1 499
2 2 0 2 0 1 4 1 500
3 2 0 3 0 0 1 4 1 501
4 2 3 1 2 3 0 3 499 500 501
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a11e8037394004a42a8b735c6b19280ba" name="a11e8037394004a42a8b735c6b19280ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e8037394004a42a8b735c6b19280ba">&#9670;&#160;</a></span>gather_All_Traces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::gather_All_Traces </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers all the traces through a given construct. </p>
<p>gather_All_Traces CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>This is the construct who's output file will be used to store the results of the query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, it stores the results in the output file of the given construct.</td></tr>
  </table>
  </dd>
</dl>
<p>This iterates over the network and calls gather_Given_Trace for every node.</p>
<p>Example Usage:</p>
<p>We encode some data into our newly minted construct, and then get the traces from it: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 ABRACADABRA /end/ encode 0
set_Input 0 FIREBALL /end/ encode 0
gather_All_Traces 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">0 0 1 1
1 0 7 1 A
2 0 4 1 B
3 0 4 1 R
4 0 2 1 C
5 0 2 1 D
6 0 2 11 ABRACADABRA
7 0 2 1 F
8 0 2 1 I
9 0 2 1 E
10 0 3 1 L
11 0 2 8 FIREBALL
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a94d09c754a3899a0b1c75a57624e3715" name="a94d09c754a3899a0b1c75a57624e3715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d09c754a3899a0b1c75a57624e3715">&#9670;&#160;</a></span>gather_Given_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Given_Node </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This outputs the patterns as string when given a node ID (NID). </p>
<p>gather_Given_Node CONSTRUCT_ID NID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The ID of the construct to use for gathering the node, the output will go to the output file associated with the construct given. </td></tr>
    <tr><td class="paramname">NID</td><td>The node ID (NID) of the node who's pattern we will be gathering, or decoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">string</td><td>This function write the string represented by the given NID to an output file associated with the given Construct.</td></tr>
  </table>
  </dd>
</dl>
<p>This is used when you want to retrieve a pattern from a NID.</p>
<p>Example Usage:</p>
<p>The first step is to encode a pattern, into a newly minted construct for this example though it doesn't have to be new, it can be an old heirloom construct passed down through the generations: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 The Dream Quest of Unkown Kadath /end/
encode 0
output_Scaffold
</pre><p> Which shows us:</p>
<p>Output: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 5
  [5]  &lt;&gt; 6
  [6]  &lt;&gt; 3
  [7]  &lt;&gt; 7
  [8]  &lt;&gt; 8
  [9]  &lt;&gt; 4
  [10]  &lt;&gt; 9
  [11]  &lt;&gt; 10
  [12]  &lt;&gt; 3
  [13]  &lt;&gt; 11
  [14]  &lt;&gt; 12
  [15]  &lt;&gt; 4
  [16]  &lt;&gt; 13
  [17]  &lt;&gt; 14
  [18]  &lt;&gt; 4
  [19]  &lt;&gt; 15
  [20]  &lt;&gt; 16
  [21]  &lt;&gt; 17
  [22]  &lt;&gt; 13
  [23]  &lt;&gt; 18
  [24]  &lt;&gt; 16
  [25]  &lt;&gt; 4
  [26]  &lt;&gt; 19
  [27]  &lt;&gt; 7
  [28]  &lt;&gt; 20
  [29]  &lt;&gt; 7
  [30]  &lt;&gt; 12
  [31]  &lt;&gt; 2
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 21
</pre><p> From this we can see the upper tier node is '21'. So we tell it to retrieve that node, however, we create a new construct and get the node through that construct to show that as long as the construct is the same type we can retrieve patterns encoded into the nodes: </p><pre class="fragment">register_Construct Many_To_One RandomCon
gather_Given_Node 1 21
</pre><p> For an output of:</p>
<p>Contents of file "./Output/RandomCon.Output.ssv": </p><pre class="fragment">21 2 32 1 2 3 4 5 6 3 7 8 4 9 10 3 11 12 4 13 14 4 15 16 17 13 18 16 4 19 7 20 7 12 2 0 32 The Dream Quest of Unkown Kadath
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a6662cc0306ac130aaa444daf461e5028" name="a6662cc0306ac130aaa444daf461e5028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6662cc0306ac130aaa444daf461e5028">&#9670;&#160;</a></span>gather_Given_Node_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Given_Node_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This outputs the patterns as an array of uint64_t when given a node ID (NID). </p>
<p>gather_Given_Node_uint CONSTRUCT_ID NID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The ID of the construct to use for gathering the node, the output will go to the output file associated with the construct given. </td></tr>
    <tr><td class="paramname">NID</td><td>The node ID (NID) of the node who's pattern we will be gathering, or decoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">string</td><td>This function write the string represented by the given NID to an output file associated with the given Construct.</td></tr>
  </table>
  </dd>
</dl>
<p>This is used when you want to retrieve a pattern from a NID as an array of uint64_t.</p>
<p>Example Usage:</p>
<p>In this example we will encode two lower tier constructs to get the NIDs, and feed them into an MSC and get a single treetop node that represents the super-symbol of all the input encoded into a single retrievable trace. We wil then use this to get the original input patterns back out.</p>
<p>3 networks must be crafted with care, two raw tier constructs, and one higher multi-sensory construct (MSC): </p><pre class="fragment">register_Construct Many_To_One ExaCon
register_Construct Many_To_One ConExa
register_Construct Many_To_One ExaMSC
</pre><p> Now we'll encode the two raw constructs ExaCon and ConExa. ExaCon will be temperature, and ConExa will be oxygen: </p><pre class="fragment">set_Input 0 Temperature: 2 /end/
encode 0
set_Input 1 Oxygen: 4 /end/
encode 1
</pre><p> Then we use gather_Treetop_Node function to get both treetops, and to output the raw node for each so we can see the full data to confirm this function works: </p><pre class="fragment">gather_Treetop_NID 0
output_Newline 0
gather_Treetop_Node 0

gather_Treetop_NID 1
output_Newline 1
gather_Treetop_Node 1
</pre><p> Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">12
12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 2
</pre><p> Contents of "./Output/ConExa.Output.ssv": </p><pre class="fragment">22
22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 4
</pre><p> Now that we have these { 12, 22 } we can move onto the multi-sensory construct: </p><pre class="fragment">set_Input_uint 2 2 12 22
encode 2
</pre><p> Gather the output: </p><pre class="fragment">gather_Treetop_NID 2
output_Newline 2
gather_Treetop_Node_uint 2
</pre><p> Contents of "./Output/ExaMSC.Output.ssv": </p><pre class="fragment">25
25 2 2 23 24 0 2 12 22
</pre><p> FINALLY we can use this function to get the information back out, starting by wiping the output files: </p><pre class="fragment">clear_Output 0
clear_Output 1
clear_Output 2
</pre><p> Now we get the pattern from our highest abstraction, the treetop from ExaMSC, NID number 25. Moving forward we will only use information retrieved from the network to reconstruct symbol #25, no previous trained knowledge we will use, only meta and structural: </p><pre class="fragment">gather_Given_Node_uint 0 25
</pre><p> Which gives us the file contents (in ExaCon! Which isn't the construct which encoded the pattern, to show the network is shared):</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">25 2 2 23 24 0 2 12 22
</pre><p> Looking at this trace we see { 2 12 22 } at the end, which means 2 elements, which are 12 &amp; 22 repectively.</p>
<p>We then output newline, gather the node 12, another newline, then the node 22. We use the default gather_Given_Node here to get the raw data, but we've shown the uint by using it to get this far: </p><pre class="fragment">output_Newline 0
gather_Given_Node 0 12
output_Newline 0
gather_Given_Node 0 22
</pre><p> Results found in "./Output/ExaCon.Output.ssv": </p><pre class="fragment">25 2 2 23 24 0 2 12 22
12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 2
22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 4
</pre><p> As you can see we have encoded and retrieved all patterns using this function for the MSC traces, and the gather_Given_Node for the raw.</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a35dd21a221a907189867c9de4795189f" name="a35dd21a221a907189867c9de4795189f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dd21a221a907189867c9de4795189f">&#9670;&#160;</a></span>gather_Given_Trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::gather_Given_Trace </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a single trace from a given node, puts it in the output file for the given construct. </p>
<p>gather_Given_Trace CONSTRUCT_ID NID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>This is the ID of construct who's output file will have the trace written to it. </td></tr>
    <tr><td class="paramname">NID</td><td>The ID of the node from which the pattern, or trace, will be extracted usin the backpropagation functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, output is done through the output file of the given construct.</td></tr>
  </table>
  </dd>
</dl>
<p>Searches the network for the given NID and if found it outputs the pattern represented by the node to the output file of the specified construct.</p>
<p>This is used when you want to retrieve encoded information.</p>
<p>Example Usage:</p>
<p>First we encode some information. </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 THE GAME /end/
encode 0
output_Scaffold 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 5
  [5]  &lt;&gt; 6
  [6]  &lt;&gt; 7
  [7]  &lt;&gt; 3
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 8
</pre><p> Then we can extract it by using the NID from above: </p><pre class="fragment">gather_Given_Trace 0 8
</pre><p> Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">8 0 2 8 THE GAME
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a7e0aa5a19bde777d70075936f32e8574" name="a7e0aa5a19bde777d70075936f32e8574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0aa5a19bde777d70075936f32e8574">&#9670;&#160;</a></span>gather_Output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Output </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as char. </p>
<p>gather_Output CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's output is being gathered, or being written to the output file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the output from a construct to the output file associated with that construct so that you can get the results of queries and other functions which result in a construct having traces in the output array.</p>
<p>Example Usage:</p>
<p>First we register our construct &amp; encode a series of +- strings: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 --- /end/ encode 0
set_Input 0 --+ /end/ encode 0
set_Input 0 -+- /end/ encode 0
set_Input 0 -++ /end/ encode 0
set_Input 0 +-- /end/ encode 0
set_Input 0 +-+ /end/ encode 0
set_Input 0 ++- /end/ encode 0
set_Input 0 +++ /end/ encode 0
</pre><p> Now we set the input and query it for the '+' char: </p><pre class="fragment">set_Input 0 + /end/
query 0
</pre><p> Then to see the result we use gather_Output: </p><pre class="fragment">gather_Output 0
</pre><p> Output: </p><pre class="fragment"> 7 10 2 3 +--
 8 20 2 3 +-+
 9 20 2 3 ++-
10 30 2 3 +++
 5 10 2 3 -+-
 6 20 2 3 -++
 4 10 2 3 --+
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a22244e0f8ca7d9dd0a2d024878196e48" name="a22244e0f8ca7d9dd0a2d024878196e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22244e0f8ca7d9dd0a2d024878196e48">&#9670;&#160;</a></span>gather_Output_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Output_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as uint64_t. </p>
<p>gather_Output_uint CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's output is being gathered, or being written to the output file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the output from a construct to the output file associated with that construct so that you can get the results of queries and other functions which result in a construct having traces in the output array.</p>
<p>Example Usage:</p>
<p>First we register our construct &amp; encode a series of 3 item arrays: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 3 11 11 11 encode 0
set_Input_uint 0 3 11 11 99 encode 0
set_Input_uint 0 3 11 99 11 encode 0
set_Input_uint 0 3 11 99 99 encode 0
set_Input_uint 0 3 99 11 11 encode 0
set_Input_uint 0 3 99 11 99 encode 0
set_Input_uint 0 3 99 99 11 encode 0
set_Input_uint 0 3 99 99 99 encode 0
</pre><p> Now we set the input and query it for the '+' char: </p><pre class="fragment">set_Input_uint 0 1 99
query 0
</pre><p> Then to see the result we use gather_Output: </p><pre class="fragment">gather_Output_uint 0
</pre><p> Output: </p><pre class="fragment"> 7 10 2 3 99 11 11
 8 20 2 3 99 11 99
 9 20 2 3 99 99 11
10 30 2 3 99 99 99
 5 10 2 3 11 99 11
 6 20 2 3 11 99 99
 4 10 2 3 11 11 99
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a7dd787a6e3a33287c796d314f26795a3" name="a7dd787a6e3a33287c796d314f26795a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd787a6e3a33287c796d314f26795a3">&#9670;&#160;</a></span>gather_Treetop_NID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Treetop_NID </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This takes the current treetop node from the CAN Scaffold (if one exists) and outputs the NID to the output file. </p>
<p>gather_Treetop_NID CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct to retrieve the treetop node ID (NID) from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>This function appends the NID of the treetop to the output file for the given construct.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is useful when you are encoding multi-sensory constructs. When you encode a raw tier construct (one that deals with raw "sensory" data from outside the neural graph through state tier binding) the treetop is an abstraction of that sensory input. This function allows you to get a handle on that abstraction, a reference to that super-symbol.</p>
<p>With this super-symbol or higher level abstraction you can feed it into higher tier constructs to build abstractions of abstractions with multiple lower constructs feeding their treetops into a higher tier construct.</p>
<p>Example Usage:</p>
<p>In this example we will encode two lower tier constructs to get the NIDs, and just for fun we'll feed them into an MSC to get a single treetop node that represents the super-symbol of all the input encoded into a single retrievable trace.</p>
<p>First we create 3 networks, our old fren ExaCon, the somewhat familiar ConExa, and the rarely seen ExaMSC. </p><pre class="fragment">register_Construct Many_To_One ExaCon
register_Construct Many_To_One ConExa
register_Construct Many_To_One ExaMSC
</pre><p> Now we'll encode the two raw constructs ExaCon and ConExa. ExaCon will be temperature, and ConExa will be oxygen: </p><pre class="fragment">set_Input 0 Temperature: 5 /end/
encode 0
set_Input 1 Oxygen: 3 /end/
encode 1
</pre><p> Output:</p>
<p>The first construct ExaCon, temperature: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 2
  [5]  &lt;&gt; 5
  [6]  &lt;&gt; 6
  [7]  &lt;&gt; 7
  [8]  &lt;&gt; 8
  [9]  &lt;&gt; 5
  [10]  &lt;&gt; 2
  [11]  &lt;&gt; 9
  [12]  &lt;&gt; 10
  [13]  &lt;&gt; 11
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 12
</pre><p>The second construct ConExa, oxygen: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 13
  [1]  &lt;&gt; 14
  [2]  &lt;&gt; 15
  [3]  &lt;&gt; 16
  [4]  &lt;&gt; 17
  [5]  &lt;&gt; 18
  [6]  &lt;&gt; 19
  [7]  &lt;&gt; 20
  [8]  &lt;&gt; 21
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 22
</pre><p> Then we use this function to get both treetops, and to output the raw node for each so we can see the full data to confirm this function works: </p><pre class="fragment">gather_Treetop_NID 0
output_Newline 0
gather_Treetop_Node 0

gather_Treetop_NID 1
output_Newline 1
gather_Treetop_Node 1
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">12
12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 5
</pre><p> Contents of "./Output/ConExa.Output.ssv": </p><pre class="fragment">22
22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 3
</pre><p> Now that we have these { 12, 22 } we can move onto the multi-sensory construct: </p><pre class="fragment">set_Input_uint 2 2 12 22
encode 2
output_Scaffold 2
</pre><p> Gather the output: </p><pre class="fragment">gather_Treetop_NID 2
output_Newline 2
gather_Treetop_Node_uint 2
</pre><p> Contents of "./Output/ExaMSC.Output.ssv": </p><pre class="fragment">25
25 2 2 23 24 0 2 12 22
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="ad7f78ebe85659943e8acbcddf9241b29" name="ad7f78ebe85659943e8acbcddf9241b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f78ebe85659943e8acbcddf9241b29">&#9670;&#160;</a></span>gather_Treetop_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Treetop_Node </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node. </p>
<p>gather_Treetop_Node CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct you want the treetop from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="classc___node.html">c_Node</a></td><td>Treetop The treetop is output to the output file associated with the given construct.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the treetop node for a given construct and outputs it to the output file for the given construct.</p>
<p>This treetop is the top node in the current CAN Scaffold. So if you encode "yargi blargi" then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents "yargi blargi".</p>
<p>Example Usage:</p>
<p>First we encode a string into a Many_To_One: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 Pull Your Circuit Breaker /end/
encode 0
</pre><p> Then we can get the treetop: </p><pre class="fragment">gather_Treetop_Node 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">16 2 25 1 2 3 3 4 5 6 2 7 4 8 9 7 10 2 9 11 4 12 7 13 14 15 13 7 0 25 Pull Your Circuit Breaker
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a01af422b47451f4761ea60e74b59eb16" name="a01af422b47451f4761ea60e74b59eb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01af422b47451f4761ea60e74b59eb16">&#9670;&#160;</a></span>gather_Treetop_Node_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::gather_Treetop_Node_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node, the output pattern will be uint64_t. </p>
<p>gather_Treetop_Node_uint CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct you want the treetop from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="classc___node.html">c_Node</a></td><td>Treetop The treetop is output to the output file associated with the given construct.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the treetop node for a given construct and outputs it to the output file for the given construct.</p>
<p>This treetop is the top node in the current CAN Scaffold. So if you encode { 111, 222, 333 } then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents { 111, 222, 333 }.</p>
<p>Example Usage:</p>
<p>First we encode a string into a Many_To_One: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 3 111 222 333
encode 0
</pre><p> Then we can get the treetop: </p><pre class="fragment">gather_Treetop_Node_uint 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">4 2 3 1 2 3 0 3 111 222 333 
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a87101ad825a93638ec15d1c9411f10c6" name="a87101ad825a93638ec15d1c9411f10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87101ad825a93638ec15d1c9411f10c6">&#9670;&#160;</a></span>get_State_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::get_State_Node </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if a node in the given Construct is bound to the given state, if not the node is created &amp; the NID returned, if found the NID is returned. </p>
<p>get_State_Node CONSTRUCT_ID STATE </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to search. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NID The state of the input, the current quanta, or element, of information being encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>NID The node that represents the state passed to this function. Passes the NID back whether found or newly minted.</td></tr>
  </table>
  </dd>
</dl>
<p>Describe behavior and side-effects. What it basically does and if it touches any globals.</p>
<p>Example Usage:</p>
<p>Here we have a state that hasn't been encoded yet, this '999'. We run 'get_State_Node 2 999' which returns the NID of the newly minted and state bound node now stored and registered with construct 2's state fractal tree. In this example the NID of the new node is 150. We see this NID in the return file. </p><pre class="fragment">does_State_Node_Exist 2 999
</pre><p> Output:</p>
<p>Contents of the RETURN_FILE: </p><pre class="fragment">150
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>This assumes the [CONSTRUCT_ID] is valid </li>
</ul>

</div>
</div>
<a id="ad42ad6252407a2a611c6a05bf4d0704f" name="ad42ad6252407a2a611c6a05bf4d0704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42ad6252407a2a611c6a05bf4d0704f">&#9670;&#160;</a></span>get_Treetop_NID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::get_Treetop_NID </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the treetop node for a given construct and puts it in the output file for that construct. </p>
<p>get_Treetop CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct you want the treetop from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>Treetop The treetop is output to the return.ssv file.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the treetop node for a given construct and outputs it to the RETURN_FILE. If you instead want it to output to the construct output then you use gather_Output_Node instead of this function.</p>
<p>This treetop is the top node in the current CAN Scaffold. So if you encode "yargi blargi" then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents "yargi blargi".</p>
<p>Example Usage:</p>
<p>First we encode a string into a Many_To_One: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 Pull Your Circuit Breaker /end/
encode 0
</pre><p> Then we can get output the scaffold so you can see it, and then get the treetop: </p><pre class="fragment">output_Scaffold 0
get_Treetop 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 3
  [4]  &lt;&gt; 4
  [5]  &lt;&gt; 5
  [6]  &lt;&gt; 6
  [7]  &lt;&gt; 2
  [8]  &lt;&gt; 7
  [9]  &lt;&gt; 4
  [10]  &lt;&gt; 8
  [11]  &lt;&gt; 9
  [12]  &lt;&gt; 7
  [13]  &lt;&gt; 10
  [14]  &lt;&gt; 2
  [15]  &lt;&gt; 9
  [16]  &lt;&gt; 11
  [17]  &lt;&gt; 4
  [18]  &lt;&gt; 12
  [19]  &lt;&gt; 7
  [20]  &lt;&gt; 13
  [21]  &lt;&gt; 14
  [22]  &lt;&gt; 15
  [23]  &lt;&gt; 13
  [24]  &lt;&gt; 7
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 16
</pre><p> Contents of "./Output/returned.ssv": </p><pre class="fragment">16
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>This function is for prototyping for those planning on converting to C++ data handling logic rather than using output.ssv. </li>
</ul>

</div>
</div>
<a id="ab00c38697a0af6242ebe8d03f3622edc" name="ab00c38697a0af6242ebe8d03f3622edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00c38697a0af6242ebe8d03f3622edc">&#9670;&#160;</a></span>get_Upper_Tier_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::get_Upper_Tier_Node </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an upper tier node based on the given legs, will create it if not found. </p>
<p>get_Upper_Tier_Node NODE_COUNT NODES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>NODES The array of NIDs to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>NID The node that represents the symbol containing the lower nodes passed to this function. Passes the NID back whether found or newly minted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses 'does_Upper_Tier_Node_Exist' to find if the node exists or not. If the node is not found then this function creates the node, assigns the connections, and passes the prepared NID back.</p>
<p>Example Usage:</p>
<p>We will use the example containing a set of nodes { 5 6 7 }, in our example node 75 matches this configuration. We output it manually to show the node data proving this and we show the returned NID in the returned data file. </p><pre class="fragment">output_Raw_Node 75
get_Upper_Tier_Node 3 5 6 7
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 75 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0
</pre><p> Contents of the RETURN_FILE: </p><pre class="fragment">75
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>If you get a crash when calling this then it is likely one or more of your submitted NIDs are not valid. </li>
</ul>

</div>
</div>
<a id="ae2a5e745eb4e47fee0064ca92aa0c2ed" name="ae2a5e745eb4e47fee0064ca92aa0c2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a5e745eb4e47fee0064ca92aa0c2ed">&#9670;&#160;</a></span>load_Input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::load_Input </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the input file associated with the given construct into the input array. </p>
<p>load_Input CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>This is the construct for whom the input will be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Be warned, this function treats the entire file as one input, it ignored newlines. Iterating through it loads each whitespace separated token into a string, "tmp_Full = tmp_Full + ' ' + tmp_Current_Token"</p>
<p>Example Usage:</p>
<p>To start with we register our construct: </p><pre class="fragment">register_Construct Many_To_One ExaCon
</pre><p> We create the input file for it and put our sample data into the file:</p>
<p>Contents of "./Input/ExaCon.Input.ssv": </p><pre class="fragment">yo ho ho
and
a
bottle
of
rum
</pre><p> Now using load_Input we can load this into the construct: </p><pre class="fragment">load_Input 0
</pre><p> And we can see the results: </p><pre class="fragment">| load_Input |
 - [ 0 ]: yo
 - [ 1 ]: ho
 - [ 2 ]: ho
 - [ 3 ]: and
 - [ 4 ]: a
 - [ 5 ]: bottle
 - [ 6 ]: of
 - [ 7 ]: rum
</pre><p> You can see how it treats the tokens with different kinds of whitespace, newlines and spaces treated the same. (Looking at "yo ho ho")</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="addd245de8b70cde87aeec9ef5f9ee7e2" name="addd245de8b70cde87aeec9ef5f9ee7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd245de8b70cde87aeec9ef5f9ee7e2">&#9670;&#160;</a></span>load_Input_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::load_Input_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the input file associated with the given construct into the input array as uint. </p>
<p>load_Input_uint CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>This is the construct for whom the input will be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>The first number in the input file should be the count of elements. The function will create a temporary array to hold these and load them.</p>
<p>Example Usage:</p>
<p>To start with we register our construct: </p><pre class="fragment">register_Construct Many_To_One ExaCon
</pre><p> We create the input file for it and put our sample data into the file:</p>
<p>Contents of "./Input/ExaCon.Input.ssv": </p><pre class="fragment">4 10 20
20 40
</pre><p> Now using load_Input we can load this into the construct: </p><pre class="fragment">load_Input_uint 0
</pre><p> And we can see the results: </p><pre class="fragment">| load_Input_uint |
 Count: 4
 - [ 0 ]: 10
 - [ 1 ]: 20
 - [ 2 ]: 20
 - [ 3 ]: 40
</pre><p> You can see how it treats the tokens with different kinds of whitespace, newlines and spaces treated the same. (Looking at "yo ho ho")</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="af800a27f84cbcbaaf20778342fef8bb5" name="af800a27f84cbcbaaf20778342fef8bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af800a27f84cbcbaaf20778342fef8bb5">&#9670;&#160;</a></span>new_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::new_Node </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to differentiate a new construct, allocates a state tree to handle a state-node space. </p>
<p>/** Creates a new node in the shared node network. </p><pre class="fragment">new_Node
</pre> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>This returns the NID of the newly created nodes.</td></tr>
  </table>
  </dd>
</dl>
<p>When the node is created it is stored in a linked list. This new node is then added to the node registration fractal tree. This allows for storing the node network in a linked list for when we want to iterate over them, and for searching with a predictable search time for nodes in the linked list no matter its length.</p>
<p>Example Usage:</p>
<p>In this example we register a new node using new_Node and then check the output file for the NID of the newly created node. Currently the node network is at 249 nodes meaning the new one will have a NID of 250. </p><pre class="fragment">new_Node
</pre><p> Output:</p>
<p>Contents of the RETURN_FILE: </p><pre class="fragment">250
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a692f286375b7b06c646a8f5f549b49d0" name="a692f286375b7b06c646a8f5f549b49d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692f286375b7b06c646a8f5f549b49d0">&#9670;&#160;</a></span>new_State_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t c_Construct_Text_Server::new_State_Node </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new node, binds it to a state, sets the type to 0 or 3 depending, and adds the node to the state tree with the state registered. </p>
<p>new_State_Node CONSTRUCT_ID STATE </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>CONSTRUCT_ID This is the Construct to use when creating the state node. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>STATE The state to bind to the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint64_t</td><td>Returns the NID of the newly minted state node.</td></tr>
  </table>
  </dd>
</dl>
<p>By registering the node with the fractal state tree we can have predictable search times no matter how big the tree gets.</p>
<p>Example Usage:</p>
<p>In this example we have 3 constructs registered and we use 'new_State_Node 2 121' to create a state node for construct [2], in this example construct [2] currently has 28 nodes registered making the return value 29 as that is the new nodes NID. </p><pre class="fragment">new_State_Node 2 121
</pre><p> Output:</p>
<p>Contents of the RETURN_FILE: </p><pre class="fragment">29
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Assumes the construct is already registered with a valid index. </li>
</ul>

</div>
</div>
<a id="ab9e0d6bff658785121a684187f9e3e38" name="ab9e0d6bff658785121a684187f9e3e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e0d6bff658785121a684187f9e3e38">&#9670;&#160;</a></span>output_Backpropagated_Symbol_NID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Backpropagated_Symbol_NID </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds given NID and outputs the <a class="el" href="#a9516daf43b865cb75bb98949b375ab49" title="Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern ...">bp_O()</a>. </p>
<p>output_BP_NID NID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID (NID) of the node being manipulated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses the fractal NID tree to search the node linked list for the given NID. Once found it uses the -&gt;<a class="el" href="#a9516daf43b865cb75bb98949b375ab49" title="Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern ...">bp_O()</a> to output the pattern the node represents.</p>
<p>Example Usage:</p>
<p>Here NID 55 represents the compound symbol '32 64 128 64 32'. </p><pre class="fragment">bp_NID 5
</pre><p> Output: </p><pre class="fragment">&lt;=- 55 * [32]  [64]  [128]  [64]  [32] -=&gt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a7c506f9322c7310f679f0944a5943d30" name="a7c506f9322c7310f679f0944a5943d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c506f9322c7310f679f0944a5943d30">&#9670;&#160;</a></span>output_Backpropagated_Symbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Backpropagated_Symbols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates through every node and outputs their <a class="el" href="#a9516daf43b865cb75bb98949b375ab49" title="Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern ...">bp_O()</a> </p>
<p>output_BP </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This is for outputting the entire network to the console.</p>
<p>Example Usage:</p>
<p>in this example we have a single trace encoded which is composed of 5 integers, { 11, 22, 33, 44, 55 }. This results in 6 nodes which we will see in the output. 5 state tier nodes, one for each input integer, and one higher tier node. Remember, NID 0 exists, but it is the NULL node not to be used. </p><pre class="fragment">output_BP
</pre><p> Output: </p><pre class="fragment">&lt;=- 0 [0] -=&gt;
&lt;=- 1 [11] -=&gt;
&lt;=- 2 [22] -=&gt;
&lt;=- 3 [33] -=&gt;
&lt;=- 4 [44] -=&gt;
&lt;=- 5 [55] -=&gt;
&lt;=- 6 * [11]  [22]  [33]  [44]  [55] -=&gt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a6cb0b312172cf044fc9454bd4b9f9f75" name="a6cb0b312172cf044fc9454bd4b9f9f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb0b312172cf044fc9454bd4b9f9f75">&#9670;&#160;</a></span>output_Constructs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::output_Constructs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the constructs currently registered. </p>
<p>output_constructs </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Outputs the list of currently registered constructs to the console.</p>
<p>Example Usage:</p>
<p>We'll register some constructs, then output them: </p><pre class="fragment">register_Construct Many_To_One First_Conman
register_Construct Many_To_One Second_Conman
register_Construct Many_To_One Third_Conman
output_constructs
</pre><p> Output: </p><pre class="fragment">__COMMAND__| output_constructs |
[0]: First_Conman
[1]: Second_Conman
[2]: Third_Conman
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="af346f81c04d6cfa0712ca66db150cd89" name="af346f81c04d6cfa0712ca66db150cd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af346f81c04d6cfa0712ca66db150cd89">&#9670;&#160;</a></span>output_Input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Input </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the input of the given construct to the console. </p>
<p>output_Input CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's input we shall output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Pretty simple, outputs the input array of the given construct to the console.</p>
<p>Example Usage:</p>
<p>Let us create a construct, then set the input, then output the input which shall be 'kaput'. </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 kaput /end/
output_Input 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Input   ==-
[0] &gt; k &lt;
[1] &gt; a &lt;
[2] &gt; p &lt;
[3] &gt; u &lt;
[4] &gt; t &lt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a833cfaa472bf0da4bd535545d531cbad" name="a833cfaa472bf0da4bd535545d531cbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833cfaa472bf0da4bd535545d531cbad">&#9670;&#160;</a></span>output_Input_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Input_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the input of the given construct to the console, but as uint. </p>
<p>output_Input_uint CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's input we shall output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Outputs the input array of the given construct to the console with the values displayed as uint64_t.</p>
<p>Example Usage:</p>
<p>Let us create a construct, then set the input, then output the input: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 3 8999 9000 9001
output_Input_uint 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Input   ==--
[0] &gt; 8999 &lt;
[1] &gt; 9000 &lt;
[2] &gt; 9001 &lt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a67d6675fb0650c609d6f89940bd1c487" name="a67d6675fb0650c609d6f89940bd1c487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d6675fb0650c609d6f89940bd1c487">&#9670;&#160;</a></span>output_Newline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::output_Newline </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You give it a construct ID and it outputs a newline to the output file associated with that construct. </p>
<p>output_Newline CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct to whom the newline shall go, to the coffers of their output file the newline appends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, it outputs <br  />
 to the output file.</td></tr>
  </table>
  </dd>
</dl>
<p>Used for formatting output when testing, playing, prototyping, experimenting, or scripting.</p>
<p>Example Usage:</p>
<p>For an example we will register an Construct, encode several items, then output them one by one with two newlines betwixt them: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 Night Gaunt /end/
encode 0
gather_Treetop_Node 0

output_Newline 0
set_Input 0 Wubbajack /end/
encode 0
gather_Treetop_Node 0

output_Newline 0
set_Input 0 Ghoul /end/
encode 0
gather_Treetop_Node 0
</pre><p> Output:</p>
<p>Contents of the file "./Output/ExaCon.Output.ssv": </p><pre class="fragment">11 2 11 1 2 3 4 5 6 7 8 9 10 5 0 11 Night Gaunt
17 2 9 12 9 13 13 8 14 8 15 16 0 9 Wubbajack
20 2 5 7 4 18 9 19 0 5 Ghoul
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a659a1d8e9f942ea65a0e675000759478" name="a659a1d8e9f942ea65a0e675000759478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659a1d8e9f942ea65a0e675000759478">&#9670;&#160;</a></span>output_Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::output_Node </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs a given node as defined by the passed NID to the console. </p>
<p>function_name params </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>retval None This function doesn't return any values.</p>
<p>The node is output to the console for the user to read, the symbol is backpropagated out and presented as both uint64_t and char().</p>
<p>Example Usage:</p>
<p>First we'll register a construct, then set &amp; encode a string, then output the scaffold so we can see the nodes: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 T-800 /end/
encode 0
output_Scaffold 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 4
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 5
</pre><p> Looking at this we can see that the treetop node (Tier[1] Index[0] in this Many_To_One) is NID #5, so we can output node number 5: </p><pre class="fragment">output_Node 5
</pre><p> Output: </p><pre class="fragment"> | output_Node | 5 |
NID: 5 Type: 2 Symbol: &lt;=- 5 * [ T, 84 ]  [ -, 45 ]  [ 8, 56 ]  [ 0, 48 ]  [ 0, 48 ]  -=&gt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a2f0c3b3e6c10ba5c94c7047dbd18e9e8" name="a2f0c3b3e6c10ba5c94c7047dbd18e9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c3b3e6c10ba5c94c7047dbd18e9e8">&#9670;&#160;</a></span>output_Node_Char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Node_Char </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the node address to char() and outputs it. </p>
<p>output_Node_Char NID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID of the node who's NID is being output as a char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This function may seem pointless at first, but it is used in conjunction with the CAN scaffolds and others to output a compact visualizatin of a series of nodes by their NID. Though there is overlap when typecasting NIDs the variation is enough that the human can see differences in different permutations of encoded input.</p>
<p>Example Usage:</p>
<p>In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 0 - 175 have already been created so our first node will be NID 176. The node bound to state 128 already exists with a NID 65. This results in 3 nodes created, 2 state tier nodes { 176, 177 } and 1 upper tier treetop node { 178 }. We will output all the nodes using this function to show a small example of the potential output used to convey variance int he NID structure at a glance. </p><pre class="fragment">output_Node_Char 176
output_Node_Char 65
output_Node_Char 177
output_Node_Char 178
</pre><p> Output: </p><pre class="fragment">A
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash. </li>
</ul>

</div>
</div>
<a id="ad011c9a43a83319a0041c71e9ed00502" name="ad011c9a43a83319a0041c71e9ed00502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad011c9a43a83319a0041c71e9ed00502">&#9670;&#160;</a></span>output_Node_Network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::output_Node_Network </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This iterates through every node outputting them to the console. </p>
<p>output_Node_Network</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This function iterates over every node in the network and outputs the to the console for you to view. This is not the patterns represented by the nodes, but the node structures themselves.</p>
<p>Example Usage:</p>
<p>First we register the construct, then we encode a series of binary values just because: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 000 /end/ encode 0
set_Input 0 001 /end/ encode 0
set_Input 0 010 /end/ encode 0
set_Input 0 011 /end/ encode 0
set_Input 0 100 /end/ encode 0
set_Input 0 101 /end/ encode 0
set_Input 0 110 /end/ encode 0
set_Input 0 111 /end/ encode 0
</pre><p> Now output the network: </p><pre class="fragment">output_Node_Network
</pre><p> Output: </p><pre class="fragment">| output_Node_Network |
 Node_ID (NID): 0  RC: 1 Type: 0 State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
 Node_ID (NID): 1  RC: 13 Type: 0 State { 48 } --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] &lt;4&gt;:  [0] 2 [1] 4 [2] 5 [3] 6 Axons[1] &lt;4&gt;:  [0] 2 [1] 4 [2] 7 [3] 8 Axons[2] &lt;4&gt;:  [0] 2 [1] 5 [2] 7 [3] 9
 Node_ID (NID): 2  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 1 [2] 1 --- Axon_Hillock_Count: 0
 Node_ID (NID): 3  RC: 13 Type: 0 State { 49 } --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] &lt;4&gt;:  [0] 7 [1] 8 [2] 9 [3] 10 Axons[1] &lt;4&gt;:  [0] 5 [1] 6 [2] 9 [3] 10 Axons[2] &lt;4&gt;:  [0] 4 [1] 6 [2] 8 [3] 10
 Node_ID (NID): 4  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 1 [2] 3 --- Axon_Hillock_Count: 0
 Node_ID (NID): 5  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 3 [2] 1 --- Axon_Hillock_Count: 0
 Node_ID (NID): 6  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 1 [1] 3 [2] 3 --- Axon_Hillock_Count: 0
 Node_ID (NID): 7  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 1 [2] 1 --- Axon_Hillock_Count: 0
 Node_ID (NID): 8  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 1 [2] 3 --- Axon_Hillock_Count: 0
 Node_ID (NID): 9  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 3 [2] 1 --- Axon_Hillock_Count: 0
 Node_ID (NID): 10  RC: 2 Type: 2 State { 0 } --- Dendrites:  [0] 3 [1] 3 [2] 3 --- Axon_Hillock_Count: 0
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a4e20c3d32f5b1eb8e4f83f0299b4e470" name="a4e20c3d32f5b1eb8e4f83f0299b4e470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e20c3d32f5b1eb8e4f83f0299b4e470">&#9670;&#160;</a></span>output_Node_Raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Node_Raw </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the ugly raw info dump for the node. </p>
<p>output_Node_Raw NID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID of the node who's information symbol is being output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This is pretty basic, outputs the node.</p>
<p>Here is the breakdown of the components output:</p>
<p>-Entire output node raw dump: </p><pre class="fragment">Node_ID (NID): %NID% RC: %RC% Type: %Type% State { %State% } --- Dendrites: [%Dendrite_ID%] %Dendrites[%Dendrite_ID%]% --- Axon_Hillock_Count: %Axon_Hillock_Count% Axons[%Axon_Hillock_ID%] &lt;%Axon_Count_For_Hillock%&gt;: [%Axon_ID%] Axons[%Axon_Hillock_ID%][%Axon_ID%]
</pre><ul>
<li><p class="startli">The NID is the node ID within the network of nodes.</p>
<p class="startli">Node_ID (NID): NID%</p>
</li>
<li><p class="startli">The RC is the reinforcement counter, the reinforcement value, the neuroplasticity analogue, the post-synaptic-cleft density approximation.</p>
<p class="startli">RC: RC%</p>
</li>
<li><p class="startli">The type of node, see set_Node_Type for more information.</p>
<p class="startli">Type: Type%</p>
</li>
<li><p class="startli">The pattern of input quanta that the node represents, the hierarchically encoded sensory trace, the abstract symbol built from the recomposition of the input states into the complete encoded pattern.</p>
<p class="startli">State { State% }</p>
</li>
<li><p class="startli">The "lower" connections to nodes that form sub-symbols of the current node's symbol.</p>
<p class="startli">Dendrites: [Dendrite_ID%] Dendrites[Dendrite_ID%]%</p>
</li>
<li><p class="startli">The number of axon hillocks on this node, the number of axonal hillocks is determined by the position of upper tier connections. If an upper tier axonic connection makes contact with dendritic index 4 then this lower node will have 5 axon hillocks so that number 4 can hold this connection preserving the information of the upper tier connection index without having to query the other node to get the respective position. This is used during the function which check for upper tier nodes and during some charging methodologies.</p>
<p class="startli">Axon_Hillock_Count: Axon_Hillock_Count%</p>
</li>
<li><p class="startli">If the node contains axonic connections they will be iteratively printed here. For each hillock the number of axons on it will be printed followed by the individual axonic connections.</p>
<p class="startli">Axons[Axon_Hillock_ID%] &lt;Axon_Count_For_Hillock%&gt;: [Axon_ID%] Axons[Axon_Hillock_ID%][Axon_ID%]</p>
</li>
</ul>
<p>Example Usage:</p>
<p>In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 1-9 have already been created so our first node will be NID 10. This results in 4 nodes created, 3 state tier nodes { 10, 11, 12 } and 1 upper tier treetop node { 13 }. We will output all the nodes using this function to show state, treetop, dendritically connected, and axonically connected nodes.. </p><pre class="fragment">output_Node_Raw 10
output_Node_Raw 11
output_Node_Raw 12
output_Node_Raw 13
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 10 RC: 1 Type: 0  State { 64 } --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] &lt;1&gt;: 13
Node_ID (NID) 11 RC: 1 Type: 0  State { 128 } --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] &lt;0&gt;:  Axons[1] &lt;1&gt;: 13
Node_ID (NID) 12 RC: 1 Type: 0  State { 256 } --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] &lt;0&gt;:  Axons[1] &lt;0&gt;:  Axons[2] &lt;1&gt;: 13
Node_ID (NID) 13 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 10 [1] 11 [2] 12 --- Axon_Hillock_Count: 0
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash. </li>
</ul>

</div>
</div>
<a id="ae1031c653941bdb9c55e6c8aca08bf40" name="ae1031c653941bdb9c55e6c8aca08bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1031c653941bdb9c55e6c8aca08bf40">&#9670;&#160;</a></span>output_Output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Output </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The output trace set is output. </p>
<p>output_Output CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>This is the construct which has the output trace set output to the console. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes the current output traces from a given construct and outputs them to the console. So after a query this allows you to output the results.</p>
<p>Example Usage:</p>
<p>Here we'll register a construct, encode two input sets, query it, and then finally show the useage of this function.</p>
<p>Register, encode: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 01234 /end/
encode 0
set_Input 0 56789 /end/
encode 0
</pre><p> Set input, query, then show this functions TRUE POWER: </p><pre class="fragment">set_Input 0 45 /end/
query 0
output_Output 0
</pre><p> Output: </p><pre class="fragment"> --==   Output_Traces [2]   ==--
 Trace[0]:  Pat_Depth: 5
--  Charge: 10 RC: 2 Treetop: 6 Pattern:  0 1 2 3 4
 Trace[1]:  Pat_Depth: 5
--  Charge: 10 RC: 2 Treetop: 12 Pattern:  5 6 7 8 9
  --==   /Output_Traces   ==--
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a9279e34a8b5696e5f1ae82d4c22f305e" name="a9279e34a8b5696e5f1ae82d4c22f305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9279e34a8b5696e5f1ae82d4c22f305e">&#9670;&#160;</a></span>output_Output_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Output_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The output trace set is output as uint64_t. </p>
<p>output_Output_uint CONSTRUCT_ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>This is the construct which has the output trace set output to the console with the values displayed as uint64_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes the current output traces from a given construct and outputs them to the console. So after a query this allows you to output the results. The results are displayed as uint64_t and not string.</p>
<p>Example Usage:</p>
<p>Here we'll register a construct, encode two uint64_t input arrays, query it, and then finally show the useage of this function.</p>
<p>Register, encode: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 5 0 1 2 3 4
encode 0
set_Input_uint 0 5 5 6 7 8 9
encode 0
</pre><p> Set input, query, then show this functions TRUE POWER: </p><pre class="fragment">set_Input_uint 0 3 4 5 6
query 0
output_Output_uint 0
</pre><p> Output: </p><pre class="fragment"> --==   Output_Traces [2]   ==--
 Trace[0]:  Pat_Depth: 5
--  Charge: 10 RC: 2 Treetop: 6 Pattern:  0 1 2 3 4
 Trace[1]:  Pat_Depth: 5
--  Charge: 20 RC: 2 Treetop: 12 Pattern:  5 6 7 8 9 &lt;- Notice this one has a charge of 20, otherwise it looks the same as the string query.
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="acc16f0b743a80c04e0e47fd83ffb97bb" name="acc16f0b743a80c04e0e47fd83ffb97bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc16f0b743a80c04e0e47fd83ffb97bb">&#9670;&#160;</a></span>output_Scaffold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Scaffold </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the scaffold as node IDs. </p>
<p>output_Scaffold CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The ID of the construct who's scaffold we'll be outputting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>When a trace, or input pattern, is encoded into the network we use a current active node scaffold (CAN) to do so. This CAN Scaffold can be output for human analysis, this splays the symbol open to your gaze, all sub-symbols and bound states there to play with.</p>
<p>Example Usage:</p>
<p>We'll encode a string into a many to one and output the scaffold: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 supersymbol
encode 0
output_Scaffold 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 5
  [5]  &lt;&gt; 1
  [6]  &lt;&gt; 6
  [7]  &lt;&gt; 7
  [8]  &lt;&gt; 8
  [9]  &lt;&gt; 9
  [10]  &lt;&gt; 10
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 11
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a23c3f4474c46f982f07317f9e6c274e3" name="a23c3f4474c46f982f07317f9e6c274e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c3f4474c46f982f07317f9e6c274e3">&#9670;&#160;</a></span>output_Scaffold_Char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::output_Scaffold_Char </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the scaffold as characters typecase from the ID. </p>
<p>output_Scaffold_Char CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The ID of the construct who's scaffold we'll be outputting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>When a trace, or input pattern, is encoded into the network we use a current active node scaffold (CAN) to do so. This CAN Scaffold can be output for human analysis, each node represented as a 'random' character, making it so that at a glance you can tell variance in node structures, and changes if watching a life network.</p>
<p>Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.</p>
<p>Example Usage:</p>
<p>We'll encode a string into a many to one and output the scaffold: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 supersymbol
encode 0
output_Scaffold_Char 0
</pre><p> Output: </p><pre class="fragment"> - [ 0 ]: output_Scaffold_Char

(0000014828425EC0)
@0p

</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="adc7c049185d08bb31ffd5a54564572ad" name="adc7c049185d08bb31ffd5a54564572ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7c049185d08bb31ffd5a54564572ad">&#9670;&#160;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::query </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the network with the current input set for the given construct, evaluates the input set and stores the results in the output traces, gathered using 'gather_Output'. </p>
<p>query CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, the data resulting from this function is handled through traces.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN</p>
<p>Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs. Does not create new nodes, only finds if they already exist or not, does not "train" only "evaluates".</p>
<p>Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.</p>
<p>To query a construct you must first have input loaded into it. Once the input is loaded then calling this will query the input pattern for a given construct. The way to use this is to first get input to the construct, then you tell it to evaluate the input, then you can use gather, output, and other functions to access the results.: </p><pre class="fragment"> Get Input: set_Input | set_Input_uint | load_Input
 Do something with the Input: query
 Get your Output: gather_X | output_X
</pre><p> Example Usage:</p>
<p>This example is a Many_To_One, which means all state nodes (Tier[0]) are connected to a single upper tier (Tier[1]) treetop node.</p>
<p>You may notice that all the names are lowercase, this is because 'R' and 'r' are different symbols, so making them all lowercase keeps them using the same 'letters'.</p>
<p>First we create a construct of the type Many_To_One named ExaCon for Example Construct. </p><pre class="fragment">register_Construct Many_To_One ExaCon
</pre><p> Then we use set_Input + encode to load several character names into the network and encode them as a base set, see encode for further details. </p><pre class="fragment">set_Input 0 randolph carter /end/ encode 0
set_Input 0 harley warren /end/ encode 0
set_Input 0 herbert west /end/ encode 0
set_Input 0 dr. allen halsey /end/ encode 0
set_Input 0 erich zann /end/ encode 0
set_Input 0 edward norrys /end/ encode 0
set_Input 0 king kuranes /end/ encode 0
</pre><p> After we have the base character names we can begin searching them. We set the input to the string 'i' to search names that have 'i' in them. </p><pre class="fragment">set_Input 0 i
</pre><p> To call this function and the correct construct we use 'query 0', this fills the NULLCAN and handles the neural cascades. </p><pre class="fragment">query 0
</pre><p> We then use 'output_Scaffold' to view the NULLCAN showing the tiny CAN holding the current queries, 'gather_Output 0' to output the resulting traces to the output file for Construct [0] (default ".\Output\CONSTRUCT_NAME.Output.ssv"). </p><pre class="fragment">output_Scaffold 0
gather_Output 0
</pre><p> To show different searches we do several searches with a newline in the output between them.</p>
<p>Search for 'a': </p><pre class="fragment">output_Newline 0
set_Input 0 a
query 0
output_Scaffold 0
gather_Output 0
</pre><p> Search for 'h': </p><pre class="fragment">output_Newline 0
set_Input 0 h
query 0
output_Scaffold 0
gather_Output 0
</pre><p> Search for 'e': </p><pre class="fragment">output_Newline 0
set_Input 0 e
query 0
output_Scaffold 0
gather_Output 0
</pre><p> Search for 'eai': </p><pre class="fragment">output_Newline 0
set_Input 0 eai
query 0
output_Scaffold 0
gather_Output 0
</pre><p> Here is the above code in completion if you want to copy/paste: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 randolph carter /end/ encode 0
set_Input 0 harley warren /end/ encode 0
set_Input 0 herbert west /end/ encode 0
set_Input 0 dr. allen halsey /end/ encode 0
set_Input 0 erich zann /end/ encode 0
set_Input 0 edward norrys /end/ encode 0
set_Input 0 king kuranes /end/ encode 0
set_Input 0 i
query 0
output_Scaffold 0
gather_Output 0
output_Newline 0
set_Input 0 a
query 0
output_Scaffold 0
gather_Output 0
output_Newline 0
set_Input 0 h
query 0
output_Scaffold 0
gather_Output 0
output_Newline 0
set_Input 0 e
query 0
output_Scaffold 0
gather_Output 0
output_Newline 0
set_Input 0 eai
query 0
output_Scaffold 0
gather_Output 0
</pre><p> Output:</p>
<p>CAN Scaffold for the 'i' search </p><pre class="fragment">__COMMAND__| output_Scaffold CONSTRUCT_ID |
 --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 22
&lt;- Tier[1] -&gt;
  [0] NULL
</pre><p> CAN Scaffold for the 'a' search </p><pre class="fragment">__COMMAND__| output_Scaffold CONSTRUCT_ID |
 --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 2
&lt;- Tier[1] -&gt;
  [0] NULL
</pre><p> CAN Scaffold for the 'h' search </p><pre class="fragment">__COMMAND__| output_Scaffold CONSTRUCT_ID |
 --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 8
&lt;- Tier[1] -&gt;
  [0] NULL
</pre><p> CAN Scaffold for the 'e' search </p><pre class="fragment">__COMMAND__| output_Scaffold CONSTRUCT_ID |
 --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 12
&lt;- Tier[1] -&gt;
  [0] NULL
</pre><p> CAN Scaffold for the 'eai' search </p><pre class="fragment"> __COMMAND__| output_Scaffold CONSTRUCT_ID |
  --==   CAN_Scaffold   ==--
 &lt;- Tier[0] -&gt;
   [0]  &lt;&gt; 12
   [1]  &lt;&gt; 2
   [2]  &lt;&gt; 22
 &lt;- Tier[1] -&gt;
   [0] NULL
</pre><p> Contents of ".\Output\ExaCon.Output.ssv"</p>
<p>Results of 'i' search </p><pre class="fragment">29 10 2 12 king kuranes
24 10 2 10 erich zann
</pre><p> Results of 'a' search </p><pre class="fragment">13 20 2 15 randolph carter
16 20 2 13 harley warren
25 10 2 13 edward norrys
21 20 2 16 dr. allen halsey
24 10 2 10 erich zann
29 10 2 12 king kuranes
</pre><p> Results of 'h' search </p><pre class="fragment">16 10 2 13 harley warren
19 10 2 12 herbert west
24 10 2 10 erich zann
13 10 2 15 randolph carter
21 10 2 16 dr. allen halsey
</pre><p> Results of 'e' search </p><pre class="fragment">24 10 2 10 erich zann
25 10 2 13 edward norrys
19 30 2 12 herbert west
16 20 2 13 harley warren
21 20 2 16 dr. allen halsey
29 10 2 12 king kuranes
13 10 2 15 randolph carter
</pre><p> Results of 'eai' search </p><pre class="fragment">24 30 2 10 erich zann
25 20 2 13 edward norrys
19 30 2 12 herbert west
16 40 2 13 harley warren &lt;- the charge is 40 because it has 2 'a' characters, and 2 'e' characters.
21 40 2 16 dr. allen halsey
29 30 2 12 king kuranes
13 30 2 15 randolph carter
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p><ul>
<li>Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.</li>
<li>Whitespace is weird when doing text input through set_Input! It reads from the text file using "file &gt;&gt; tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. </li>
</ul>

</div>
</div>
<a id="ac3a9a9996d29030fc6165ff49eeb79cf" name="ac3a9a9996d29030fc6165ff49eeb79cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a9a9996d29030fc6165ff49eeb79cf">&#9670;&#160;</a></span>query_Given_Index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::query_Given_Index </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the network with the current input set, however, every input node is charged using the given index. </p>
<p>query_Given_Index CONSTRUCT_ID INDEX </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to search. </td></tr>
    <tr><td class="paramname">int</td><td>INDEX This is the index to use when charging, if you are searching for patterns that have any of the input nodes in index [2] then you would use this parameter to specify leg [2]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, the data resulting from this function is handled through traces.</td></tr>
  </table>
  </dd>
</dl>
<p>If INDEX is [3] then all nodes in the input set will be charging using axon hillock [3].</p>
<p>This is used when you have multiple inputs to the same index that you want to check. For example, maybe you want to check for traces grouped around one end the temperature scale rather than a single value.</p>
<p>Example Usage:</p>
<ul>
<li>Example 1.</li>
</ul>
<p>Following up on the idea of checking a range of thermometer readings from the description we have this example. If your temperature gauge registers 1 -5 then in this example you might want to look up the super-symbols, the encoded traces, the upper tier nodes, that have 4 &amp; 5 encoded onto the index corresponding to temperature on your greenhouse input array.</p>
<p>Here is an example input set from our example greenhouse sensors, oxygen, carbon dioxide, temperature, humidity, etc.</p>
<p>Each of these is an row in your input list:</p>
<ol type="1">
<li>Oxygen</li>
<li>Carbon Dioxide</li>
<li>Temperature &lt;- We'll be searching this index for the temperature ranges using this function query_Given_Index</li>
<li>Humidity</li>
<li>Etc</li>
</ol>
<p>They are read in as a string of values 1 - 5, "O2 Co2 Temp Humidity Etc", and example with values may be "2 4 2 1 3" to give an idea what an input list might look like to the neural network.</p>
<p>So you encode each list, for this example we'll say your greenhouse controller automatically logs these input lists. We'll use some of this log data for an example dataset: </p><pre class="fragment">register_Construct Many_To_One ExaCon &lt;- Don't forget to register the construct.
set_Input 0 3 2 4 1 5 /end/ encode 0
set_Input 0 2 3 3 2 4 /end/ encode 0
set_Input 0 4 1 2 5 3 /end/ encode 0
set_Input 0 5 4 3 2 1 /end/ encode 0
set_Input 0 1 5 2 4 3 /end/ encode 0
set_Input 0 3 2 1 4 5 /end/ encode 0
set_Input 0 4 3 2 5 1 /end/ encode 0
set_Input 0 1 4 3 2 5 /end/ encode 0
set_Input 0 2 3 4 1 5 /end/ encode 0
set_Input 0 5 1 2 3 4 /end/ encode 0
set_Input 0 3 4 2 1 5 /end/ encode 0
set_Input 0 2 1 3 5 3 /end/ encode 0
set_Input 0 4 5 1 2 3 /end/ encode 0
set_Input 0 1 2 3 4 5 /end/ encode 0
set_Input 0 3 2 5 1 4 /end/ encode 0
set_Input 0 2 3 4 5 1 /end/ encode 0
set_Input 0 4 5 2 3 1 /end/ encode 0
set_Input 0 5 1 3 2 4 /end/ encode 0
set_Input 0 1 4 5 3 2 /end/ encode 0
set_Input 0 3 2 4 5 1 /end/ encode 0
set_Input 0 2 1 5 3 3 /end/ encode 0
set_Input 0 4 3 1 2 5 /end/ encode 0
set_Input 0 5 4 2 1 3 /end/ encode 0
set_Input 0 1 5 4 3 2 /end/ encode 0
set_Input 0 3 2 1 5 4 /end/ encode 0
</pre><p> Now we need to find the temperatures, the { 4, 5 }. We do this by setting the input appropriately.</p>
<p>To formulate the input strings we create an input string from out input indexes with no whitespace between them, this is because each one is the smallest unit of information so we don't risk losing any by placing characters next to each other. Being single digit values 1-5 we can do that with this string based input: </p><pre class="fragment">45
</pre><p> This 45 is represented as a string internally so each digit is a separate integer value even though a human reads it as forty-five.</p>
<p>Then formulate it into the set_Input string for the construct 0 (ExaCon as defined using 'register_Construct Many_To_One ExaCon' above) we are working with: </p><pre class="fragment">set_Input 0 45 /end/
</pre><p> Finally we query the network with 'query_Given_Index' to search the network for all traces containing one of { 4, 5 } on leg 4, which corresponds to 4. Temperature, so index/leg/dendrite/axon_hillock #4. You might wonder why we are setting it to index 4 and not 2 like one would expect. This is because we have to count each whitespace as an index in the input string, "1 2 3 4 5" equals '1' + ' ' + '2' + ' ' + '3' + ' ' + '4' + ' ' + '5'.</p>
<p>Here is the query string: </p><pre class="fragment">query_Given_Index 0 4
</pre><p> Then use 'gather_Output' to get the output: </p><pre class="fragment">gather_Output 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment"> 7 10 2 9 3 2 4 1 5
15 10 2 9 2 3 4 1 5
22 10 2 9 2 3 4 5 1
26 10 2 9 3 2 4 5 1
30 10 2 9 1 5 4 3 2
21 10 2 9 3 2 5 1 4
25 10 2 9 1 4 5 3 2
27 10 2 9 2 1 5 3 3
</pre><ul>
<li>Example 2.</li>
</ul>
<p>This example builds on the above one to search for temperatures matching 1, 2, &amp; 3. </p><pre class="fragment">set_Input 0 123 /end/
</pre><p> Then the query and gather: </p><pre class="fragment">query_Given_Index 0 4
gather_Output 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">12 10 2 9 3 2 1 4 5
19 10 2 9 4 5 1 2 3
28 10 2 9 4 3 1 2 5
31 10 2 9 3 2 1 5 4
 9 10 2 9 4 1 2 5 3
11 10 2 9 1 5 2 4 3
13 10 2 9 4 3 2 5 1
16 10 2 9 5 1 2 3 4
17 10 2 9 3 4 2 1 5
23 10 2 9 4 5 2 3 1
29 10 2 9 5 4 2 1 3
 8 10 2 9 2 3 3 2 4
10 10 2 9 5 4 3 2 1
14 10 2 9 1 4 3 2 5
18 10 2 9 2 1 3 5 3
20 10 2 9 1 2 3 4 5
24 10 2 9 5 1 3 2 4
</pre><ul>
<li>Example 3.</li>
</ul>
<p>In this example we basically redo the same environmental search again, but this time we'll use the uint interface.</p>
<p>Start with encoding, but with uint and the syntax that requires (set_Input_uint CONSTRUCT_ID COUNT INPUT ): </p><pre class="fragment">register_Construct Many_To_One ExaCon &lt;- Don't forget to register the construct.
set_Input_uint 0 5 3 2 4 1 5 encode 0
set_Input_uint 0 5 2 3 3 2 4 encode 0
set_Input_uint 0 5 4 1 2 5 3 encode 0
set_Input_uint 0 5 5 4 3 2 1 encode 0
set_Input_uint 0 5 1 5 2 4 3 encode 0
set_Input_uint 0 5 3 2 1 4 5 encode 0
set_Input_uint 0 5 4 3 2 5 1 encode 0
set_Input_uint 0 5 1 4 3 2 5 encode 0
set_Input_uint 0 5 2 3 4 1 5 encode 0
set_Input_uint 0 5 5 1 2 3 4 encode 0
set_Input_uint 0 5 3 4 2 1 5 encode 0
set_Input_uint 0 5 2 1 3 5 3 encode 0
set_Input_uint 0 5 4 5 1 2 3 encode 0
set_Input_uint 0 5 1 2 3 4 5 encode 0
set_Input_uint 0 5 3 2 5 1 4 encode 0
set_Input_uint 0 5 2 3 4 5 1 encode 0
set_Input_uint 0 5 4 5 2 3 1 encode 0
set_Input_uint 0 5 5 1 3 2 4 encode 0
set_Input_uint 0 5 1 4 5 3 2 encode 0
set_Input_uint 0 5 3 2 4 5 1 encode 0
set_Input_uint 0 5 2 1 5 3 3 encode 0
set_Input_uint 0 5 4 3 1 2 5 encode 0
set_Input_uint 0 5 5 4 2 1 3 encode 0
set_Input_uint 0 5 1 5 4 3 2 encode 0
set_Input_uint 0 5 3 2 1 5 4 encode 0
</pre><p> For the input search string we use the uint format of stating the number of elements and our inputs, so 'set_Input 45 /end/' becomes 'set_Input_uint 2 4 5': </p><pre class="fragment">set_Input 0 2 4 5
</pre><p> The different input methods result in different input indexes for the values, meaning our query is different. The uint version gives us the intuitive index of [2] for our temperature because each number is a sequential input, rather than input - space - input: </p><pre class="fragment">query_Given_Index 0 2
</pre><p> We gather using the uint interface so it outputs the integers to the textfile properly: </p><pre class="fragment">gather_Output_uint 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment"> 6 10 2 5 3 2 4 1 5
14 10 2 5 2 3 4 1 5
21 10 2 5 2 3 4 5 1
25 10 2 5 3 2 4 5 1
29 10 2 5 1 5 4 3 2
20 10 2 5 3 2 5 1 4
24 10 2 5 1 4 5 3 2
26 10 2 5 2 1 5 3 3
</pre><ul>
<li>Example Meta-Explanation:</li>
</ul>
<p>The difference in the node IDs is due to the string interface not encoding the ' ' as the second character. With the input set of 'n n n n n', and each 'n' being a value 1-5, this means the second index in the string will be ' ' and read in as NID[2]. You can compare the patterns between the string version and the uint version to see the data is the same, but the node IDs are off by one:</p>
<p>String version 'set_Input': </p><pre class="fragment"> 7 10 2 9 3 2 4 1 5
15 10 2 9 2 3 4 1 5
22 10 2 9 2 3 4 5 1
26 10 2 9 3 2 4 5 1
30 10 2 9 1 5 4 3 2
21 10 2 9 3 2 5 1 4
25 10 2 9 1 4 5 3 2
27 10 2 9 2 1 5 3 3
</pre><p> uint Version 'set_Input_uint': </p><pre class="fragment"> 6 10 2 5 3 2 4 1 5
14 10 2 5 2 3 4 1 5
21 10 2 5 2 3 4 5 1
25 10 2 5 3 2 4 5 1
29 10 2 5 1 5 4 3 2
20 10 2 5 3 2 5 1 4
24 10 2 5 1 4 5 3 2
26 10 2 5 2 1 5 3 3
</pre><p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.</li>
<li>Whitespace is weird when doing text input through set_Input! It reads from the text file using "file &gt;&gt; tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. </li>
</ul>

</div>
</div>
<a id="a0d6b56adab575328125b8650ff74ac6d" name="a0d6b56adab575328125b8650ff74ac6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6b56adab575328125b8650ff74ac6d">&#9670;&#160;</a></span>query_Given_Legs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::query_Given_Legs </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the network using the current input set of the given Construct, however, an array of legs is passed that signifies whether or not each individual leg is to be charged and every input queried to all axon_hillocks/legs set to fire. </p>
<p>query_Given_Legs CONSTRUCT_ID LEG_COUNT LGS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to search. </td></tr>
    <tr><td class="paramname">int</td><td>LEG_COUNT The number of legs you are passing. </td></tr>
    <tr><td class="paramname">bool</td><td>LEGS The array of legs as boolean values used to determine whether or not to charge nodes connected on that axon_hillock/dendrite_index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, the data resulting from this function is handled through traces.</td></tr>
  </table>
  </dd>
</dl>
<p>This function works by taking this set of 'legs' which is a boolean array. It then takes every input of the construct and puts them in a pool of unorganized nodes. It then steps through the boolean array checking whether that step needs to be charged or not. If it needs charged the program then steps through every node in the pool having it charge any axons on the current index, which would be the axon_hillock to the node.</p>
<p>So if we are on the second leg in the array then we would step through each node, go check the axon_hillock population count, and if any are found we charge them into the charging buffers.</p>
<p>This means you will search for the set of inputs you give, not in order but individually, on the legs you specify.</p>
<p>Example Usage:</p>
<ul>
<li>Example 1.</li>
</ul>
<p>In this example we'll use the scenario of running a game server such as Minecraft and needing to track down some hackers. You have the chatlogs which are immense, and you have the user account database. One of your mods remembers that the hacker had an x or z in the first character or four of their name.</p>
<p>Using this function we can search for { 'X', 'Z', 'x','z' } on the first 4 characters of each name. So to start we need to encode the database of names by formatting them with the set_Input command: </p><pre class="fragment">register_Construct Many_To_One ExaCon /end/ encode 0
set_Input 0 PotatoChipCrunch /end/ encode 0
set_Input 0 NotARealIdentity /end/ encode 0
set_Input 0 BabyDollXOXO /end/ encode 0
set_Input 0 SpaceCowboy /end/ encode 0
set_Input 0 NinjaGuy22 /end/ encode 0
set_Input 0 ElectroExile /end/ encode 0
set_Input 0 ArcaneAdventurer /end/ encode 0
set_Input 0 Xx_KawaiiAngel_xX /end/ encode 0
set_Input 0 FireDragon99 /end/ encode 0
set_Input 0 ProUser2024 /end/ encode 0
set_Input 0 MySpaceStar /end/ encode 0
set_Input 0 RealNameJane /end/ encode 0
set_Input 0 xXx_P0t4t0Ch1p_xXx /end/ encode 0
set_Input 0 PixelPilgrim /end/ encode 0
set_Input 0 d4t4b4s3Qu33n /end/ encode 0
set_Input 0 NeonNomad /end/ encode 0
set_Input 0 ByteBandit23 /end/ encode 0
set_Input 0 DataMinerX /end/ encode 0
set_Input 0 -R4v3n-Cl4w- /end/ encode 0
set_Input 0 G1tGuD /end/ encode 0
set_Input 0 d00d!3_H4xx0r /end/ encode 0
set_Input 0 -MysticMoon- /end/ encode 0
set_Input 0 Vyrail_Vyxian /end/ encode 0
set_Input 0 xX_D@rk_P@ssw0rd_Xx /end/ encode 0
set_Input 0 8BitCh4rm3r /end/ encode 0
set_Input 0 $p4c3C@d3t /end/ encode 0
set_Input 0 W1z4rd0f0s /end/ encode 0
set_Input 0 C0mm@nd_L1n3_H3ro /end/ encode 0
set_Input 0 ScriptKiddieSupreme /end/ encode 0
</pre><p> Now that we have the database to search we can formulate the input query, punch it, and gather the output. </p><pre class="fragment">set_Input 0 XZxz /end/
query_Given_Legs 0 4 1 1 1 1
gather_Output 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">44 20 2 17 Xx_KawaiiAngel_xX
59 30 2 18 xXx_P0t4t0Ch1p_xXx &lt;- Notice how this one had 3 matches to the character pool 'XZxz' in the searched string "xXx_"
78 20 2 19 xX_D@rk_P@ssw0rd_Xx
60 10 2 12 PixelPilgrim
86 10 2 10 W1z4rd0f0s
</pre><ul>
<li>Example 2.</li>
</ul>
<p>Building on the previous example we have another mod say he saw one of them with a '-' or '_' so we'll expand the search: </p><pre class="fragment">set_Input 0 Xx-_ /end/
query_Given_Legs 0 4 1 1 1 1
output_Newline 0
gather_Output 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">44 30 2 17 Xx_KawaiiAngel_xX
59 40 2 18 xXx_P0t4t0Ch1p_xXx &lt;- With the addition of the '_' to the pool of states we find that this "xXx_" now has a match on all characters evaluated. Making the charge 40.
78 30 2 19 xX_D@rk_P@ssw0rd_Xx
60 10 2 12 PixelPilgrim
68 10 2 12 -R4v3n-Cl4w-
73 10 2 12 -MysticMoon-
</pre><ul>
<li>Example 3.</li>
</ul>
<p>If we examine the last example we find the charges are dependent on the number of matches.</p>
<p>The query treats the input as a pool of states, rather than an input string. This means that an input with repeated characters or states will evalaute them each time it encounters them.</p>
<p>Using this you can "weigh" inputs manually. If we want to weight the '-' character we cna input it multiple times like this: </p><pre class="fragment">set_Input 0 Xx-----_ /end/ &lt;- We input the '-' character 5 times.
output_Newline 0
query_Given_Legs 0 4 1 1 1 1
gather_Output 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv": </p><pre class="fragment">44 30 2 17 Xx_KawaiiAngel_xX
59 40 2 18 xXx_P0t4t0Ch1p_xXx
78 30 2 19 xX_D@rk_P@ssw0rd_Xx
60 10 2 12 PixelPilgrim
68 50 2 12 -R4v3n-Cl4w-
73 50 2 12 -MysticMoon-
</pre><p> Notice how the last two have charges of 50 vs the previous example where they had 10? With Many_To_One constructs the upper tier node charge is directly proportionate to how many inputs are linked to it (and modified by weights and such but you get the point).</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a6d33fb55089f40f7b4821750c1cedcbb" name="a6d33fb55089f40f7b4821750c1cedcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d33fb55089f40f7b4821750c1cedcbb">&#9670;&#160;</a></span>query_Spacial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::query_Spacial </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the network with the current input set of the given Construct, but the input index determines what leg is charged. </p>
<p>Meaning if an input at index [3] is charged then only upper tier nodes connected on axon hillock [3] will be charged.</p>
<p>query_Spacial CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>CONSTRUCT_ID The construct that encapsulates the state space to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values, the data resulting from this function is handled through traces.</td></tr>
  </table>
  </dd>
</dl>
<p>This query is used when the position of the input relative to the rest matters. Such as in time series searches, or context dependent inputs. The input position determines which connections get charged, this allows for searching nodes based on both the state of the input and the position.</p>
<p>This would be useful for things such as time-series prediction, such as stock data or an environmental variable.</p>
<p>Example Usage:</p>
<ul>
<li>Example 1.</li>
</ul>
<p>If we were trying to predict temperatures based on the previous temperatures and their fluctuations we might use this function. For example, if we have the current set of temperatures as { 50, 55, 60 } then we would want to know what comes after 60. First though we'll encode a sample history to search through.</p>
<p>Here's the sample history: </p><pre class="fragment">50 55 60 65 70 70 65 60 55 50
</pre><p> We'll do this by encoding 3 temperatures at a time starting at the beginning of the sample history. </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 5 3 50 55 60
encode 0
set_Input_uint 0 5 3 55 60 65
encode 0
set_Input_uint 0 5 3 60 65 70
encode 0
set_Input_uint 0 5 3 65 70 70
encode 0
set_Input_uint 0 5 3 70 70 65
encode 0
set_Input_uint 0 5 3 70 65 60
encode 0
set_Input_uint 0 5 3 65 60 55
encode 0
set_Input_uint 0 5 3 60 55 50
encode 0
</pre><p> Assuming we encoded 3 temperatures at a time we can create a prediction by setting the first two indexes and searching "forward".</p>
<p>So we input the set { 55, 60 } for the first two numbers, then search using this query_Spacial. </p><pre class="fragment">set_Input_uint 0 5 2 55 60
query_Spacial 0
gather_Output_uint 0
</pre><p> This means that only patterns with 55 as position [0], and 60 as position [1] will be found. This means those found will have position [2] as the "next" temperature.</p>
<p>Output: </p><pre class="fragment">6 20 2 3 55 60 65
12 10 2 3 65 60 55
</pre><p> We may choose to evaluate them through simple averaging the predicted index (number [2]). Or, alternatively we can weight them based on charge, or both.</p>
<p>In this case we can choose the trace with the charge of 20 for our prediction, which is { 55, 60, 65 }</p>
<p>A pure average would return 60, so trace selection is an important aspect that goes beyond this simple example. The choice on how to select the traces and filter them can make or break an algorithm.</p>
<p>So we take our current input and add the new trace to get a prediction: </p><pre class="fragment">55 60 ?? &lt;- Current, the ?? is the index we are searching for, the prediction.
55 60 65 &lt;- Found
=
55 60 65 &lt;- Resulting predicted pattern.
</pre><ul>
<li>Example 2.</li>
</ul>
<p>For an example that hopefully illistrates the purpose of this function we can walk through searching for a string when you know only a couple characters and their position in the string. Pretend you are sleuthing around online hunting down pedo scum, suddenly discord dings, a message! One of your contacts has a lead, a screenshot from a twitch stream with the kingpin distributor you've been tracking for a while now. He's in this twitch chat, you know that avatar, but there's a problem. The chat animations have caused a cloud of emoji to be doubleing over the name right as the screenshot was taken. You have only the second and third characters, 'aw', but it is a lead.</p>
<p>So we have the clue to work on [ '?' 'a' 'w' '?' ]. We know 'aw' are the second and third character, and the first char is a mystery, as are the rest if they even exist, which is liklely given how short that username would be.</p>
<p>Luckily you have a dataset of usernames to look through, we'll train these into the network (obviously we are using a completely insufficient number but we aren't including 10k usernames here), then search the network using our clue.</p>
<p>One thing to note, we have these usernames from sites we've scraped, and they have characters not allowed in the name. This means we can take our knowledge of how the network works and use this by inputting characters that cannot appear in usernames like a "greenscreen" in the string. The network during query doesn't create nodes, and if the username network never has these illegal characters encoded to a node then we will sure we are only searching for our intended characters, as no nodes will be in the scaffold for the invalid ones to charge.</p>
<p>Code for our initial dataset, notice some names such as Flawless1337 do not have the 'aw' in the right spot: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 SawBones9000 /end/ encode 0
set_Input 0 MawOfD00M /end/ encode 0
set_Input 0 PawPatriot1337 /end/ encode 0
set_Input 0 DawgWalker2000 /end/ encode 0
set_Input 0 TawTacticLol /end/ encode 0
set_Input 0 RawRampage2001 /end/ encode 0
set_Input 0 KawKungFuMaster /end/ encode 0
set_Input 0 LawlessLegion1337 /end/ encode 0
set_Input 0 Jawbreaker9001 /end/ encode 0
set_Input 0 VawVandal2000 /end/ encode 0
set_Input 0 AwkwardWarrior /end/ encode 0
set_Input 0 Flawless1337 /end/ encode 0
set_Input 0 StrawHat2000` /end/ encode 0
set_Input 0 ClawClasherLol /end/ encode 0
set_Input 0 GnawingGamer2001 /end/ encode 0
set_Input 0 HacksawHavoc /end/ encode 0
set_Input 0 Jawdropper2000 /end/ encode 0
set_Input 0 MawMauler1337 /end/ encode 0
set_Input 0 YawYawkerLol /end/ encode 0
set_Input 0 ZawZapper2001 /end/ encode 0
</pre><p> After the dataset we setup the query and submit it, using the 'illega' character of '_' to create "NULLCAN" nodes, which are positions in the current active node (CAN) scaffold, the datastructure which corrdinates encoding and charging, which don't have a node, therefore are "NULLCAN" nodes. </p><pre class="fragment">set_Input 0 _aw
query_Spacial 0
</pre><p> Gather the output traces into the "./Output/ExaCon.ssv" file. </p><pre class="fragment">gather_Output 0
</pre><p> Put a newline in the output file so we can tell the difference between the two queries we are doing. Two queries to compare this function to the 'normal' query. </p><pre class="fragment">output_Newline 0
</pre><p> The input is still set to "_aw" so we don't have to reinput our string. We can instead call 'query 0' because the prep work is all done. We then gather the output as normal with 'gather_Output 0'. </p><pre class="fragment">query 0
gather_Output 0
</pre><p> Output:</p>
<p>Contents of "./Output/ExaCon.Output.ssv":</p>
<p>Compare the first set returned with this query_Spacial function here: </p><pre class="fragment">11 20 2 12 SawBones9000
16 20 2  9 MawOfD00M
24 20 2 14 PawPatriot1337
30 20 2 14 DawgWalker2000
34 20 2 12 TawTacticLol
38 20 2 14 RawRampage2001
42 20 2 15 KawKungFuMaster
43 20 2 17 LawlessLegion1337
46 20 2 14 Jawbreaker9001
49 20 2 13 VawVandal2000
62 10 2 12 HacksawHavoc
63 20 2 14 Jawdropper2000
64 20 2 13 MawMauler1337
66 20 2 12 YawYawkerLol
68 20 2 13 ZawZapper2001
</pre><p> To this set returned with the nondifferentiated query function: </p><pre class="fragment">11 20 2 12 SawBones9000
16 20 2  9 MawOfD00M
24 30 2 14 PawPatriot1337
30 30 2 14 DawgWalker2000
34 30 2 12 TawTacticLol
38 40 2 14 RawRampage2001 &lt;- Notice the high charge of [40] due to the frequency of 'a' characters with the 'aw' sub-string.
42 30 2 15 KawKungFuMaster
43 20 2 17 LawlessLegion1337
46 30 2 14 Jawbreaker9001
49 40 2 13 VawVandal2000
62 40 2 12 HacksawHavoc
63 20 2 14 Jawdropper2000
64 30 2 13 MawMauler1337
66 40 2 12 YawYawkerLol
68 30 2 13 ZawZapper2001
52 20 2 12 Flawless1337
58 30 2 14 ClawClasherLol
60 30 2 16 GnawingGamer2001
55 30 2 13 StrawHat2000`
51 40 2 14 AwkwardWarrior
</pre><p> Full code for the previous example if you wish to copy/paste: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 SawBones9000 /end/ encode 0
set_Input 0 MawOfD00M /end/ encode 0
set_Input 0 PawPatriot1337 /end/ encode 0
set_Input 0 DawgWalker2000 /end/ encode 0
set_Input 0 TawTacticLol /end/ encode 0
set_Input 0 RawRampage2001 /end/ encode 0
set_Input 0 KawKungFuMaster /end/ encode 0
set_Input 0 LawlessLegion1337 /end/ encode 0
set_Input 0 Jawbreaker9001 /end/ encode 0
set_Input 0 VawVandal2000 /end/ encode 0
set_Input 0 AwkwardWarrior /end/ encode 0
set_Input 0 Flawless1337 /end/ encode 0
set_Input 0 StrawHat2000` /end/ encode 0
set_Input 0 ClawClasherLol /end/ encode 0
set_Input 0 GnawingGamer2001 /end/ encode 0
set_Input 0 HacksawHavoc /end/ encode 0
set_Input 0 Jawdropper2000 /end/ encode 0
set_Input 0 MawMauler1337 /end/ encode 0
set_Input 0 YawYawkerLol /end/ encode 0
set_Input 0 ZawZapper2001 /end/ encode 0
set_Input 0 _aw
query_Spacial 0
gather_Output 0
output_Newline 0
query 0
gather_Output 0
</pre><ul>
<li>Example 3.</li>
</ul>
<p>There may be times when you have a set number of inputs and you want to search for any patterns with that state in that spot. For example, you have your input set from your greenhouse sensors, oxygen, carbon dioxide, temperature, humidity, etc.</p>
<p>Each of these is an row in your input list:</p>
<ol type="1">
<li>Oxygen</li>
<li>Carbon Dioxide</li>
<li>Temperature</li>
<li>Humidity</li>
<li>Etc</li>
</ol>
<p>They are read in as a string of values 1 - 5, "O2 Co2 Temp Hum Etc", and example with values may be "2 4 2 1 3" to give an idea what an input list might look like to the neural network.</p>
<p>So you encode each list, each snapshot, once every hour or so as your standard datakeeping, in fact it is automated. We'll use these made up snapshots for an example dataset: </p><pre class="fragment">register_Construct Many_To_One ExaCon &lt;- Don't forget to register the construct.
set_Input 0 3 2 4 1 5 /end/ encode 0
set_Input 0 2 3 3 2 4 /end/ encode 0
set_Input 0 4 1 2 5 3 /end/ encode 0
set_Input 0 5 4 3 2 1 /end/ encode 0
set_Input 0 1 5 2 4 3 /end/ encode 0
set_Input 0 3 2 1 4 5 /end/ encode 0
set_Input 0 4 3 2 5 1 /end/ encode 0
set_Input 0 1 4 3 2 5 /end/ encode 0
set_Input 0 2 3 4 1 5 /end/ encode 0
set_Input 0 5 1 2 3 4 /end/ encode 0
set_Input 0 3 4 2 1 5 /end/ encode 0
set_Input 0 2 1 3 5 3 /end/ encode 0
set_Input 0 4 5 1 2 3 /end/ encode 0
set_Input 0 1 2 3 4 5 /end/ encode 0
set_Input 0 3 2 5 1 4 /end/ encode 0
set_Input 0 2 3 4 5 1 /end/ encode 0
set_Input 0 4 5 2 3 1 /end/ encode 0
set_Input 0 5 1 3 2 4 /end/ encode 0
set_Input 0 1 4 5 3 2 /end/ encode 0
set_Input 0 3 2 4 5 1 /end/ encode 0
set_Input 0 2 1 5 3 3 /end/ encode 0
set_Input 0 4 3 1 2 5 /end/ encode 0
set_Input 0 5 4 2 1 3 /end/ encode 0
set_Input 0 1 5 4 3 2 /end/ encode 0
set_Input 0 3 2 1 5 4 /end/ encode 0
</pre><p> Now, your boss comes in one day and says they need some data for a research project. They want every snapshop that has a humity value of 3 (everything here is 1 - 5 in range for simplicity) and a O2 of 2.</p>
<p>So you formulate your input string, using the greenscreen illegal character mask again, where the first and last are set to '2' and '3' respectively: "2 _ _ _ 3". There is a major issue with this that may not be apparent right away, the spaces are counted as valid symbols by the network. So we need to invalidate them as well to remove them from the query, "2_______3"</p>
<p>This is because the input array is treated as an array of characters, with the caveat that extra whitespace is ignored and condensed down to a single space, ' ', which can be odd if not expected. </p><pre class="fragment">set_Input 0 2_______3 /end/
</pre><p> Then use this query_Spacial function &amp; gather the output: </p><pre class="fragment">query_Spacial 0
gather_Output 0
</pre><p> Which gives us the output: </p><pre class="fragment"> 8 10 2 9 2 3 3 2 4
15 10 2 9 2 3 4 1 5
18 20 2 9 2 1 3 5 3 &lt;- The charge here is [20] because both of the nodes were found in the right location.
22 10 2 9 2 3 4 5 1
27 20 2 9 2 1 5 3 3
 9 10 2 9 4 1 2 5 3
11 10 2 9 1 5 2 4 3
19 10 2 9 4 5 1 2 3
29 10 2 9 5 4 2 1 3
</pre><p> To further this example we will search for a temperature with a value of 1, and humidity of 4 to see what was going on when it was a wee bit chilly with high humidity.</p>
<p>First we output a newline to the file to separate our searches, then we set the input. After setting the input we can then query_Spacial and gather_Output as normal. </p><pre class="fragment">output_Newline 0
set_Input 0 ____1___4 /end/
query_Spacial 0
gather_Output 0
</pre><p> This gives the following output: </p><pre class="fragment">12 10 2 9 3 2 1 4 5
19 10 2 9 4 5 1 2 3
28 10 2 9 4 3 1 2 5
31 20 2 9 3 2 1 5 4 &lt;- This appears to be the only really good match.
 8 10 2 9 2 3 3 2 4
16 10 2 9 5 1 2 3 4
21 10 2 9 3 2 5 1 4
24 10 2 9 5 1 3 2 4
</pre><p> Using this you can selectively search your traces.</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.</li>
<li>Whitespace is weird when doing text input through set_Input! It reads from the text file using "file &gt;&gt; tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. </li>
</ul>

</div>
</div>
<a id="ae8a353a9fb4ae478baa66f0014869544" name="ae8a353a9fb4ae478baa66f0014869544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a353a9fb4ae478baa66f0014869544">&#9670;&#160;</a></span>register_Construct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::register_Construct </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a Construct with the neural net engine of the given architecture and name desired. </p>
<p>register_Construct TYPE NAME</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TYPE</td><td>The node network architecture, Many_To_One, pyramidal, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int</td><td>Outputs the ID of the newly constructed construct to "./Output/returns.ssv".</td></tr>
  </table>
  </dd>
</dl>
<p>Registers a construct with the engine. This calls "register_Construct" with the <a class="el" href="classc___node___network.html">c_Node_Network</a> object NNet in the <a class="el" href="classc___construct.html" title="This class encapsulates and manipulates the Neural Network Engine directly while providing a public i...">c_Construct</a>, which:</p><ul>
<li>Creates an instance of a CAN scaffold of the type specified.</li>
<li>Creates a fractal state tree for the construct.</li>
<li>The name is registered in an array.</li>
<li>These are all encapsulated in a "construct".</li>
</ul>
<p>Currently these are the types of constructs available:</p><ul>
<li>Many_To_One</li>
</ul>
<p>Many_To_One: </p><pre class="fragment">This type is only 2 tiers, the state tier, and one treetop node per trace. You encode all the state nodes, then submit them as one to "get_Upper_Tier_Node".
</pre><p> Example Usage:</p>
<p>We'll register 3 constructs, then output the constructs: </p><pre class="fragment">register_Construct Many_To_One ExaCon
register_Construct Many_To_One ConExa
register_Construct Many_To_One ExaMSC

output_constructs
</pre><p> Output: </p><pre class="fragment">__COMMAND__| output_constructs |
[0]: ExaCon
[1]: ConExa
[2]: ExaMSC
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="ad4eebf315113910670ef8f01b5bebc9f" name="ad4eebf315113910670ef8f01b5bebc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eebf315113910670ef8f01b5bebc9f">&#9670;&#160;</a></span>reset_Input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::reset_Input </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to wipe the input array of a given construct. </p>
<p>reset_Input CONSTRUCT_ID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's input we are to wipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>For oopsies and when you need to prep a construct for new input.</p>
<p>Example Usage:</p>
<p>Let's setup a construct, set the input, output the input (lel), wipe the input, and output it again to confirm: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 This is amazing wheee /end/ encode 0
output_Input 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Input   ==--
[0] &gt; T &lt;
[1] &gt; h &lt;
[2] &gt; i &lt;
[3] &gt; s &lt;
[4] &gt;   &lt;
[5] &gt; i &lt;
[6] &gt; s &lt;
[7] &gt;   &lt;
[8] &gt; a &lt;
[9] &gt; m &lt;
[10] &gt; a &lt;
[11] &gt; z &lt;
[12] &gt; i &lt;
[13] &gt; n &lt;
[14] &gt; g &lt;
[15] &gt;   &lt;
[16] &gt; w &lt;
[17] &gt; h &lt;
[18] &gt; e &lt;
[19] &gt; e &lt;
[20] &gt; e &lt;
</pre><p> Now wipe the output and check it again!: </p><pre class="fragment">wipe_Input 0
output_Input 0
</pre><p> Output: </p><pre class="fragment">--==   CAN_Input   ==--
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a88e7529b9409186f7c4daff83c0b238e" name="a88e7529b9409186f7c4daff83c0b238e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e7529b9409186f7c4daff83c0b238e">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::run </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main loop for the neuro-server. </p>
<p>run</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this to start the server in C++.</p>
<p>This loop outputs a the message as a means of delay, then checks the flag file, and if anything is found it calls the interpreter.</p>
<p>Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a2d6f27d2f8ef5575b1baf91d3ed45ee2" name="a2d6f27d2f8ef5575b1baf91d3ed45ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6f27d2f8ef5575b1baf91d3ed45ee2">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::save </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>brief </p>
<p>function_name params </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>retval None This function doesn't return any values.</p>
<p>Describe behavior and side-effects. What it basically does and if it touches any globals.</p>
<p>Example Usage: </p><pre class="fragment">function_name params
</pre><p> Output: </p><pre class="fragment">output
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a09404fc5ad69a0b09826d03b21dd2bc1" name="a09404fc5ad69a0b09826d03b21dd2bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09404fc5ad69a0b09826d03b21dd2bc1">&#9670;&#160;</a></span>set_Dendrites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::set_Dendrites </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dendrites of the node. </p>
<p>set_Dendrites NID COUNT DENDRITE_IDS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID of the node being manipulated. </td></tr>
    <tr><td class="paramname">int</td><td>COUNT The number of dendrites in the array DENDRITE_IDS </td></tr>
    <tr><td class="paramname">uint64_t</td><td>DENDRITE_IDS An array of NIDs that represent the dendritic connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>The choice of encoding method will determine dendrite count. This is left with a dynamic leg count though so that bespoke networks can be created with ease. It is dangerous, but that is up to the user to handle.</p>
<p>Example Usage:</p>
<p>Setting the dendrites of imaginary node 43 to NIDs 2 &amp; 3 representing the connections to "lower" tier nodes making up the sub-symbols of the current node's represented pattern. Before and after setting them we output the node. This assumes no axonic connections. </p><pre class="fragment">output_Node_Raw 43
set_Dendrites 43 2 2 3
output_Node_Raw 43
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 43 RC: 1 Type: 2  State { 0 } --- Dendrites:  --- Axon_Hillock_Count: 0
Node_ID (NID) 43 RC: 1 Type: 2  State { 0 } --- Dendrites:  [0] 2 [1] 3 --- Axon_Hillock_Count: 0
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>This assumes the node has no dendrites yet, if it does you be dangling and jangling.</li>
<li>Calling this function with an invalid node will cause a crash.</li>
<li>Calling it and assigning dendrites invalid NID IDs will cause a crash when bp_O, create_Connection, does_Lower_Ter_Connection_Exist, or any other operation which touches the dendrites. </li>
</ul>

</div>
</div>
<a id="a04ecf7c8d1e5a740d9a33fe12d10a5ad" name="a04ecf7c8d1e5a740d9a33fe12d10a5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ecf7c8d1e5a740d9a33fe12d10a5ad">&#9670;&#160;</a></span>set_Input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int c_Construct_Text_Server::set_Input </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This command sets the input of a given construct to the given input string. </p>
<p>set_input CONSTRUCT_ID INPUT_STRING </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's input you wish to set. </td></tr>
    <tr><td class="paramname">INPUT_STRING</td><td>The input string, either terminates from endl, or the token '/end/' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>The sub-string '/end/' can be used as a string terminator. This is useful when you want to string multiple commands together, otherwise anything after the input command would be considered input. 'set_Input 0 Example_Text encode 0' would end up setting construct [0]'s input to 'Example_Text encode 0' and nothing would be encoded.</p>
<p>Use this function to set the input of the construct you'll be either encoding or evaluating, or both.</p>
<p>Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.</p>
<p>Whitespace is weird when doing text input through set_Input! It reads from the text file using "file &gt;&gt; tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.</p>
<p>Example Usage:</p>
<ul>
<li>Example 1.</li>
</ul>
<p>We'll register a construct, then set the input, then output the input so we can see it. </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 Careful lads, I think there's a sni- /end/
output_Input 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Input   ==--
[0] &gt; C &lt;
[1] &gt; a &lt;
[2] &gt; r &lt;
[3] &gt; e &lt;
[4] &gt; f &lt;
[5] &gt; u &lt;
[6] &gt; l &lt;
[7] &gt;   &lt;
[8] &gt; l &lt;
[9] &gt; a &lt;
[10] &gt; d &lt;
[11] &gt; s &lt;
[12] &gt; , &lt;
[13] &gt;   &lt;
[14] &gt; I &lt;
[15] &gt;   &lt;
[16] &gt; t &lt;
[17] &gt; h &lt;
[18] &gt; i &lt;
[19] &gt; n &lt;
[20] &gt; k &lt;
[21] &gt;   &lt;
[22] &gt; t &lt;
[23] &gt; h &lt;
[24] &gt; e &lt;
[25] &gt; r &lt;
[26] &gt; e &lt;
[27] &gt; ' &lt;
[28] &gt; s &lt;
[29] &gt;   &lt;
[30] &gt; a &lt;
[31] &gt;   &lt;
[32] &gt; s &lt;
[33] &gt; n &lt;
[34] &gt; i &lt;
[35] &gt; - &lt;
</pre><ul>
<li>Example 2.</li>
</ul>
<p>We're going to show what happens if you forget the '/end/' on a compound statement with set_Input in it. </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input 0 Example_Text encode 0
output_Input 0
</pre><p> Gives the output: </p><pre class="fragment"> --==   CAN_Input   ==--
[0] &gt; E &lt;
[1] &gt; x &lt;
[2] &gt; a &lt;
[3] &gt; m &lt;
[4] &gt; p &lt;
[5] &gt; l &lt;
[6] &gt; e &lt;
[7] &gt; _ &lt;
[8] &gt; T &lt;
[9] &gt; e &lt;
[10] &gt; x &lt;
[11] &gt; t &lt;
[12] &gt;   &lt;
[13] &gt; e &lt;
[14] &gt; n &lt;
[15] &gt; c &lt;
[16] &gt; o &lt;
[17] &gt; d &lt;
[18] &gt; e &lt;
[19] &gt;   &lt;
[20] &gt; 0 &lt;
</pre><p> Whereas including the '/end/' closing tag: </p><pre class="fragment">set_Input 0 Example_Text /end/ encode 0
output_Input 0
</pre><p> Gives the output: </p><pre class="fragment"> --==   CAN_Input   ==--
[0] &gt; E &lt;
[1] &gt; x &lt;
[2] &gt; a &lt;
[3] &gt; m &lt;
[4] &gt; p &lt;
[5] &gt; l &lt;
[6] &gt; e &lt;
[7] &gt; _ &lt;
[8] &gt; T &lt;
[9] &gt; e &lt;
[10] &gt; x &lt;
[11] &gt; t &lt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a5d02da651068631fb3407d219d0c0d8e" name="a5d02da651068631fb3407d219d0c0d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d02da651068631fb3407d219d0c0d8e">&#9670;&#160;</a></span>set_Input_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::set_Input_uint </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input of a given construct to the given array of uint64_t values. </p>
<p>set_Input_uint CONSTRUCT_ID COUNT INPUT</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's input will be getting set. </td></tr>
    <tr><td class="paramname">COUNT</td><td>The number of elements to expect in the Input array. </td></tr>
    <tr><td class="paramname">INPUT</td><td>The uint64_t array that will be read into the input of the given construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used when you have arrays of unsigned integer values to work with. Used for handling nodes with multi-sensory constructs and others that use nodes as their I/O states.</p>
<p>Example Usage:</p>
<ul>
<li>Example 1.</li>
</ul>
<p>Imagine we have an array of unsigned integers representing the number of deaths a team has in a video game. Say 4 players: </p><pre class="fragment">register_Construct Many_To_One ExaCon
set_Input_uint 0 4 3 10 12 87
output_Input_uint 0
</pre><p> Output: </p><pre class="fragment"> --==   CAN_Input   ==--
[0] &gt; 3 &lt;
[1] &gt; 10 &lt;
[2] &gt; 12 &lt;
[3] &gt; 87 &lt;
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>None. </li>
</ul>

</div>
</div>
<a id="a3be6c291b0c5ad8be48b09bc144bed68" name="a3be6c291b0c5ad8be48b09bc144bed68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be6c291b0c5ad8be48b09bc144bed68">&#9670;&#160;</a></span>set_State_Nodes_Index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::set_State_Nodes_Index </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the index for the given Construct state_Node_Tree. </p>
<p>set_State_Nodes_Index CONSTRUCT_ID INDEX </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CONSTRUCT_ID</td><td>The construct who's state node tree you are setting. </td></tr>
    <tr><td class="paramname">INDEX</td><td>The index you are setting the state tree to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the index for the given Construct state_Node_Tree in the c_Node_Network::State_Nodes fractal state tree array. This keeps the state spaces separate and discrete. Most networks you don't want to share state nodes. Some you do, that's where this function comes in, allows you to point a construct to the state tree you want.</p>
<p>It is important to remember that the state tree indices and the constructs don't line up. Construct[1] likely doesn't have State_Tree[1]!</p>
<p>Example Usage:</p>
<p>Create 2 constructs to work with, we'll be pointing ConExa's State Tree at ExaCon's State Tree: </p><pre class="fragment">register_Construct Many_To_One ExaCon
register_Construct Many_To_One ConExa
</pre><p> Set the ConExa to ExaCon: </p><pre class="fragment">set_State_Nodes_Index 1 1
</pre><p> Encode a string into ExaCon &amp; output the scaffold, then encode a similar one in ConExa &amp; output the scaffold. Comparing these you can see the shared nodes underneath. </p><pre class="fragment">set_Input 0 Control_String Variable /end/
encode 0
output_Scaffold 0

set_Input 1 Control_String New_Data /end/
encode 1
output_Scaffold 1
</pre><p> All constructs share the underlying node network, so those NIDs are unique to the entire network, not just a single construct. This means when you see the same node in both scaffolds you are seeing the exact same node.</p>
<p>Output:</p>
<p>Construct[0]: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 5
  [5]  &lt;&gt; 2
  [6]  &lt;&gt; 6
  [7]  &lt;&gt; 7
  [8]  &lt;&gt; 8
  [9]  &lt;&gt; 4
  [10]  &lt;&gt; 5
  [11]  &lt;&gt; 9
  [12]  &lt;&gt; 3
  [13]  &lt;&gt; 10
  [14]  &lt;&gt; 11
  [15]  &lt;&gt; 12
  [16]  &lt;&gt; 13
  [17]  &lt;&gt; 5
  [18]  &lt;&gt; 9
  [19]  &lt;&gt; 13
  [20]  &lt;&gt; 14
  [21]  &lt;&gt; 6
  [22]  &lt;&gt; 15
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 16
</pre><p> Construct[1]: </p><pre class="fragment"> --==   CAN_Scaffold   ==--
&lt;- Tier[0] -&gt;
  [0]  &lt;&gt; 1
  [1]  &lt;&gt; 2
  [2]  &lt;&gt; 3
  [3]  &lt;&gt; 4
  [4]  &lt;&gt; 5
  [5]  &lt;&gt; 2
  [6]  &lt;&gt; 6
  [7]  &lt;&gt; 7
  [8]  &lt;&gt; 8
  [9]  &lt;&gt; 4
  [10]  &lt;&gt; 5
  [11]  &lt;&gt; 9
  [12]  &lt;&gt; 3
  [13]  &lt;&gt; 10
  [14]  &lt;&gt; 11
  [15]  &lt;&gt; 17
  [16]  &lt;&gt; 15
  [17]  &lt;&gt; 18
  [18]  &lt;&gt; 7
  [19]  &lt;&gt; 19
  [20]  &lt;&gt; 13
  [21]  &lt;&gt; 4
  [22]  &lt;&gt; 13
&lt;- Tier[1] -&gt;
  [0]  &lt;&gt; 20
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>State tree indices and the constructs don't line up. Construct[1] likely doesn't have State_Tree[1]! </li>
</ul>

</div>
</div>
<a id="a475eb56659e2ddb166163704d42bafc4" name="a475eb56659e2ddb166163704d42bafc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475eb56659e2ddb166163704d42bafc4">&#9670;&#160;</a></span>set_Type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_Construct_Text_Server::set_Type </td>
          <td>(</td>
          <td class="paramtype">std::ifstream *</td>          <td class="paramname"><span class="paramname"><em>p_File</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of a given node. </p>
<p>set_Type NID TYPE </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint64_t</td><td>NID The Node ID (NID) of the node being manipulated. </td></tr>
    <tr><td class="paramname">uint64_t</td><td>TYPE The type you are assigning the node to: (0: State), (1: Branch), (2: Treetop), (3: State/Treetop) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>This function doesn't return any values.</td></tr>
  </table>
  </dd>
</dl>
<p>This type is used for determining how to handle the node. You may want to set one to a treetop that way you can then write a charging function that has a different behavior for treetop nodes.</p>
<p>Example Usage:</p>
<p>Setting the type of node 66 to the value of 2 flagging it as a treetop node. Before and after setting the type we use output_Node_Raw to view the results. This assumes node 66 has two dendrites { 7, 14 }. </p><pre class="fragment">output_Node_Raw 66
set_Type 66 2
output_Node_Raw 66
</pre><p> Output: </p><pre class="fragment">Node_ID (NID) 66 RC: 1 Type: 0  State { 0 } --- Dendrites:  [7]  [14]  --- Axon_Hillock_Count: 0
Node_ID (NID) 66 RC: 1 Type: 2  State { 0 } --- Dendrites:  [7]  [14]  --- Axon_Hillock_Count: 0
</pre><p> Error Handling:</p>
<ul>
<li>No error handling is implemented in this function.</li>
</ul>
<p>Additional Notes:</p>
<ul>
<li>Calling this function with an invalid node will cause a crash.</li>
<li>You can set the type to any value you want, this allows for extending functionality, but can cause a crash if you set it to an invalid type and the node is mishandled. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/NT4/<a class="el" href="c___construct___text___server_8h_source.html">c_Construct_Text_Server.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
