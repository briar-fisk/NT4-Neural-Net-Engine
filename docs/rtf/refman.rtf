{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment NT4 Neural-Net Engine }NT4 Neural-Net Engine}
{\comment Generated by doxygen 1.10.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt NT4 Neural-Net Engine}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
NT4 User Manual\par \pard\plain 
{\tc\tcl1 \v NT4 User Manual}
{\xe \v NT4 User Manual}
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The goal of the system to give users a system they can download and play with, no in between, assuming a good binary, otherwise it is compile then use. On windows a CMake build script is included so they can compile and play in one click. When they have it set up they can start playing with the batch file interface on Windows.On Linux you are assumed to be savvy enough to figure out the compilation, use, and interfacing. The engine envisioned as a "redstone component" in operation, I / O and interface meant to be used in a network of components, in this case scripts. It is obviously more complex than a simple redstone repeater, but the idea of encapsulation in such a manner remains.\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Overview
\par}
{\tc\tcl2 \v Overview}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The system operates as a server, it runs continuously in a loop until shutdown\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
It has several files, input.ssv, config.ssv, control_panel.ssv, control_panel_flag.ssv, control_panel_complete, and output.ssv\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
All I / O is done through these space separated volumes for simplicity\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The ML engine has your typical public interface for C++ OOP classes\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This interface of the ML is then "piped" to and from these text files.The user may store a command followed by the arguments and the system will compile this into a function call to the ML engine.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The interface contains an "interpreter" that allows for "running" the config and control_panel files as sequential system calls to the ML engine, we'll call this interpreter eval()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The reason for this is for integration into shell scripts, and to be able to easily prototype networks, workflows, and configurations using the live shell engine, and then when ready you go implement the design by transliterating the code from text to C++.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This system is the highest abstraction of the engine, expected to be the lowest barrier of entry so it is presented as the 'face' of the engine, though the C++ pure interface has advantages to those who can C++. \par}
\par
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Index\par \pard\plain 
{\tc \v Topic Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Topics\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all topics with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
NT4_Namespace\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Construct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Construct_Text_Server\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b NT4} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the namespace which encapsulates the {\b NT4} Neural-Net Engine and the interfaces })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
c_2D_IO_Set\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_3D_IO_Set\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Base_CAN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
c_CAN_1D_Pyramid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_CAN_2D_Pyramid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_CAN_3D_Pyramid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_CAN_Many_To_One\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
c_Charging_Buffer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Charging_Buffer_Node\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Charging_Buffer_Tree\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Charging_Linked_List\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Charging_Linked_List_Handler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Construct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Construct_API\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Construct_Text_Server\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Fractal_Node\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Fractal_Tree\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_IO_Set\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Linked_List\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Linked_List_Handler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Node\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Node_Network\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Sim\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Trace\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
c_Base_CAN::tmp_Union\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
u_Tmp\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b c_2D_IO_Set} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_3D_IO_Set} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Base_CAN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_CAN_1D_Pyramid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_CAN_2D_Pyramid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_CAN_3D_Pyramid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_CAN_Many_To_One} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Charging_Buffer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Charging_Buffer_Node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Charging_Buffer_Tree} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Charging_Linked_List} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Charging_Linked_List_Handler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Construct} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class encapsulates and manipulates the Neural Network Engine directly while providing a public interface })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Construct_API} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Construct_Text_Server} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a handshake based text interface for the engine })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Fractal_Node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Fractal_Tree} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_IO_Set} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Linked_List} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Linked_List_Handler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Node_Network} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Sim} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Trace} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b c_Base_CAN::tmp_Union} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b u_Tmp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b NT4.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/{\b c_Sim.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/{\b NT4_Master.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN_1D_Pyramid.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN_2D_Pyramid.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN_3D_Pyramid.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN_7D_Pyramid.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN_Many_To_One.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_CAN_Multi_Sensory_Construct.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Charging_Array.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Construct.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Construct_API.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Construct_Text_Server.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Fractal_Tree.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_IO.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Linked_List_Handler.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Node.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Node_Network.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/NT4/{\b c_Trace.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Topic Documentation{\tc \v Topic Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NT4_Namespace\par \pard\plain 
{\tc\tcl2 \v NT4_Namespace}
{\xe \v NT4_Namespace}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NT4}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the namespace which encapsulates the {\b NT4} Neural-Net Engine and the interfaces. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Construct\par \pard\plain 
{\tc\tcl2 \v Construct}
{\xe \v Construct}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b c_Construct}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class encapsulates and manipulates the Neural Network Engine directly while providing a public interface. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Construct_Text_Server\par \pard\plain 
{\tc\tcl2 \v Construct_Text_Server}
{\xe \v Construct_Text_Server}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b c_Construct_Text_Server}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a handshake based text interface for the engine. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b RETURN_FILE} = "./Output/returned.ssv"{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NT4 Namespace Reference\par \pard\plain 
{\tc\tcl2 \v NT4}
{\xe \v NT4}
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the namespace which encapsulates the {\b NT4} Neural-Net Engine and the interfaces. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the namespace which encapsulates the {\b NT4} Neural-Net Engine and the interfaces. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_2D_IO_Set Class Reference\par \pard\plain 
{\tc\tcl2 \v c_2D_IO_Set}
{\xe \v c_2D_IO_Set}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Depth} (int p_X_Depth, int p_Y_Depth){\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b wipe_Data} (){\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Value} (uint64_t p_Value, int p_X, int p_Y){\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Array_Value} (uint64_t **p_Data_Array, int p_X_Depth, int p_Y_Depth){\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Value} (int p_X, int p_Y){\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b shift_Data} (){\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (){\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t ** {\b Data}{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Depth} [2]{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_IO.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_3D_IO_Set Class Reference\par \pard\plain 
{\tc\tcl2 \v c_3D_IO_Set}
{\xe \v c_3D_IO_Set}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Depth} (int p_X_Depth, int p_Y_Depth, int p_Z_Depth){\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b wipe_Data} (){\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Value} (uint64_t p_Value, int p_X, int p_Y, int p_Z){\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Array_Value} (uint64_t ***p_Data_Array, int p_X_Depth, int p_Y_Depth, int p_Z_Depth){\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Value} (int p_X, int p_Y, int p_Z){\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b shift_Data} (){\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (){\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t *** {\b Data}{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Depth} [3]{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_IO.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Base_CAN Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Base_CAN}
{\xe \v c_Base_CAN}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Inheritance diagram for c_Base_CAN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classc___base___c_a_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union {\b tmp_Union}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b encode} (uint64_t *p_Input=NULL, int p_Depth=0)=0{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b query} (uint64_t *p_Input=NULL, int p_Depth=0, int p_Charging_Style=-1, int p_Leg=0, int *p_Legs=NULL)=0{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b submit_Set} (uint64_t *p_Input, int p_Depth)=0{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b c_Node} * {\b get_Treetop} (int p_Index=0)=0{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b gather_Given_Trace} (uint64_t p_NID)=0{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b gather_All_Traces} ()=0{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} (){\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_NNet} ({\b c_Node_Network} *p_NNet){\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Index){\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (uint64_t *p_Input, int p_Input_Depth){\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (std::string p_Input){\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input} (uint64_t **p_Input, int p_X_Depth, int p_Y_Depth){\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_String} (char **p_Input, int p_X_Depth, int p_Y_Depth){\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input} (uint64_t ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth){\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_String} (char ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth){\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b output_Scaffold} ()=0{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Type=0){\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Type=0){\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b output_Scaffold_Char} ()=0{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node_Network} * {\b NNet}{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Nodes_Index}{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_IO_Set} {\b Input}{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_2D_IO_Set} {\b Input_2D}{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_3D_IO_Set} {\b Input_3D}{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Trace} * {\b Output}{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Output_Depth}{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_CAN.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_1D_Pyramid Class Reference\par \pard\plain 
{\tc\tcl2 \v c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
Inheritance diagram for c_CAN_1D_Pyramid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classc___c_a_n__1_d___pyramid.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Scaffold} (){\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setup_CAN_Scaffold} (){\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_State} (std::string p_How="Encode"){\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_Scaffold} (std::string p_How="Encode"){\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b encode} (uint64_t *p_Input=NULL, int p_Depth=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Buffers} (int p_Style=-1, int p_Leg=0, int *p_Legs=NULL){\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetops} (){\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_All_Traces} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_Given_Trace} (uint64_t p_NID)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query} (uint64_t *p_Input=NULL, int p_Depth=0, int p_Charging_Style=-1, int p_Leg=0, int *p_Legs=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b submit_Set} (uint64_t *p_Input, int p_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b c_Node} * {\b get_Treetop} (int p_Index=-1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold_Char} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_NNet} ({\b c_Node_Network} *p_NNet)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (uint64_t *p_Input, int p_Input_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (std::string p_Input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input} (uint64_t **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_String} (char **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input} (uint64_t ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_String} (char ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Type=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Type=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} *** {\b Scaffold}{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth}{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer} {\b tmp_Buffman}{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Attributes inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node_Network} * {\b NNet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Nodes_Index}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_IO_Set} {\b Input}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_2D_IO_Set} {\b Input_2D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_3D_IO_Set} {\b Input_3D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Trace} * {\b Output}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Output_Depth}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v encode\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:encode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::encode (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_All_Traces\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:gather_All_Traces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::gather_All_Traces (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_Given_Trace\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:gather_Given_Trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::gather_Given_Trace (uint64_t  {\i p_NID}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v get_Treetop\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:get_Treetop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b c_Node} * c_CAN_1D_Pyramid::get_Treetop (int  {\i p_Index} = {\f2 -1}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:output_Scaffold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::output_Scaffold (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold_Char\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:output_Scaffold_Char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::output_Scaffold_Char (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v query\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::query (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}, int  {\i p_Charging_Style} = {\f2 -1}, int  {\i p_Leg} = {\f2 0}, int *  {\i p_Legs} = {\f2 NULL}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v submit_Set\:c_CAN_1D_Pyramid}
{\xe \v c_CAN_1D_Pyramid\:submit_Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_1D_Pyramid::submit_Set (uint64_t *  {\i p_Input}, int  {\i p_Depth}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_CAN_1D_Pyramid.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_2D_Pyramid Class Reference\par \pard\plain 
{\tc\tcl2 \v c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
Inheritance diagram for c_CAN_2D_Pyramid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classc___c_a_n__2_d___pyramid.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Scaffold} (){\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setup_CAN_Scaffold} (){\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_State} (std::string p_How="Encode"){\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_Scaffold} (std::string p_How="Encode"){\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b encode} (uint64_t *p_Input=NULL, int p_Depth=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Buffers} (int p_Style=-1, int p_Leg=0, int *p_Legs=NULL){\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetops} (){\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_All_Traces} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_Given_Trace} (uint64_t p_NID)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query} (uint64_t *p_Input=NULL, int p_Depth=0, int p_Charging_Style=-1, int p_Leg=0, int *p_Legs=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b submit_Set} (uint64_t *p_Input, int p_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b c_Node} * {\b get_Treetop} (int p_Index=-1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold_Char} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_NNet} ({\b c_Node_Network} *p_NNet)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (uint64_t *p_Input, int p_Input_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (std::string p_Input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input} (uint64_t **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_String} (char **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input} (uint64_t ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_String} (char ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Type=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Type=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} **** {\b Scaffold}{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth_X}{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth_Y}{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Top_Tier}{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer} {\b tmp_Buffman}{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Attributes inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node_Network} * {\b NNet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Nodes_Index}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_IO_Set} {\b Input}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_2D_IO_Set} {\b Input_2D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_3D_IO_Set} {\b Input_3D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Trace} * {\b Output}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Output_Depth}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v encode\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:encode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::encode (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_All_Traces\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:gather_All_Traces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::gather_All_Traces (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_Given_Trace\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:gather_Given_Trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::gather_Given_Trace (uint64_t  {\i p_NID}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v get_Treetop\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:get_Treetop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b c_Node} * c_CAN_2D_Pyramid::get_Treetop (int  {\i p_Index} = {\f2 -1}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:output_Scaffold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::output_Scaffold (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold_Char\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:output_Scaffold_Char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::output_Scaffold_Char (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v query\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::query (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}, int  {\i p_Charging_Style} = {\f2 -1}, int  {\i p_Leg} = {\f2 0}, int *  {\i p_Legs} = {\f2 NULL}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v submit_Set\:c_CAN_2D_Pyramid}
{\xe \v c_CAN_2D_Pyramid\:submit_Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_2D_Pyramid::submit_Set (uint64_t *  {\i p_Input}, int  {\i p_Depth}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_CAN_2D_Pyramid.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_3D_Pyramid Class Reference\par \pard\plain 
{\tc\tcl2 \v c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
Inheritance diagram for c_CAN_3D_Pyramid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classc___c_a_n__3_d___pyramid.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Scaffold} (){\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setup_CAN_Scaffold} (){\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_State} (std::string p_How="Encode"){\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_Scaffold} (std::string p_How="Encode"){\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b encode} (uint64_t *p_Input=NULL, int p_Depth=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Buffers} (int p_Style=-1, int p_Leg=0, int *p_Legs=NULL){\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetops} (){\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_All_Traces} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_Given_Trace} (uint64_t p_NID)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query} (uint64_t *p_Input=NULL, int p_Depth=0, int p_Charging_Style=-1, int p_Leg=0, int *p_Legs=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b submit_Set} (uint64_t *p_Input, int p_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b c_Node} * {\b get_Treetop} (int p_Index=-1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold_Char} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_NNet} ({\b c_Node_Network} *p_NNet)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (uint64_t *p_Input, int p_Input_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (std::string p_Input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input} (uint64_t **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_String} (char **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input} (uint64_t ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_String} (char ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Type=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Type=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} ***** {\b Scaffold}{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth_X}{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth_Y}{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth_Z}{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Top_Tier}{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer} {\b tmp_Buffman}{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Attributes inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node_Network} * {\b NNet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Nodes_Index}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_IO_Set} {\b Input}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_2D_IO_Set} {\b Input_2D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_3D_IO_Set} {\b Input_3D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Trace} * {\b Output}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Output_Depth}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v encode\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:encode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::encode (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_All_Traces\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:gather_All_Traces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::gather_All_Traces (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_Given_Trace\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:gather_Given_Trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::gather_Given_Trace (uint64_t  {\i p_NID}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v get_Treetop\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:get_Treetop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b c_Node} * c_CAN_3D_Pyramid::get_Treetop (int  {\i p_Index} = {\f2 -1}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:output_Scaffold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::output_Scaffold (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold_Char\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:output_Scaffold_Char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::output_Scaffold_Char (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v query\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::query (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}, int  {\i p_Charging_Style} = {\f2 -1}, int  {\i p_Leg} = {\f2 0}, int *  {\i p_Legs} = {\f2 NULL}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v submit_Set\:c_CAN_3D_Pyramid}
{\xe \v c_CAN_3D_Pyramid\:submit_Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_3D_Pyramid::submit_Set (uint64_t *  {\i p_Input}, int  {\i p_Depth}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_CAN_3D_Pyramid.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_Many_To_One Class Reference\par \pard\plain 
{\tc\tcl2 \v c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
Inheritance diagram for c_CAN_Many_To_One:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classc___c_a_n___many___to___one.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Scaffold} (){\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setup_CAN_Scaffold} (){\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_State} (std::string p_How="Encode"){\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fill_Scaffold} (std::string p_How="Encode"){\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b encode} (uint64_t *p_Input=NULL, int p_Depth=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Buffers} (int p_Style=-1, int p_Leg=0, int *p_Legs=NULL){\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetops} (){\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_All_Traces} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_Given_Trace} (uint64_t p_NID)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query} (uint64_t *p_Input=NULL, int p_Depth=0, int p_Charging_Style=-1, int p_Leg=0, int *p_Legs=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b submit_Set} (uint64_t *p_Input, int p_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b c_Node} * {\b get_Treetop} (int p_Index=-1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold_Char} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_NNet} ({\b c_Node_Network} *p_NNet)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (uint64_t *p_Input, int p_Input_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (std::string p_Input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input} (uint64_t **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_String} (char **p_Input, int p_X_Depth, int p_Y_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input} (uint64_t ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_String} (char ***p_Input, int p_X_Depth, int p_Y_Depth, int p_Z_Depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Type=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Type=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} ** {\b Scaffold} [2]{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Depth}{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer} {\b tmp_Buffman}{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Attributes inherited from {\b c_Base_CAN}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node_Network} * {\b NNet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Nodes_Index}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_IO_Set} {\b Input}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_2D_IO_Set} {\b Input_2D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_3D_IO_Set} {\b Input_3D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Trace} * {\b Output}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Output_Depth}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v encode\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:encode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::encode (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_All_Traces\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:gather_All_Traces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::gather_All_Traces (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v gather_Given_Trace\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:gather_Given_Trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::gather_Given_Trace (uint64_t  {\i p_NID}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v get_Treetop\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:get_Treetop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b c_Node} * c_CAN_Many_To_One::get_Treetop (int  {\i p_Index} = {\f2 -1}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:output_Scaffold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::output_Scaffold (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v output_Scaffold_Char\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:output_Scaffold_Char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::output_Scaffold_Char (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v query\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::query (uint64_t *  {\i p_Input} = {\f2 NULL}, int  {\i p_Depth} = {\f2 0}, int  {\i p_Charging_Style} = {\f2 -1}, int  {\i p_Leg} = {\f2 0}, int *  {\i p_Legs} = {\f2 NULL}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v submit_Set\:c_CAN_Many_To_One}
{\xe \v c_CAN_Many_To_One\:submit_Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_CAN_Many_To_One::submit_Set (uint64_t *  {\i p_Input}, int  {\i p_Depth}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b c_Base_CAN} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_CAN_Many_To_One.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Charging_Buffer Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Charging_Buffer}
{\xe \v c_Charging_Buffer}
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Outputs} (){\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Given_Leg} ({\b c_Node} *p_Node, double p_Charge=10.00, int p_Leg=0){\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b charge_Given_Legs} ({\b c_Node} *p_Node, int p_Leg_Count, int *p_Leg, double p_Charge=10.00){\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b submit} ({\b c_Node} *p_Node, double p_Charge=10.00){\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather} (){\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b gather_Treetops} (){\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b destroy_Output_Buffers} (){\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_All_Buffers} (){\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Tree} (){\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Charge_LL} (){\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output_LL} (){\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Treetops} (){\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer_Tree} {\b Tree}{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List_Handler} {\b Current_Charge}{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List_Handler} {\b Output}{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List_Handler} {\b Treetops}{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b flg_Not_Done}{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Input_Position}{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Base_Charge}{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Current_Highest_Charge}{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Previous_Highest_Charge}{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Modifier_Charge}{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Action_Potential_Threshold}{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Charging_Array.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Charging_Buffer_Node Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Charging_Buffer_Node}
{\xe \v c_Charging_Buffer_Node}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b Data}{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b LL}{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b c_Charging_Buffer_Tree}{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Charging_Array.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Charging_Buffer_Tree Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Charging_Buffer_Tree}
{\xe \v c_Charging_Buffer_Tree}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b init} (){\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer_Node} * {\b search} ({\b c_Node} *p_Data){\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer_Node} * {\b query_Node} ({\b c_Charging_Buffer_Node} *&p_Node, uint64_t p_Data, int p_Shift){\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Tree} (){\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node} ({\b c_Charging_Buffer_Node} *&p_Node, int p_Tab){\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b get_Node_LL} ({\b c_Charging_Buffer_Node} *&p_Node){\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Node_LL} ({\b c_Charging_Buffer_Node} *&p_Node, {\b c_Charging_Linked_List} *p_LL){\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b set_Current_Node_LL} ({\b c_Charging_Linked_List} *p_LL){\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b get_Current_Node_LL} (){\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer_Node} * {\b Root}{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Buffer_Node} ** {\b Current}{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b flg_Foundit}{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b tmp_Data}{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b tmp_SData}{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Charging_Array.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Charging_Linked_List Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Charging_Linked_List}
{\xe \v c_Charging_Linked_List}
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_LL} (){\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b Next}{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b Previous}{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Charge}{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b NID}{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Charging_Array.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Charging_Linked_List_Handler Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Charging_Linked_List_Handler}
{\xe \v c_Charging_Linked_List_Handler}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b init} (){\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b new_LL} ({\b c_Node} *p_NID, double p_Charge){\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (){\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} * {\b Root}{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Charging_Linked_List} ** {\b Current_LL}{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Depth}{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Charging_Array.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Construct Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Construct}
{\xe \v c_Construct}
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class encapsulates and manipulates the Neural Network Engine directly while providing a public interface. }}\par
{
{\f2 #include <c_Construct.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b add_Assembly} (std::string p_Assembly_Name){\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Node_Ref_By_NID} (uint64_t p_NID){\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Type} ({\b c_Node} *p_Node, uint8_t p_Type){\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b add_Axon_Index} ({\b c_Node} *p_Node, {\b c_Node} *p_Axon, int p_Index){\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Dendrites} ({\b c_Node} *p_Node, int p_Count, {\b c_Node} **p_Dendrites){\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b does_Upper_Tier_Connection_Exist} (int p_Count, {\b c_Node} **p_Nodes){\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b does_Lower_Connection_Exist} ({\b c_Node} *p_Node, int p_Count, {\b c_Node} **p_Nodes){\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bind_State} ({\b c_Node} *p_Node, uint64_t p_State){\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_O} ({\b c_Node} *p_Node){\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_Trace_O} ({\b c_Node} *p_Node, {\b c_Linked_List_Handler} *p_LL){\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Raw} ({\b c_Node} *p_Node){\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Char} ({\b c_Node} *p_Node){\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b register_New_Construct} (){\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b new_Node} (){\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b new_State_Node} (int p_Assembly, double p_State){\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b create_Connections} ({\b c_Node} *p_To, int p_Count, {\b c_Node} **p_From){\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b does_Upper_Tier_Connection_Exist_Network} (int p_Count, {\b c_Node} **p_Legs){\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Upper_Tier_Node} (int p_Count, {\b c_Node} **p_Legs){\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b does_State_Node_Exist} (int p_Assembly, uint64_t p_State){\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_State_Node} (int p_Assembly, uint64_t p_State){\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_BP} (){\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_BP_NID} (int p_NID){\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Network} (){\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b encode} (int p_Assembly, int p_Depth=0, uint64_t *p_Input=NULL){\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b query} (int p_Assembly, uint64_t *p_Input=NULL, int p_Depth=0, int p_Charging_Style=-1, int p_Leg=0, int *p_Legs=NULL){\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b submit_Set} (int p_Assembly, int p_Depth, uint64_t *p_Input){\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Treetop} (int p_Assembly){\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Treetop_NID} (int p_Assembly){\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Treetop_NID_At_Given_Index} (int p_Assembly, int p_Index){\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Trace} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Trace_uint} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Traces} (int p_Assembly){\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Traces_uint} (int p_Assembly){\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} (int p_Assembly){\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_NNet} (int p_Assembly, {\b c_Node_Network} *p_NNet){\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Assembly, int p_Index){\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (int p_Assembly, int p_Input_Depth, uint64_t *p_Input){\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input} (int p_Assembly, int p_X_Depth, int p_Y_Depth, uint64_t **p_Input){\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input} (int p_Assembly, int p_X_Depth, int p_Y_Depth, int p_Z_Depth, uint64_t ***p_Input){\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (int p_Assembly, std::string p_Input){\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Scaffold} (int p_Assembly){\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Assembly){\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input_uint} (int p_Assembly){\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Assembly){\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output_uint} (int p_Assembly){\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Scaffold_Char} (int p_Assembly){\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b register_Assembly} (std::string p_Type, std::string p_Assembly_Name){\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b load_Input} (int p_Assembly){\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b load_Input_uint} (int p_Assembly){\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (int p_Assembly, std::string p_Input){\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_uint} (int p_Assembly, int p_Depth, uint64_t *p_Input){\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Node} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Node_uint} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Nodes} (int p_Assembly){\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Nodes_uint} (int p_Assembly){\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Trace_To_File} (std::ofstream *p_SF, {\b c_Trace} *p_Trace, int p_Output_Type){\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output_To_File} (int p_Assembly, int p_Output_Type=0){\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Output} (int p_Assembly){\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Output_uint} (int p_Assembly){\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b write_Node_To_File} (int p_Assembly, std::ofstream *p_SF, {\b c_Node} *p_Node, int p_Output_Type=0){\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save_Node_To_File} (std::ofstream *p_SF, {\b c_Node} *p_Node, int p_Output_Type=0){\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save_Assemblies} (std::ofstream *p_SF){\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save_Node_Network} (std::ofstream *p_SF){\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save_State_Trees} (std::ofstream *p_SF){\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save} (std::string p_FName){\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load_Assemblies} (std::ifstream *p_SF){\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load_Node} (std::ifstream *p_SF){\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load_Node_Network} (std::ifstream *p_SF){\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load_State_Trees} (std::ifstream *p_SF){\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load} (std::string p_FName){\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetop_Node} (int p_Assembly){\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetop_Node_uint} (int p_Assembly){\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetop_NID} (int p_Assembly){\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Assemblies} (){\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b clear_Output} (int p_Assembly){\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b output_Newline} (int p_Assembly){\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node_Network} {\b Nodes}{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string * {\b Assembly_Names}{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string * {\b Assembly_Input_Files}{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string * {\b Assembly_Output_Files}{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Assembly_Count}{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Base_CAN} ** {\b CAN}{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string * {\b CAN_Type}{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class encapsulates and manipulates the Neural Network Engine directly while providing a public interface. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inside the construct you'll find the raw C++. The interface brings highly granular control from the sub-classes to the surface. On this interface the other ones are built. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Construct.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Construct_API Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Construct_API}
{\xe \v c_Construct_API}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Type} (uint64_t p_NID, uint8_t p_Type){\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b add_Axon_Index} (uint64_t p_NID, uint64_t p_Axon_NID, int p_Index){\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Dendrites} (uint64_t p_NID, int p_Count, uint64_t *p_Dendrite_NIDs){\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b does_Upper_Tier_Connection_Exist} (int p_Count, uint64_t *p_Nodes){\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b does_Lower_Connection_Exist} (uint64_t p_NID, int p_Count, uint64_t *p_Nodes){\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bind_State} (uint64_t p_NID, uint64_t p_State){\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_O} (uint64_t p_NID){\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Raw} (uint64_t p_NID){\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Char} (uint64_t p_NID){\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b register_New_Construct} (){\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b new_Node} (){\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b new_State_Node} (int p_Assembly, double p_State){\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b create_Connections} (uint64_t p_To_NID, int p_Count, uint64_t *p_From_NID){\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b does_Upper_Tier_Connection_Exist_Network} (int p_Count, uint64_t *p_Legs_NID){\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Upper_Tier_Node} (int p_Count, uint64_t *p_Legs_NID){\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b does_State_Node_Exist} (int p_Assembly, uint64_t p_State){\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_State_Node} (int p_Assembly, uint64_t p_State){\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_BP} (){\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_BP_NID} (int p_NID){\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Network} (){\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b encode} (int p_Assembly){\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b query} (int p_Assembly){\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b query_Spacial} (int p_Assembly){\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b query_Given_Index} (int p_Assembly, int p_Index){\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b query_Given_Legs} (int p_Assembly, int p_Leg_Count, int *p_Legs){\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b submit_Set} (int p_Assembly, int p_Depth, uint64_t *p_Input){\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Treetop_NID} (int p_Assembly){\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Trace} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Traces} (int p_Assembly){\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset_Input} (int p_Assembly){\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_State_Nodes_Index} (int p_Assembly, int p_Index){\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Scaffold} (int p_Assembly){\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input} (int p_Assembly){\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Input_uint} (int p_Assembly){\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output} (int p_Assembly){\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Output_uint} (int p_Assembly){\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Scaffold_Char} (int p_Assembly){\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b register_Assembly} (std::string p_Type, std::string p_Assembly_Name){\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b load_Input} (int p_Assembly){\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b load_Input_uint} (int p_Assembly){\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (int p_Assembly, std::string p_Input){\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_uint} (int p_Assembly, int p_Depth, uint64_t *p_Input){\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input} (int p_Assembly, int p_Input_Depth, uint64_t *p_Input){\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_uint} (int p_Assembly, int p_X_Depth, int p_Y_Depth, uint64_t **p_Input){\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_uint} (int p_Assembly, int p_X_Depth, int p_Y_Depth, int p_Z_Depth, uint64_t ***p_Input){\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Input_String} (int p_Assembly, std::string p_Input){\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Node} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Given_Node_uint} (int p_Assembly, uint64_t p_NID){\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Nodes} (int p_Assembly){\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_All_Nodes_uint} (int p_Assembly){\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Output} (int p_Assembly){\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Output_uint} (int p_Assembly){\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetop_Node} (int p_Assembly){\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetop_Node_uint} (int p_Assembly){\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b gather_Treetop_NID} (int p_Assembly){\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Assemblies} (){\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b clear_Output} (int p_Assembly){\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b output_Newline} (int p_Assembly){\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save} (std::string p_FName){\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load} (std::string p_FName){\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Construct} {\b Base}{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Construct_API.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Construct_Text_Server Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server}
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a handshake based text interface for the engine. }}\par
{
{\f2 #include <c_Construct_Text_Server.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_Type} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the type of a given node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_Axon_Index} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given NID to an Axon on the given Hillock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_Dendrites} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the dendrites of the node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b does_Upper_Tier_Connection_Exist} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searches the axons to see if an upper tier connection exists, if found returns the NID, if not returns 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b does_Lower_Connection_Exist} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the given node has dendrites that match the given nodes in the given order. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bind_State} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Binds a node to a quanta of data, the state of the input, as uint64_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bp_O} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern represented by this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Node_Raw} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the ugly raw info dump for the node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Node_Char} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Casts the node address to char() and outputs it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b register_New_Construct} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to differentiate a new construct, allocates a state tree to handle a state-node space. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b new_Node} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new node in the shared node network. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b new_State_Node} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new node, binds it to a state, sets the type to 0 or 3 depending, and adds the node to the state tree with the state registered. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b create_Connections} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a connection between nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b does_Upper_Tier_Connection_Exist_Network} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if an upper tier node exists, functionally the same as does_Upper_Tier_Connection_Exist on the node, but this includes error handling. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b get_Upper_Tier_Node} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets an upper tier node based on the given legs, will create it if not found. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b does_State_Node_Exist} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a state node exists in the given construct index then return it, otherwise return 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b get_State_Node} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks to see if a node in the given assembly is bound to the given state, if not the node is created & the NID returned, if found the NID is returned. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_BP} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterates through every node and outputs their {\b bp_O()} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_BP_NID} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finds given NID and outputs the {\b bp_O()}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b encode} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encodes the current input of the given assembly. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network with the current input set for the given construct, evaluates the input set and stores the results in the output traces, gathered using 'gather_Output'. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query_Spacial} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network with the current input set of the given assembly, but the input index determines what leg is charged. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query_Given_Index} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network with the current input set, however, every input node is charged using the given index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b query_Given_Legs} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network using the current input set of the given assembly, however, an array of legs is passed that signifies whether or not each individual leg is to be charged and every input queried to all axon_hillocks/legs set to fire. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b submit_Set} (std::ifstream *p_File){\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b get_Treetop_NID} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the treetop node for a given construct and puts it in the output file for that construct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_Given_Trace} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a single trace from a given node, puts it in the output file for the given construct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gather_All_Traces} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gathers all the traces through a given construct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset_Input} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to wipe the input array of a given construct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_State_Nodes_Index} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the index for the given Construct state_Node_Tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b set_Input} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This command sets the input of a given construct to the given input string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_Input_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the input of a given construct to the given array of uint64_t values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_2D_Input_uint} (std::ifstream *p_File){\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_3D_Input_uint} (std::ifstream *p_File){\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the scaffold as node IDs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Input} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the input of the given construct to the console. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Input_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the input of the given construct to the console, but as uint. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Output} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The output trace set is output. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Output_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The output trace set is output as uint64_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b output_Scaffold_Char} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the scaffold as characters typecase from the ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b register_Assembly} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registers a Construct with the neural net engine of the given architecture and name desired. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b load_Input} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads the input file associated with the given construct into the input array. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b load_Input_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads the input file associated with the given construct into the input array as uint. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Given_Node} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This outputs the patterns as string when given a node ID (NID). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Given_Node_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This outputs the patterns as an array of uint64_t when given a node ID (NID). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_All_Nodes} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gathers all of the nodes to the given constructs output. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_All_Nodes_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gathers all of the nodes to the given constructs output as an array of uint64_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Output} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as char. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Output_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as uint64_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Treetop_Node} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Treetop_Node_uint} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node, the output pattern will be uint64_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gather_Treetop_NID} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This takes the current treetop node from the CAN Scaffold (if one exists) and outputs the NID to the output file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b output_Node_Network} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This iterates through every node outputting them to the console. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b output_Node} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given node as defined by the passed NID to the console. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b output_Assemblies} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the constructs currently registered. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b clear_Output} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wipes and output file for a given construct, CLS for the output file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b output_Newline} (std::ifstream *p_File)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You give it a construct ID and it outputs a newline to the output file associated with that construct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save} (std::ifstream *p_File){\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b load} (std::ifstream *p_File){\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b run} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main loop for the neuro-server. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a handshake based text interface for the engine. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File-Based Command Control System for Asynchronous Standalone Neural-Net Engine Control:\par
Text-Based Command Execution:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Commands are represented as text strings that specify actions or operations to be performed by the system or process.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Each command is associated with a specific functionality or operation within the system.\par}
\par
File I/O:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Input and output operations are performed using files as the medium of communication.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Commands are read from input files, and outputs, returns, and status indicators are written to output files, though some commands do output to the console.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This method facilitates asynchronous communication between systems, as they can read from and write to files independently.\par}
\par
Handshake Protocol:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A handshake protocol is used to establish communication or synchronize actions between systems.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In this context, a flag file serves as a mechanism for signaling the readiness or completion of certain operations, namely that the user has written a command sequence to 'Control_Panel.ssv' that is ready to be interpreted..\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The content of the flag file is used to indicate the status of the control panel, allowing the system to either wait or act accordingly.\par}
\par
Flag File:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A flag file is a small file used to signal the status or state of the system.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
It typically contains simple data or metadata, such as a single value or indicator, to convey information. In the {\b NT4} text interface it is a boolean value.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Flag files are used as synchronization primitives to coordinate activities between systems.\par}
\par
Control Panel:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The control panel represents a set of commands or instructions that can be executed by the system or process.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
It is stored in a separate file (e.g., Control_Panel.ssv), which contains a sequence of commands or directives to be processed.\par}
\par
Interpretation and Execution:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The system interprets commands read from the control file (e.g., Control_Panel.ssv) and executes them sequentially.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Command execution may involve performing operations on data, manipulating the state of the system, or interacting with external resources.\par}
\par
Status Checking and Control Flow:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The system periodically checks the status of a flag file (e.g., Control_Panel_Flag.ssv) to determine if there are new commands to execute or if certain operations have completed.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Based on the status indicated by the flag file, the system may initiate specific actions, continue processing, or wait for further instructions.\par}
\par
Startup and 'autoexec.ssv':{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For 'booting up' the system interprets the commands found in 'autoexec.ssv' sequentially. This allows for shell scripting a startup sequence.\par}
\par
Custom Commands:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A script file placed in "./Scripts/" can be called by simply entering the filename as you would a command token. A file can call other files so you can create dependency hell for yourself if you wish, but with the added complexity of ML. \par}
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add_Axon_Index\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:add_Axon_Index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::add_Axon_Index (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a given NID to an Axon on the given Hillock. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note this is selecting a hillock not assigning an axonal ID, if the index doesn't exist then exist it with resize_Axon_Hillocks()\par
add_axon_index NID Axon_NID HILLOCK_INDEX {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID (NID) of the node being manipulated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{AXON_NID The NID of the node that the axon will reference. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{INDEX The hillock the axon is put onto, not the axon ID. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
The nodes keep track of which dendrite their upper connections are connected to by encoding them into respective "axon hillocks". Basically we take whichever dendrite index the connection is connected to and create an axonic group that represents those connections to legs of that index. This allows for advanced search of the networks including time-series and more.\par
Example Usage:\par
Adding an axonic connection to node 42 on axon hillock 5 of node 16 to represent that it is Dendrite[5] on the node above. We will use output_Node_Raw after setting the axon to show the result. This assumes no previous axonic connections or dendrites and it is a quanta bound state node with the state set to the uint64_t value 99. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 16\par
add_Axon_Index 16 42 5\par
output_Node_Raw 16\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 16 RC: 1 Type: 0  State \{ 99 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 16 RC: 1 Type: 0  State \{ 99 \} --- Dendrites:  --- Axon_Hillock_Count: 6  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <0>:  Axons[3] <0>:  Axons[4] <0>:  Axons[5] <1>: [0] 42\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Invalid axon IDs will not cause an immediate crash, but any function which touches the axons will crash when attemting to reference the invalid axon NIDs. \par}
}}
{\xe \v bind_State\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:bind_State}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::bind_State (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Binds a node to a quanta of data, the state of the input, as uint64_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bind_State NID STATE {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID of the node being manipulated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The state of the input, the current quanta, or element, of information being encoded. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
At the interface between the networks internal node structure and the exterior information space exists the state tier, this is the interface where outside information binds to nodes to allow for communication coherently across the internal/external space. Outside you have the information to be encoded, this information is composed of differentiated information, the smallest piece of coherent information that the abstractions are built upon is the quanta. This quanta is a pixel, a character, an integer, a scalar value. A quantifiable and discrete piece of information which forms the basis of the patterns of information you will be encoding/decoding from the neural matrix. This doesn't have to be low level abstraction wise, only that is has a hash or scalar abstraction that can be cast to uint64. It could represent the hash of a full 3D body scan as easily as a scalar value from a thermal sensor.\par
This function binds the state to the node to form the interface, an absolutely crucial function to the distributed symbol neural networks.\par
Example Usage:\par
We will bind the uint state 1234321 to node 10, outputting the node before and after the operation using 'output_Node_Raw 10'. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 10\par
bind_State 10 1234321\par
output_Node_Raw 10\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 10 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 10 RC: 1 Type: 0  State \{ 1234321 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash. \par}
}}
{\xe \v bp_O\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:bp_O}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::bp_O (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initiates a backpropagation (feedbackward info cascade ! weight adjustment) that outputs the pattern represented by this node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bp_O NID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID of the node who's information symbol is being output. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
The patterns that are encoded, the traces, are encoded in a deterministic and hierarchical manner. This allows us the oppurtunity to craft algorithms to "walk" the structure down and retrieve the original input pattern stored in the relationships of the nodes on the various tiers, or layers, or abstraction.\par
This function outputs the full symbol represented by the node given. It walks the tree to output the pattern perfectly as it was originally encoded.\par
Example Usage:\par
In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 1-9 have already been created so our first node will be NID 10. This results in 4 nodes created, 3 state tier nodes \{ 10, 11, 12 \} and 1 upper tier treetop node \{ 13 \}. We will output all the nodes, then demonstrate the bp_O. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 10\par
output_Node_Raw 11\par
output_Node_Raw 12\par
output_Node_Raw 13\par
bp_O 13\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 10 RC: 1 Type: 0  State \{ 64 \} --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] <1>: 13\par
Node_ID (NID) 11 RC: 1 Type: 0  State \{ 128 \} --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] <0>:  Axons[1] <1>: 13\par
Node_ID (NID) 12 RC: 1 Type: 0  State \{ 256 \} --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>: 13\par
Node_ID (NID) 13 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 10 [1] 11 [2] 12 --- Axon_Hillock_Count: 0\par
<=- 13 * [double(64), 64]  [double(128), 128]  [double(256), 256] -=>\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Note that the 'double(n)' in the real output is the actual cast value and not the typecast definition.\par}
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If you crash when calling this and the node is valid then check your dendrites. \par}
}}
{\xe \v clear_Output\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:clear_Output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::clear_Output (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wipes and output file for a given construct, CLS for the output file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clear_Output CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The ID of the construct who's output file is getting deleted. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Opens the output file associated with the given construct using truncate (ios::ate) to wipe the file.\par
Used in scripting for manipulating the output files through the engine to wipe them, or manually, but this allows obtuse control through the engine.\par
Example Usage:\par
Here we setup a construct, encode a string, gather the treetop node into the output file, output the output, wipe the output using this function, then recheck the output file to make sure: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 Night Gaunt /end/\par
encode 0\par
gather_Treetop_Node 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11 2 11 1 2 3 4 5 6 7 8 9 10 5 0 11 Night Gaunt\par
}
 Now we use this function to wipe the file: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid clear_Output 0\par
}
 Output: Contents of "./Output/ExaCon.Output.ssv":\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v create_Connections\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:create_Connections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::create_Connections (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a connection between nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create_Connections TO_NID COUNT FROM_NIDS[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{TO_NID This is the node that all the lower nodes connect to, the one that receives the dendritic connections. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODE_COUNT The number of nodes to connect to the upper tier node. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODES[] The array of node NIDs that are the lower nodes, they receive the axonic connections. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
p_To forms dendritic connections to p_From, and on p_From you have the axonic connections. This function uses set_Dendrites on the upper tier node and sets the axon for the lower nodes to create the two way connection. The doubly linked tiered nodes.\par
Example Usage:\par
In this example we have an upper tier node we created with the NID 100, and 5 lower nodes with NIDs \{ 10, 20, 30, 40, 50 \}. We assume no nodes have any connections as of yet. We will be outputting the nodes before and after. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 10\par
output_Node_Raw 20\par
output_Node_Raw 30\par
output_Node_Raw 40 \par
output_Node_Raw 50\par
output_Node_Raw 100\par
\par
create_Connections 100 5 10 20 30 40 50\par
\par
output_Node_Raw 10\par
output_Node_Raw 20\par
output_Node_Raw 30\par
output_Node_Raw 40\par
output_Node_Raw 50\par
output_Node_Raw 100\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 10 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 20 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 30 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 40 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 50 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 100 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
\par
Node_ID (NID) 10 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] <1>: 100\par
Node_ID (NID) 20 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] <0>:  Axons[1] <1>: 100\par
Node_ID (NID) 30 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>: 100\par
Node_ID (NID) 40 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <0>:   Axons[2] <1>: 100\par
Node_ID (NID) 50 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <0>:   Axons[2] <0>:   Axons[2] <1>: 100\par
Node_ID (NID) 100 RC: 1 Type: 0  State \{ 0 \} --- Dendrites: [0] 10 [1] 20 [2] 30 [3] 40 [4] 50  --- Axon_Hillock_Count: 0\par
}
\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This does nothing for setting or binding states, or setting node types, this function is purely to create these connections.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Passing invalid nodes will cause it to crash when it tries to call the NULL object to create either dendrite or axon connections. \par}
}}
{\xe \v does_Lower_Connection_Exist\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:does_Lower_Connection_Exist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool c_Construct_Text_Server::does_Lower_Connection_Exist (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the given node has dendrites that match the given nodes in the given order. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
does_Lower_Connection_Exist NID NODE_COUNT NODES[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID of the node being manipulated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODES[] The array of NIDs to look for. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bool} \cell }{This function returns a 1 (true) or 0 (false) depending on whether the dendrites match the given nodes or not.\cell }
{\row }
}
This takes a given node and a set of node IDs (NIDs) to check. It checks each dendrite leg against the given node list to see if they all match or not. If one is found that doesn't match it return 0 immediately. Used during encoding to find out whether a compound higher tier symbol has been encoded yet.\par
Example Usage:\par
We will check node 75 which has the dendrites \{ 5, 6, 7 \} to see if it matches the given dendrite set \{ 5, 6, 8 \}, which we know it does not. Then we will output a newline in the output file and check node 76 which in this example has the dendrites \{ 5, 6, 8 \} which match the given set outputting 1 to the RETURN_FILE. Before checking each node we'll output it to show the dendrites so you can see them yourself. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 75\par
does_Lower_Connection_Exist 75 3 5 6 8\par
newline returns\par
output_Node_Raw 76\par
does_Lower_Connection_Exist 76 3 5 6 8\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 75 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0\par
Node_ID (NID) 76 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 5 [1] 6 [2] 8 --- Axon_Hillock_Count: 0\par
}
 Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0\par
1\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the given node count exceeds the dendrite count you will cause it to crash. This is due to the function assuming the count will not exceed the number of defined dendrites and iterates trustfully through it. This is by design as this function will be called many often and is a potential bottleneck. \par}
}}
{\xe \v does_State_Node_Exist\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:does_State_Node_Exist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::does_State_Node_Exist (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a state node exists in the given construct index then return it, otherwise return 0. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
does_State_Node_Exist CONSTRUCT_ID STATE {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to search. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The node that represents the state passed to this function. Passes the NID back if found, if not found it passes back 0.\cell }
{\row }
}
Checks the state tree of a given construct to see if the state is registered and bound to a node within that state space.\par
Example Usage:\par
We have a state node registered to construct 3 with the state 123. This state node is NID 50. We run 'does_State_Node_Exist 2 123' which returns the NID 50 as it found the node bound to the state '123' registered within construct 2's fractal state tree. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid does_State_Node_Exist 2 123\par
}
 Output:\par
Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This assumes the [CONSTRUCT_ID] is valid \par}
}}
{\xe \v does_Upper_Tier_Connection_Exist\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:does_Upper_Tier_Connection_Exist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::does_Upper_Tier_Connection_Exist (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Searches the axons to see if an upper tier connection exists, if found returns the NID, if not returns 0. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
does_Upper_Tier_Connection_Exist NODE_COUNT NODES[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODES[] The array of NIDs to look for. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID This function return the NID of a node matching the description, returns 0 if none are found.\cell }
{\row }
}
This is used during encoding and performing a query. It traverses the connections in the given NID's first axon hillock. For each of these connections it does a does_Lower_Connection_Exist to see if that node matches. By searching the first legs we keep the search limited to only those with the possiblity to match the search string of connections. We know this is the case because if the first node in a string of nodes has an upper tier connection then that gives us a connection to a node that at least shares index[0] with our current lower-tier node and by checking every other dendrite index of the upper tier node against the respective index in the passed node array we can know for sure if our current pattern exists yet. After checking all of the upper tier connections on axon hillock 0 if we come up with no confirmed connections we know that the current arrangement of nodes hasn't been encoded into a higher tier node symbol yet.\par
Example Usage:\par
We will use the example containing a set of nodes \{ 5 6 7 \}, node 5 has 2 axonic connections with the second having the correct configuration of legs meaning we found it. This second node has the NID 75, we know node 75 has the correct connection so we output it manually to show the node data. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Raw_Node 75\par
does_Upper_Tier_Connection_Exist 3 5 6 7\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 75 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0\par
}
 Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash. \par}
}}
{\xe \v does_Upper_Tier_Connection_Exist_Network\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:does_Upper_Tier_Connection_Exist_Network}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::does_Upper_Tier_Connection_Exist_Network (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if an upper tier node exists, functionally the same as does_Upper_Tier_Connection_Exist on the node, but this includes error handling. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
does_Upper_Tier_Connection_Exist_Network NODE_COUNT NODES[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODES[] The array of NIDs to look for. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID This function return the NID of a node matching the description, returns 0 if none are found.\cell }
{\row }
}
This is used during encoding and performing a query. It traverses the connections in the given NID's first axon hillock. For each of these connections it does a does_Lower_Connection_Exist to see if that node matches. By searching the first legs we keep the search limited to only those with the possiblity to match the search string of connections. We know this is the case because if the first node in a string of nodes has an upper tier connection then that gives us a connection to a node that at least shares index[0] with our current lower-tier node and by checking every other dendrite index of the upper tier node against the respective index in the passed node array we can know for sure if our current pattern exists yet. After checking all of the upper tier connections on axon hillock 0 if we come up with no confirmed connections we know that the current arrangement of nodes hasn't been encoded into a higher tier node symbol yet.\par
Example Usage:\par
We will use the example containing a set of nodes \{ 5 6 7 \}, node 5 has 2 axonic connections with the second having the correct configuration of legs meaning we found it. This second node has the NID 75, we know node 75 has the correct connection so we output it manually to show the node data. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Raw_Node 75\par
does_Upper_Tier_Connection_Exist_Network 3 5 6 7\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 75 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0\par
}
 Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This function makes sure that the first node on the submitted node set is not NULL before calling does_Upper_Tier_Connection_Exist. This command is safer than the direct node 'does_Upper_Tier_Connection_Exist'.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None \par}
}}
{\xe \v encode\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:encode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::encode (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encodes the current input of the given assembly. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
encode CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to use when encoding. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This encodes the p_Input data, if the nodes aren't found they are created, used for training. How it does this is determined by what type of construct it is. Different constructs can have different structures depending on whether they are many to one, 2d pyramidal, 3d pyramidal, stiched based, etc.\par
To encode a construct you must first have input loaded into it. Once the input is loaded then calling this will encode the input pattern into a construct. The way to use this is to first get input to the construct, then you tell it to encode the input, then you can use gather, output, and other functions to access the results.: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Get Input: set_Input | set_Input_uint | load_Input\par
 Do something with the Input: encode\par
 Get your Output: gather_X | output_X \par
}
 Example Usage:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
First we create a construct of the type Many_To_One named ExaCon for Example Construct.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Then we use set_Input_uint to load the uint array \{ 10, 15, 20 \} into ExaCon's input.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
After the input is set we call encode on ExaCon, which is construct ID [0].\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
We then use output_Scaffold to view the encoded trace.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This example is a Many_To_One, which means all state nodes (Tier[0]) are connected to a single upper tier (Tier[1]) treetop node.\par
register_Assembly Many_To_One ExaCon set_Input_uint 0 5 3 10 15 20 encode 0 output_Scaffold 0 output_Node_Network gather_All_Nodes 0\par}
Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  __COMMAND__| output_Scaffold CONSTRUCT_ID |\par
  --==   CAN_Scaffold   ==--\par
 <- Tier[0] ->\par
   [0]  <> 1\par
   [1]  <> 2\par
   [2]  <> 3\par
 <- Tier[1] ->\par
   [0]  <> 4\par
\par
 __COMMAND__| output_node_network |\par
 Node_ID (NID): 0  RC: 1 Type: 0 State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 1  RC: 2 Type: 0 State \{ 10 \} --- Dendrites:  --- Axon_Hillock_Count: 1 Axons[0] <1>:  [0] 4\par
 Node_ID (NID): 2  RC: 2 Type: 0 State \{ 15 \} --- Dendrites:  --- Axon_Hillock_Count: 2 Axons[0] <0>:  Axons[1] <1>:  [0] 4\par
 Node_ID (NID): 3  RC: 2 Type: 0 State \{ 20 \} --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>:  [0] 4\par
 Node_ID (NID): 4  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 1 [1] 2 [2] 3 --- Axon_Hillock_Count: 0\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Here is another example, except this time we're encoding the phrase "the quick brown fox jumped over the lazy dog" to show language being encoded.\par
register_Assembly Many_To_One ExaCon set_Input 0 the quick brown fox jumps over the lazy dog encode 0 output_Scaffold 0 gather_All_Nodes 0\par}
Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0 1 0 0 1\par
1 3 0 32 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 t\par
2 3 0 33 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 h\par
3 4 0 34 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 1 28 1 e\par
4 9 0 40 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 1 28 0 0 0 0 0 1 28 0 0 0 0 1 28 0 0 0 1 28 0 0 0 0 1 28 1\par
5 2 0 5 0 0 0 0 1 28 1 q\par
6 3 0 22 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 u\par
7 2 0 7 0 0 0 0 0 0 1 28 1 i\par
8 2 0 8 0 0 0 0 0 0 0 1 28 1 c\par
9 2 0 9 0 0 0 0 0 0 0 0 1 28 1 k\par
10 2 0 11 0 0 0 0 0 0 0 0 0 0 1 28 1 b\par
11 3 0 30 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 r\par
12 5 0 42 0 0 0 0 0 0 0 0 0 0 0 0 1 28 0 0 0 0 1 28 0 0 0 0 0 0 0 0 1 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 o\par
13 2 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 w\par
14 2 0 15 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 n\par
15 2 0 17 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 f\par
16 2 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 x\par
17 2 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 j\par
18 2 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 m\par
19 2 0 24 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 p\par
20 2 0 25 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 s\par
21 2 0 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 v\par
22 2 0 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 l\par
23 2 0 37 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 a\par
24 2 0 38 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 z\par
25 2 0 39 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 y\par
26 2 0 41 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 d\par
27 2 0 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 28 1 g\par
28 2 43 1 2 3 4 5 6 7 8 9 4 10 11 12 13 14 4 15 12 16 4 17 6 18 19 20 4 12 21 3 11 4 1 2 3 4 22 23 24 25 4 26 12 27 0 43 the quick brown fox jumps over the lazy dog\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. \par}
}}
{\xe \v gather_All_Nodes\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_All_Nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_All_Nodes (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gathers all of the nodes to the given constructs output. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_All_Nodes CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's output will be used. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Loops through each node and gathers them into the output file associated with the given construct.\par
Example Usage:\par
Register a construct and encode the string 'qwerty': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 qwerty /end/\par
encode 0\par
}
 Now use this function to gather all the nodes to the output file associated with the given construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_All_Nodes 0\par
}
\par
Output:\par
Contents of "./ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0 1 0 0 1\par
1 2 0 1 1 7 1 q\par
2 2 0 2 0 1 7 1 w\par
3 2 0 3 0 0 1 7 1 e\par
4 2 0 4 0 0 0 1 7 1 r\par
5 2 0 5 0 0 0 0 1 7 1 t\par
6 2 0 6 0 0 0 0 0 1 7 1 y\par
7 2 6 1 2 3 4 5 6 0 6 qwerty\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_All_Nodes_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_All_Nodes_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_All_Nodes_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gathers all of the nodes to the given constructs output as an array of uint64_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_All_Nodes_uint CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's output will be used. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Loops through each node and gathers them into the output file associated with the given construct, the output states/patterns are uint64_t.\par
Example Usage:\par
Register a construct and encode the array \{ 499, 500, 501 \}: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 3 499 500 501\par
encode 0\par
}
 Now use this function to gather all the nodes to the output file associated with the given construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_All_Nodes_uint 0\par
}
\par
Output:\par
Contents of "./ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0 1 0 0 1 0\par
1 2 0 1 1 4 1 499\par
2 2 0 2 0 1 4 1 500\par
3 2 0 3 0 0 1 4 1 501\par
4 2 3 1 2 3 0 3 499 500 501\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_All_Traces\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_All_Traces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::gather_All_Traces (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gathers all the traces through a given construct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_All_Traces CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{This is the construct who's output file will be used to store the results of the query. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, it stores the results in the output file of the given construct.\cell }
{\row }
}
This iterates over the network and calls gather_Given_Trace for every node.\par
Example Usage:\par
We encode some data into our newly minted construct, and then get the traces from it: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 ABRACADABRA /end/ encode 0\par
set_Input 0 FIREBALL /end/ encode 0\par
gather_All_Traces 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0 0 1 1\par
1 0 7 1 A\par
2 0 4 1 B\par
3 0 4 1 R\par
4 0 2 1 C\par
5 0 2 1 D\par
6 0 2 11 ABRACADABRA\par
7 0 2 1 F\par
8 0 2 1 I\par
9 0 2 1 E\par
10 0 3 1 L\par
11 0 2 8 FIREBALL\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Given_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Given_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Given_Node (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This outputs the patterns as string when given a node ID (NID). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Given_Node CONSTRUCT_ID NID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The ID of the construct to use for gathering the node, the output will go to the output file associated with the construct given. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NID} \cell }{The node ID (NID) of the node who's pattern we will be gathering, or decoding. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{This function write the string represented by the given NID to an output file associated with the given Construct.\cell }
{\row }
}
This is used when you want to retrieve a pattern from a NID.\par
Example Usage:\par
The first step is to encode a pattern, into a newly minted construct for this example though it doesn't have to be new, it can be an old heirloom construct passed down through the generations: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 The Dream Quest of Unkown Kadath /end/\par
encode 0\par
output_Scaffold\par
}
 Which shows us:\par
Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 5\par
  [5]  <> 6\par
  [6]  <> 3\par
  [7]  <> 7\par
  [8]  <> 8\par
  [9]  <> 4\par
  [10]  <> 9\par
  [11]  <> 10\par
  [12]  <> 3\par
  [13]  <> 11\par
  [14]  <> 12\par
  [15]  <> 4\par
  [16]  <> 13\par
  [17]  <> 14\par
  [18]  <> 4\par
  [19]  <> 15\par
  [20]  <> 16\par
  [21]  <> 17\par
  [22]  <> 13\par
  [23]  <> 18\par
  [24]  <> 16\par
  [25]  <> 4\par
  [26]  <> 19\par
  [27]  <> 7\par
  [28]  <> 20\par
  [29]  <> 7\par
  [30]  <> 12\par
  [31]  <> 2\par
<- Tier[1] ->\par
  [0]  <> 21\par
}
 From this we can see the upper tier node is '21'. So we tell it to retrieve that node, however, we create a new construct and get the node through that construct to show that as long as the construct is the same type we can retrieve patterns encoded into the nodes: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One RandomCon\par
gather_Given_Node 1 21\par
}
 For an output of:\par
Contents of file "./Output/RandomCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 2 32 1 2 3 4 5 6 3 7 8 4 9 10 3 11 12 4 13 14 4 15 16 17 13 18 16 4 19 7 20 7 12 2 0 32 The Dream Quest of Unkown Kadath\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Given_Node_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Given_Node_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Given_Node_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This outputs the patterns as an array of uint64_t when given a node ID (NID). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Given_Node_uint CONSTRUCT_ID NID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The ID of the construct to use for gathering the node, the output will go to the output file associated with the construct given. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NID} \cell }{The node ID (NID) of the node who's pattern we will be gathering, or decoding. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{This function write the string represented by the given NID to an output file associated with the given Construct.\cell }
{\row }
}
This is used when you want to retrieve a pattern from a NID as an array of uint64_t.\par
Example Usage:\par
In this example we will encode two lower tier constructs to get the NIDs, and feed them into an MSC and get a single treetop node that represents the super-symbol of all the input encoded into a single retrievable trace. We wil then use this to get the original input patterns back out.\par
3 networks must be crafted with care, two raw tier constructs, and one higher multi-sensory construct (MSC): {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
register_Assembly Many_To_One ConExa\par
register_Assembly Many_To_One ExaMSC\par
}
 Now we'll encode the two raw constructs ExaCon and ConExa. ExaCon will be temperature, and ConExa will be oxygen: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 Temperature: 2 /end/\par
encode 0\par
set_Input 1 Oxygen: 4 /end/\par
encode 1\par
}
 Then we use gather_Treetop_Node function to get both treetops, and to output the raw node for each so we can see the full data to confirm this function works: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Treetop_NID 0\par
output_Newline 0\par
gather_Treetop_Node 0\par
\par
gather_Treetop_NID 1\par
output_Newline 1\par
gather_Treetop_Node 1\par
}
 Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12\par
12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 2\par
}
 Contents of "./Output/ConExa.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22\par
22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 4\par
}
 Now that we have these \{ 12, 22 \} we can move onto the multi-sensory construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input_uint 2 2 12 22\par
encode 2\par
}
 Gather the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Treetop_NID 2\par
output_Newline 2\par
gather_Treetop_Node_uint 2\par
}
 Contents of "./Output/ExaMSC.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25\par
25 2 2 23 24 0 2 12 22\par
}
 FINALLY we can use this function to get the information back out, starting by wiping the output files: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid clear_Output 0\par
clear_Output 1\par
clear_Output 2\par
}
 Now we get the pattern from our highest abstraction, the treetop from ExaMSC, NID number 25. Moving forward we will only use information retrieved from the network to reconstruct symbol #25, no previous trained knowledge we will use, only meta and structural: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Given_Node_uint 0 25\par
}
 Which gives us the file contents (in ExaCon! Which isn't the construct which encoded the pattern, to show the network is shared):\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25 2 2 23 24 0 2 12 22\par
}
 Looking at this trace we see \{ 2 12 22 \} at the end, which means 2 elements, which are 12 & 22 repectively.\par
We then output newline, gather the node 12, another newline, then the node 22. We use the default gather_Given_Node here to get the raw data, but we've shown the uint by using it to get this far: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
gather_Given_Node 0 12\par
output_Newline 0\par
gather_Given_Node 0 22\par
}
 Results found in "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25 2 2 23 24 0 2 12 22\par
12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 2\par
22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 4\par
}
 As you can see we have encoded and retrieved all patterns using this function for the MSC traces, and the gather_Given_Node for the raw.\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Given_Trace\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Given_Trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::gather_Given_Trace (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a single trace from a given node, puts it in the output file for the given construct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Given_Trace CONSTRUCT_ID NID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{This is the ID of construct who's output file will have the trace written to it. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NID} \cell }{The ID of the node from which the pattern, or trace, will be extracted usin the backpropagation functions. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, output is done through the output file of the given construct.\cell }
{\row }
}
Searches the network for the given NID and if found it outputs the pattern represented by the node to the output file of the specified construct.\par
This is used when you want to retrieve encoded information.\par
Example Usage:\par
First we encode some information. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 THE GAME /end/\par
encode 0\par
output_Scaffold 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 5\par
  [5]  <> 6\par
  [6]  <> 7\par
  [7]  <> 3\par
<- Tier[1] ->\par
  [0]  <> 8\par
}
 Then we can extract it by using the NID from above: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Given_Trace 0 8\par
}
 Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8 0 2 8 THE GAME\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Output\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Output (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as char. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Output CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's output is being gathered, or being written to the output file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Writes the output from a construct to the output file associated with that construct so that you can get the results of queries and other functions which result in a construct having traces in the output array.\par
Example Usage:\par
First we register our construct & encode a series of +- strings: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 --- /end/ encode 0\par
set_Input 0 --+ /end/ encode 0\par
set_Input 0 -+- /end/ encode 0\par
set_Input 0 -++ /end/ encode 0\par
set_Input 0 +-- /end/ encode 0\par
set_Input 0 +-+ /end/ encode 0\par
set_Input 0 ++- /end/ encode 0\par
set_Input 0 +++ /end/ encode 0\par
}
 Now we set the input and query it for the '+' char: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 + /end/\par
query 0\par
}
 Then to see the result we use gather_Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Output 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7 10 2 3 +--\par
 8 20 2 3 +-+\par
 9 20 2 3 ++-\par
10 30 2 3 +++\par
 5 10 2 3 -+-\par
 6 20 2 3 -++\par
 4 10 2 3 --+\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Output_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Output_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Output_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes every trace in the given Construct output trace array and writes them to the output file associated with that construct., note the output state patterns are treated as uint64_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Output_uint CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's output is being gathered, or being written to the output file. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Writes the output from a construct to the output file associated with that construct so that you can get the results of queries and other functions which result in a construct having traces in the output array.\par
Example Usage:\par
First we register our construct & encode a series of 3 item arrays: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 3 11 11 11 encode 0\par
set_Input_uint 0 3 11 11 99 encode 0\par
set_Input_uint 0 3 11 99 11 encode 0\par
set_Input_uint 0 3 11 99 99 encode 0\par
set_Input_uint 0 3 99 11 11 encode 0\par
set_Input_uint 0 3 99 11 99 encode 0\par
set_Input_uint 0 3 99 99 11 encode 0\par
set_Input_uint 0 3 99 99 99 encode 0\par
}
 Now we set the input and query it for the '+' char: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input_uint 0 1 99\par
query 0\par
}
 Then to see the result we use gather_Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Output_uint 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7 10 2 3 99 11 11\par
 8 20 2 3 99 11 99\par
 9 20 2 3 99 99 11\par
10 30 2 3 99 99 99\par
 5 10 2 3 11 99 11\par
 6 20 2 3 11 99 99\par
 4 10 2 3 11 11 99\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Treetop_NID\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Treetop_NID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Treetop_NID (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This takes the current treetop node from the CAN Scaffold (if one exists) and outputs the NID to the output file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Treetop_NID CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct to retrieve the treetop node ID (NID) from. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{This function appends the NID of the treetop to the output file for the given construct.\cell }
{\row }
}
This function is useful when you are encoding multi-sensory constructs. When you encode a raw tier construct (one that deals with raw "sensory" data from outside the neural graph through state tier binding) the treetop is an abstraction of that sensory input. This function allows you to get a handle on that abstraction, a reference to that super-symbol.\par
With this super-symbol or higher level abstraction you can feed it into higher tier constructs to build abstractions of abstractions with multiple lower constructs feeding their treetops into a higher tier construct.\par
Example Usage:\par
In this example we will encode two lower tier constructs to get the NIDs, and just for fun we'll feed them into an MSC to get a single treetop node that represents the super-symbol of all the input encoded into a single retrievable trace.\par
First we create 3 networks, our old fren ExaCon, the somewhat familiar ConExa, and the rarely seen ExaMSC. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
register_Assembly Many_To_One ConExa\par
register_Assembly Many_To_One ExaMSC\par
}
 Now we'll encode the two raw constructs ExaCon and ConExa. ExaCon will be temperature, and ConExa will be oxygen: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 Temperature: 5 /end/\par
encode 0\par
set_Input 1 Oxygen: 3 /end/\par
encode 1\par
}
 Output:\par
The first construct ExaCon, temperature: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 2\par
  [5]  <> 5\par
  [6]  <> 6\par
  [7]  <> 7\par
  [8]  <> 8\par
  [9]  <> 5\par
  [10]  <> 2\par
  [11]  <> 9\par
  [12]  <> 10\par
  [13]  <> 11\par
<- Tier[1] ->\par
  [0]  <> 12\par
}
\par
The second construct ConExa, oxygen: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 13\par
  [1]  <> 14\par
  [2]  <> 15\par
  [3]  <> 16\par
  [4]  <> 17\par
  [5]  <> 18\par
  [6]  <> 19\par
  [7]  <> 20\par
  [8]  <> 21\par
<- Tier[1] ->\par
  [0]  <> 22\par
}
 Then we use this function to get both treetops, and to output the raw node for each so we can see the full data to confirm this function works: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Treetop_NID 0\par
output_Newline 0\par
gather_Treetop_Node 0\par
\par
gather_Treetop_NID 1\par
output_Newline 1\par
gather_Treetop_Node 1\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12\par
12 2 14 1 2 3 4 2 5 6 7 8 5 2 9 10 11 0 14 Temperature: 5\par
}
 Contents of "./Output/ConExa.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22\par
22 2 9 13 14 15 16 17 18 19 20 21 0 9 Oxygen: 3\par
}
 Now that we have these \{ 12, 22 \} we can move onto the multi-sensory construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input_uint 2 2 12 22\par
encode 2\par
output_Scaffold 2\par
}
 Gather the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Treetop_NID 2\par
output_Newline 2\par
gather_Treetop_Node_uint 2\par
}
 Contents of "./Output/ExaMSC.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25\par
25 2 2 23 24 0 2 12 22\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Treetop_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Treetop_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Treetop_Node (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Treetop_Node CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct you want the treetop from. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b c_Node}} \cell }{Treetop[] The treetop is output to the output file associated with the given construct.\cell }
{\row }
}
This returns the treetop node for a given construct and outputs it to the output file for the given construct.\par
This treetop is the top node in the current CAN Scaffold. So if you encode "yargi blargi" then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents "yargi blargi".\par
Example Usage:\par
First we encode a string into a Many_To_One: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 Pull Your Circuit Breaker /end/\par
encode 0\par
}
 Then we can get the treetop: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Treetop_Node 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 2 25 1 2 3 3 4 5 6 2 7 4 8 9 7 10 2 9 11 4 12 7 13 14 15 13 7 0 25 Pull Your Circuit Breaker\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v gather_Treetop_Node_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:gather_Treetop_Node_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::gather_Treetop_Node_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the treetop node for a given construct and puts it in the output file for that construct as a raw node, the output pattern will be uint64_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gather_Treetop_Node_uint CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct you want the treetop from. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b c_Node}} \cell }{Treetop[] The treetop is output to the output file associated with the given construct.\cell }
{\row }
}
This returns the treetop node for a given construct and outputs it to the output file for the given construct.\par
This treetop is the top node in the current CAN Scaffold. So if you encode \{ 111, 222, 333 \} then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents \{ 111, 222, 333 \}.\par
Example Usage:\par
First we encode a string into a Many_To_One: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 3 111 222 333\par
encode 0\par
}
 Then we can get the treetop: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Treetop_Node_uint 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4 2 3 1 2 3 0 3 111 222 333 \par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v get_State_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:get_State_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::get_State_Node (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks to see if a node in the given assembly is bound to the given state, if not the node is created & the NID returned, if found the NID is returned. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get_State_Node CONSTRUCT_ID STATE {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to search. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The state of the input, the current quanta, or element, of information being encoded. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The node that represents the state passed to this function. Passes the NID back whether found or newly minted.\cell }
{\row }
}
Describe behavior and side-effects. What it basically does and if it touches any globals.\par
Example Usage:\par
Here we have a state that hasn't been encoded yet, this '999'. We run 'get_State_Node 2 999' which returns the NID of the newly minted and state bound node now stored and registered with construct 2's state fractal tree. In this example the NID of the new node is 150. We see this NID in the return file. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid does_State_Node_Exist 2 999\par
}
 Output:\par
Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 150\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This assumes the [CONSTRUCT_ID] is valid \par}
}}
{\xe \v get_Treetop_NID\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:get_Treetop_NID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::get_Treetop_NID (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the treetop node for a given construct and puts it in the output file for that construct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get_Treetop CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct you want the treetop from. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{Treetop[] The treetop is output to the return.ssv file.\cell }
{\row }
}
This returns the treetop node for a given construct and outputs it to the RETURN_FILE. If you instead want it to output to the construct output then you use gather_Output_Node instead of this function.\par
This treetop is the top node in the current CAN Scaffold. So if you encode "yargi blargi" then this treetop node in a Many_To_One construct would be on tier [1] of the CAN Scaffold at index [0] that represents "yargi blargi".\par
Example Usage:\par
First we encode a string into a Many_To_One: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 Pull Your Circuit Breaker /end/\par
encode 0\par
}
 Then we can get output the scaffold so you can see it, and then get the treetop: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Scaffold 0\par
get_Treetop 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 3\par
  [4]  <> 4\par
  [5]  <> 5\par
  [6]  <> 6\par
  [7]  <> 2\par
  [8]  <> 7\par
  [9]  <> 4\par
  [10]  <> 8\par
  [11]  <> 9\par
  [12]  <> 7\par
  [13]  <> 10\par
  [14]  <> 2\par
  [15]  <> 9\par
  [16]  <> 11\par
  [17]  <> 4\par
  [18]  <> 12\par
  [19]  <> 7\par
  [20]  <> 13\par
  [21]  <> 14\par
  [22]  <> 15\par
  [23]  <> 13\par
  [24]  <> 7\par
<- Tier[1] ->\par
  [0]  <> 16\par
}
 Contents of "./Output/returned.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This function is for prototyping for those planning on converting to C++ data handling logic rather than using output.ssv. \par}
}}
{\xe \v get_Upper_Tier_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:get_Upper_Tier_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::get_Upper_Tier_Node (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets an upper tier node based on the given legs, will create it if not found. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get_Upper_Tier_Node NODE_COUNT NODES[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{NODE_COUNT The number of nodes to use in the check for an upper tier node symbol. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NODES[] The array of NIDs to look for. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The node that represents the symbol containing the lower nodes passed to this function. Passes the NID back whether found or newly minted.\cell }
{\row }
}
This function uses 'does_Upper_Tier_Node_Exist' to find if the node exists or not. If the node is not found then this function creates the node, assigns the connections, and passes the prepared NID back.\par
Example Usage:\par
We will use the example containing a set of nodes \{ 5 6 7 \}, in our example node 75 matches this configuration. We output it manually to show the node data proving this and we show the returned NID in the returned data file. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Raw_Node 75\par
get_Upper_Tier_Node 3 5 6 7\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 75 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 5 [1] 6 [2] 7 --- Axon_Hillock_Count: 0\par
}
 Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If you get a crash when calling this then it is likely one or more of your submitted NIDs are not valid. \par}
}}
{\xe \v load_Input\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:load_Input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::load_Input (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads the input file associated with the given construct into the input array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
load_Input CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{This is the construct for whom the input will be loaded. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Be warned, this function treats the entire file as one input, it ignored newlines. Iterating through it loads each whitespace separated token into a string, "tmp_Full = tmp_Full + ' ' + tmp_Current_Token"\par
Example Usage:\par
To start with we register our construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
}
 We create the input file for it and put our sample data into the file:\par
Contents of "./Input/ExaCon.Input.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid yo ho ho\par
and\par
a\par
bottle\par
of\par
rum\par
}
 Now using load_Input we can load this into the construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid load_Input 0\par
}
 And we can see the results: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid | load_Input |\par
 - [ 0 ]: yo\par
 - [ 1 ]: ho\par
 - [ 2 ]: ho\par
 - [ 3 ]: and\par
 - [ 4 ]: a\par
 - [ 5 ]: bottle\par
 - [ 6 ]: of\par
 - [ 7 ]: rum\par
}
 You can see how it treats the tokens with different kinds of whitespace, newlines and spaces treated the same. (Looking at "yo ho ho")\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v load_Input_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:load_Input_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::load_Input_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads the input file associated with the given construct into the input array as uint. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
load_Input_uint CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{This is the construct for whom the input will be loaded. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
The first number in the input file should be the count of elements. The function will create a temporary array to hold these and load them.\par
Example Usage:\par
To start with we register our construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
}
 We create the input file for it and put our sample data into the file:\par
Contents of "./Input/ExaCon.Input.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4 10 20\par
20 40\par
}
 Now using load_Input we can load this into the construct: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid load_Input_uint 0\par
}
 And we can see the results: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid | load_Input_uint |\par
 Count: 4\par
 - [ 0 ]: 10\par
 - [ 1 ]: 20\par
 - [ 2 ]: 20\par
 - [ 3 ]: 40\par
}
 You can see how it treats the tokens with different kinds of whitespace, newlines and spaces treated the same. (Looking at "yo ho ho")\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v new_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:new_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::new_Node (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new node in the shared node network. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
new_Node {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{This returns the NID of the newly created nodes.\cell }
{\row }
}
When the node is created it is stored in a linked list. This new node is then added to the node registration fractal tree. This allows for storing the node network in a linked list for when we want to iterate over them, and for searching with a predictable search time for nodes in the linked list no matter its length.\par
Example Usage:\par
In this example we register a new node using new_Node and then check the output file for the NID of the newly created node. Currently the node network is at 249 nodes meaning the new one will have a NID of 250. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid new_Node\par
}
 Output:\par
Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 250\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v new_State_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:new_State_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t c_Construct_Text_Server::new_State_Node (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new node, binds it to a state, sets the type to 0 or 3 depending, and adds the node to the state tree with the state registered. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
new_State_Node CONSTRUCT_ID STATE {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{CONSTRUCT_ID This is the assembly to use when creating the state node. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{STATE The state to bind to the node. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{Returns the NID of the newly minted state node.\cell }
{\row }
}
By registering the node with the fractal state tree we can have predictable search times no matter how big the tree gets.\par
Example Usage:\par
In this example we have 3 constructs registered and we use 'new_State_Node 2 121' to create a state node for construct [2], in this example construct [2] currently has 28 nodes registered making the return value 29 as that is the new nodes NID. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid new_State_Node 2 121\par
}
 Output:\par
Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Assumes the construct is already registered with a valid index. \par}
}}
{\xe \v output_Assemblies\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Assemblies}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::output_Assemblies (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the constructs currently registered. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Assemblies {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Outputs the list of currently registered constructs to the console.\par
Example Usage:\par
We'll register some constructs, then output them: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One First_Conman\par
register_Assembly Many_To_One Second_Conman\par
register_Assembly Many_To_One Third_Conman\par
output_Assemblies\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __COMMAND__| output_assemblies |\par
[0]: First_Conman\par
[1]: Second_Conman\par
[2]: Third_Conman\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_BP\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_BP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_BP (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterates through every node and outputs their {\b bp_O()} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_BP {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This is for outputting the entire network to the console.\par
Example Usage:\par
in this example we have a single trace encoded which is composed of 5 integers, \{ 11, 22, 33, 44, 55 \}. This results in 6 nodes which we will see in the output. 5 state tier nodes, one for each input integer, and one higher tier node. Remember, NID 0 exists, but it is the NULL node not to be used. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_BP\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <=- 0 [0] -=>\par
<=- 1 [11] -=>\par
<=- 2 [22] -=>\par
<=- 3 [33] -=>\par
<=- 4 [44] -=>\par
<=- 5 [55] -=>\par
<=- 6 * [11]  [22]  [33]  [44]  [55] -=>\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_BP_NID\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_BP_NID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_BP_NID (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finds given NID and outputs the {\b bp_O()}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_BP_NID NID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID (NID) of the node being manipulated. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Uses the fractal NID tree to search the node linked list for the given NID. Once found it uses the ->{\b bp_O()} to output the pattern the node represents.\par
Example Usage:\par
Here NID 55 represents the compound symbol '32 64 128 64 32'. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid bp_NID 5\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <=- 55 * [32]  [64]  [128]  [64]  [32] -=>\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Input\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Input (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the input of the given construct to the console. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Input CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's input we shall output. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Pretty simple, outputs the input array of the given construct to the console.\par
Example Usage:\par
Let us create a construct, then set the input, then output the input which shall be 'kaput'. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 kaput /end/\par
output_Input 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==-\par
[0] > k <\par
[1] > a <\par
[2] > p <\par
[3] > u <\par
[4] > t <\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Input_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Input_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Input_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the input of the given construct to the console, but as uint. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Input_uint CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's input we shall output. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Outputs the input array of the given construct to the console with the values displayed as uint64_t.\par
Example Usage:\par
Let us create a construct, then set the input, then output the input: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 3 8999 9000 9001\par
output_Input_uint 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==--\par
[0] > 8999 <\par
[1] > 9000 <\par
[2] > 9001 <\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Newline\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Newline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::output_Newline (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You give it a construct ID and it outputs a newline to the output file associated with that construct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Newline CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct to whom the newline shall go, to the coffers of their output file the newline appends. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, it outputs \par
 to the output file.\cell }
{\row }
}
Used for formatting output when testing, playing, prototyping, experimenting, or scripting.\par
Example Usage:\par
For an example we will register an assembly, encode several items, then output them one by one with two newlines betwixt them: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 Night Gaunt /end/\par
encode 0\par
gather_Treetop_Node 0\par
\par
output_Newline 0\par
set_Input 0 Wubbajack /end/\par
encode 0\par
gather_Treetop_Node 0\par
\par
output_Newline 0\par
set_Input 0 Ghoul /end/\par
encode 0\par
gather_Treetop_Node 0\par
}
 Output:\par
Contents of the file "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11 2 11 1 2 3 4 5 6 7 8 9 10 5 0 11 Night Gaunt\par
17 2 9 12 9 13 13 8 14 8 15 16 0 9 Wubbajack\par
20 2 5 7 4 18 9 19 0 5 Ghoul\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Node\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::output_Node (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs a given node as defined by the passed NID to the console. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
function_name params {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{\cell }
{\row }
}
retval None This function doesn't return any values.\par
The node is output to the console for the user to read, the symbol is backpropagated out and presented as both uint64_t and char().\par
Example Usage:\par
First we'll register a construct, then set & encode a string, then output the scaffold so we can see the nodes: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 T-800 /end/\par
encode 0\par
output_Scaffold 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 4\par
<- Tier[1] ->\par
  [0]  <> 5\par
}
 Looking at this we can see that the treetop node (Tier[1] Index[0] in this Many_To_One) is NID #5, so we can output node number 5: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node 5\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  | output_Node | 5 |\par
NID: 5 Type: 2 Symbol: <=- 5 * [ T, 84 ]  [ -, 45 ]  [ 8, 56 ]  [ 0, 48 ]  [ 0, 48 ]  -=>\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Node_Char\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Node_Char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Node_Char (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Casts the node address to char() and outputs it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Node_Char NID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID of the node who's NID is being output as a char. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This function may seem pointless at first, but it is used in conjunction with the CAN scaffolds and others to output a compact visualizatin of a series of nodes by their NID. Though there is overlap when typecasting NIDs the variation is enough that the human can see differences in different permutations of encoded input.\par
Example Usage:\par
In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 0 - 175 have already been created so our first node will be NID 176. The node bound to state 128 already exists with a NID 65. This results in 3 nodes created, 2 state tier nodes \{ 176, 177 \} and 1 upper tier treetop node \{ 178 \}. We will output all the nodes using this function to show a small example of the potential output used to convey variance int he NID structure at a glance. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Char 176\par
output_Node_Char 65\par
output_Node_Char 177\par
output_Node_Char 178\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \'E2\'96\'91A\'E2\'96\'92\'E2\'96\'93\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash. \par}
}}
{\xe \v output_Node_Network\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Node_Network}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::output_Node_Network (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This iterates through every node outputting them to the console. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Node_Network\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This function iterates over every node in the network and outputs the to the console for you to view. This is not the patterns represented by the nodes, but the node structures themselves.\par
Example Usage:\par
First we register the construct, then we encode a series of binary values just because: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 000 /end/ encode 0\par
set_Input 0 001 /end/ encode 0\par
set_Input 0 010 /end/ encode 0\par
set_Input 0 011 /end/ encode 0\par
set_Input 0 100 /end/ encode 0\par
set_Input 0 101 /end/ encode 0\par
set_Input 0 110 /end/ encode 0\par
set_Input 0 111 /end/ encode 0\par
}
 Now output the network: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Network\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid | output_Node_Network |\par
 Node_ID (NID): 0  RC: 1 Type: 0 State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 1  RC: 13 Type: 0 State \{ 48 \} --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] <4>:  [0] 2 [1] 4 [2] 5 [3] 6 Axons[1] <4>:  [0] 2 [1] 4 [2] 7 [3] 8 Axons[2] <4>:  [0] 2 [1] 5 [2] 7 [3] 9\par
 Node_ID (NID): 2  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 1 [1] 1 [2] 1 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 3  RC: 13 Type: 0 State \{ 49 \} --- Dendrites:  --- Axon_Hillock_Count: 3 Axons[0] <4>:  [0] 7 [1] 8 [2] 9 [3] 10 Axons[1] <4>:  [0] 5 [1] 6 [2] 9 [3] 10 Axons[2] <4>:  [0] 4 [1] 6 [2] 8 [3] 10\par
 Node_ID (NID): 4  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 1 [1] 1 [2] 3 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 5  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 1 [1] 3 [2] 1 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 6  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 1 [1] 3 [2] 3 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 7  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 3 [1] 1 [2] 1 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 8  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 3 [1] 1 [2] 3 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 9  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 3 [1] 3 [2] 1 --- Axon_Hillock_Count: 0\par
 Node_ID (NID): 10  RC: 2 Type: 2 State \{ 0 \} --- Dendrites:  [0] 3 [1] 3 [2] 3 --- Axon_Hillock_Count: 0\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Node_Raw\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Node_Raw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Node_Raw (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the ugly raw info dump for the node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Node_Raw NID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID of the node who's information symbol is being output. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This is pretty basic, outputs the node.\par
Here is the breakdown of the components output:\par
-Entire output node raw dump: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID): %NID% RC: %RC% Type: %Type% State \{ %State% \} --- Dendrites: [%Dendrite_ID%] %Dendrites[%Dendrite_ID%]% --- Axon_Hillock_Count: %Axon_Hillock_Count% Axons[%Axon_Hillock_ID%] <%Axon_Count_For_Hillock%>: [%Axon_ID%] Axons[%Axon_Hillock_ID%][%Axon_ID%]\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The NID is the node ID within the network of nodes.\par
Node_ID (NID): NID%\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The RC is the reinforcement counter, the reinforcement value, the neuroplasticity analogue, the post-synaptic-cleft density approximation.\par
RC: RC%\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The type of node, see set_Node_Type for more information.\par
Type: Type%\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The pattern of input quanta that the node represents, the hierarchically encoded sensory trace, the abstract symbol built from the recomposition of the input states into the complete encoded pattern.\par
State \{ State% \}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The "lower" connections to nodes that form sub-symbols of the current node's symbol.\par
Dendrites: [Dendrite_ID%] Dendrites[Dendrite_ID%]%\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The number of axon hillocks on this node, the number of axonal hillocks is determined by the position of upper tier connections. If an upper tier axonic connection makes contact with dendritic index 4 then this lower node will have 5 axon hillocks so that number 4 can hold this connection preserving the information of the upper tier connection index without having to query the other node to get the respective position. This is used during the function which check for upper tier nodes and during some charging methodologies.\par
Axon_Hillock_Count: Axon_Hillock_Count%\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the node contains axonic connections they will be iteratively printed here. For each hillock the number of axons on it will be printed followed by the individual axonic connections.\par
Axons[Axon_Hillock_ID%] <Axon_Count_For_Hillock%>: [Axon_ID%] Axons[Axon_Hillock_ID%][Axon_ID%]\par}
Example Usage:\par
In this example we have encoded the pattern "64 128 256" into a many to one construct. In this example the nodes 1-9 have already been created so our first node will be NID 10. This results in 4 nodes created, 3 state tier nodes \{ 10, 11, 12 \} and 1 upper tier treetop node \{ 13 \}. We will output all the nodes using this function to show state, treetop, dendritically connected, and axonically connected nodes.. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 10\par
output_Node_Raw 11\par
output_Node_Raw 12\par
output_Node_Raw 13\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 10 RC: 1 Type: 0  State \{ 64 \} --- Dendrites:  --- Axon_Hillock_Count: 1  Axons[0] <1>: 13\par
Node_ID (NID) 11 RC: 1 Type: 0  State \{ 128 \} --- Dendrites:  --- Axon_Hillock_Count: 2  Axons[0] <0>:  Axons[1] <1>: 13\par
Node_ID (NID) 12 RC: 1 Type: 0  State \{ 256 \} --- Dendrites:  --- Axon_Hillock_Count: 3  Axons[0] <0>:  Axons[1] <0>:  Axons[2] <1>: 13\par
Node_ID (NID) 13 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 10 [1] 11 [2] 12 --- Axon_Hillock_Count: 0\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash. \par}
}}
{\xe \v output_Output\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Output}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Output (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The output trace set is output. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Output CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{This is the construct which has the output trace set output to the console. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Takes the current output traces from a given construct and outputs them to the console. So after a query this allows you to output the results.\par
Example Usage:\par
Here we'll register a construct, encode two input sets, query it, and then finally show the useage of this function.\par
Register, encode: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 01234 /end/\par
encode 0\par
set_Input 0 56789 /end/\par
encode 0\par
}
 Set input, query, then show this functions TRUE POWER: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 45 /end/\par
query 0\par
output_Output 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   Output_Traces [2]   ==--\par
 Trace[0]:  Pat_Depth: 5\par
--  Charge: 10 RC: 2 Treetop: 6 Pattern:  0 1 2 3 4\par
 Trace[1]:  Pat_Depth: 5\par
--  Charge: 10 RC: 2 Treetop: 12 Pattern:  5 6 7 8 9\par
  --==   /Output_Traces   ==--\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Output_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Output_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Output_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The output trace set is output as uint64_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Output_uint CONSTRUCT_ID\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{This is the construct which has the output trace set output to the console with the values displayed as uint64_t. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Takes the current output traces from a given construct and outputs them to the console. So after a query this allows you to output the results. The results are displayed as uint64_t and not string.\par
Example Usage:\par
Here we'll register a construct, encode two uint64_t input arrays, query it, and then finally show the useage of this function.\par
Register, encode: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 5 0 1 2 3 4\par
encode 0\par
set_Input_uint 0 5 5 6 7 8 9\par
encode 0\par
}
 Set input, query, then show this functions TRUE POWER: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input_uint 0 3 4 5 6\par
query 0\par
output_Output_uint 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   Output_Traces [2]   ==--\par
 Trace[0]:  Pat_Depth: 5\par
--  Charge: 10 RC: 2 Treetop: 6 Pattern:  0 1 2 3 4\par
 Trace[1]:  Pat_Depth: 5\par
--  Charge: 20 RC: 2 Treetop: 12 Pattern:  5 6 7 8 9 <- Notice this one has a charge of 20, otherwise it looks the same as the string query.\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Scaffold\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Scaffold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Scaffold (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the scaffold as node IDs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Scaffold CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The ID of the construct who's scaffold we'll be outputting. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
When a trace, or input pattern, is encoded into the network we use a current active node scaffold (CAN) to do so. This CAN Scaffold can be output for human analysis, this splays the symbol open to your gaze, all sub-symbols and bound states there to play with.\par
Example Usage:\par
We'll encode a string into a many to one and output the scaffold: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 supersymbol\par
encode 0\par
output_Scaffold 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 5\par
  [5]  <> 1\par
  [6]  <> 6\par
  [7]  <> 7\par
  [8]  <> 8\par
  [9]  <> 9\par
  [10]  <> 10\par
<- Tier[1] ->\par
  [0]  <> 11\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v output_Scaffold_Char\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:output_Scaffold_Char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::output_Scaffold_Char (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outputs the scaffold as characters typecase from the ID. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output_Scaffold_Char CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The ID of the construct who's scaffold we'll be outputting. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
When a trace, or input pattern, is encoded into the network we use a current active node scaffold (CAN) to do so. This CAN Scaffold can be output for human analysis, each node represented as a 'random' character, making it so that at a glance you can tell variance in node structures, and changes if watching a life network.\par
Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.\par
Example Usage:\par
We'll encode a string into a many to one and output the scaffold: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 supersymbol\par
encode 0\par
output_Scaffold_Char 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  - [ 0 ]: output_Scaffold_Char\par
\par
(0000014828425EC0)\par
\'C3\'89\'CE\'B1\'C3\'87\'C3\'A1@\'C3\'89\'CE\'B1\'C3\'890\'E2\'95\'A8p\par
\'E2\'96\'BA\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v query\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::query (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network with the current input set for the given construct, evaluates the input set and stores the results in the output traces, gathered using 'gather_Output'. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
query CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to search. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, the data resulting from this function is handled through traces.\cell }
{\row }
}
This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN\par
Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs. Does not create new nodes, only finds if they already exist or not, does not "train" only "evaluates".\par
Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.\par
To query a construct you must first have input loaded into it. Once the input is loaded then calling this will query the input pattern for a given construct. The way to use this is to first get input to the construct, then you tell it to evaluate the input, then you can use gather, output, and other functions to access the results.: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Get Input: set_Input | set_Input_uint | load_Input\par
 Do something with the Input: query\par
 Get your Output: gather_X | output_X\par
}
 Example Usage:\par
This example is a Many_To_One, which means all state nodes (Tier[0]) are connected to a single upper tier (Tier[1]) treetop node.\par
You may notice that all the names are lowercase, this is because 'R' and 'r' are different symbols, so making them all lowercase keeps them using the same 'letters'.\par
First we create a construct of the type Many_To_One named ExaCon for Example Construct. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
}
 Then we use set_Input + encode to load several character names into the network and encode them as a base set, see encode for further details. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 randolph carter /end/ encode 0\par
set_Input 0 harley warren /end/ encode 0\par
set_Input 0 herbert west /end/ encode 0\par
set_Input 0 dr. allen halsey /end/ encode 0\par
set_Input 0 erich zann /end/ encode 0\par
set_Input 0 edward norrys /end/ encode 0\par
set_Input 0 king kuranes /end/ encode 0\par
}
 After we have the base character names we can begin searching them. We set the input to the string 'i' to search names that have 'i' in them. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 i\par
}
 To call this function and the correct construct we use 'query 0', this fills the NULLCAN and handles the neural cascades. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid query 0\par
}
 We then use 'output_Scaffold' to view the NULLCAN showing the tiny CAN holding the current queries, 'gather_Output 0' to output the resulting traces to the output file for Construct [0] (default ".\\Output\\CONSTRUCT_NAME.Output.ssv"). {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Scaffold 0\par
gather_Output 0\par
}
 To show different searches we do several searches with a newline in the output between them.\par
Search for 'a': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
set_Input 0 a\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
}
 Search for 'h': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
set_Input 0 h\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
}
 Search for 'e': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
set_Input 0 e\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
}
 Search for 'eai': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
set_Input 0 eai\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
}
 Here is the above code in completion if you want to copy/paste: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 randolph carter /end/ encode 0\par
set_Input 0 harley warren /end/ encode 0\par
set_Input 0 herbert west /end/ encode 0\par
set_Input 0 dr. allen halsey /end/ encode 0\par
set_Input 0 erich zann /end/ encode 0\par
set_Input 0 edward norrys /end/ encode 0\par
set_Input 0 king kuranes /end/ encode 0\par
set_Input 0 i\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
output_Newline 0\par
set_Input 0 a\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
output_Newline 0\par
set_Input 0 h\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
output_Newline 0\par
set_Input 0 e\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
output_Newline 0\par
set_Input 0 eai\par
query 0\par
output_Scaffold 0\par
gather_Output 0\par
}
 Output:\par
CAN Scaffold for the 'i' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __COMMAND__| output_Scaffold CONSTRUCT_ID |\par
 --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 22\par
<- Tier[1] ->\par
  [0] NULL\par
}
 CAN Scaffold for the 'a' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __COMMAND__| output_Scaffold CONSTRUCT_ID |\par
 --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 2\par
<- Tier[1] ->\par
  [0] NULL\par
}
 CAN Scaffold for the 'h' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __COMMAND__| output_Scaffold CONSTRUCT_ID |\par
 --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 8\par
<- Tier[1] ->\par
  [0] NULL\par
}
 CAN Scaffold for the 'e' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __COMMAND__| output_Scaffold CONSTRUCT_ID |\par
 --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 12\par
<- Tier[1] ->\par
  [0] NULL\par
}
 CAN Scaffold for the 'eai' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  __COMMAND__| output_Scaffold CONSTRUCT_ID |\par
  --==   CAN_Scaffold   ==--\par
 <- Tier[0] ->\par
   [0]  <> 12\par
   [1]  <> 2\par
   [2]  <> 22\par
 <- Tier[1] ->\par
   [0] NULL\par
}
 Contents of ".\\Output\\ExaCon.Output.ssv"\par
Results of 'i' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 10 2 12 king kuranes\par
24 10 2 10 erich zann\par
}
 Results of 'a' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13 20 2 15 randolph carter\par
16 20 2 13 harley warren\par
25 10 2 13 edward norrys\par
21 20 2 16 dr. allen halsey\par
24 10 2 10 erich zann\par
29 10 2 12 king kuranes\par
}
 Results of 'h' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16 10 2 13 harley warren\par
19 10 2 12 herbert west\par
24 10 2 10 erich zann\par
13 10 2 15 randolph carter\par
21 10 2 16 dr. allen halsey\par
}
 Results of 'e' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 10 2 10 erich zann\par
25 10 2 13 edward norrys\par
19 30 2 12 herbert west\par
16 20 2 13 harley warren\par
21 20 2 16 dr. allen halsey\par
29 10 2 12 king kuranes\par
13 10 2 15 randolph carter\par
}
 Results of 'eai' search {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 30 2 10 erich zann\par
25 20 2 13 edward norrys\par
19 30 2 12 herbert west\par
16 40 2 13 harley warren <- the charge is 40 because it has 2 'a' characters, and 2 'e' characters.\par
21 40 2 16 dr. allen halsey\par
29 30 2 12 king kuranes\par
13 30 2 15 randolph carter\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. \par}
}}
{\xe \v query_Given_Index\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:query_Given_Index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::query_Given_Index (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network with the current input set, however, every input node is charged using the given index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
query_Given_Index CONSTRUCT_ID INDEX {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to search. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{INDEX This is the index to use when charging, if you are searching for patterns that have any of the input nodes in index [2] then you would use this parameter to specify leg [2]. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, the data resulting from this function is handled through traces.\cell }
{\row }
}
If INDEX is [3] then all nodes in the input set will be charging using axon hillock [3].\par
This is used when you have multiple inputs to the same index that you want to check. For example, maybe you want to check for traces grouped around one end the temperature scale rather than a single value.\par
Example Usage:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 1.\par}
Following up on the idea of checking a range of thermometer readings from the description we have this example. If your temperature gauge registers 1 -5 then in this example you might want to look up the super-symbols, the encoded traces, the upper tier nodes, that have 4 & 5 encoded onto the index corresponding to temperature on your greenhouse input array.\par
Here is an example input set from our example greenhouse sensors, oxygen, carbon dioxide, temperature, humidity, etc.\par
Each of these is an row in your input list:\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab Oxygen\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Carbon Dioxide\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab Temperature <- We'll be searching this index for the temperature ranges using this function query_Given_Index\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
4.\tab Humidity\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
5.\tab Etc\par}
They are read in as a string of values 1 - 5, "O2 Co2 Temp Humidity Etc", and example with values may be "2 4 2 1 3" to give an idea what an input list might look like to the neural network.\par
So you encode each list, for this example we'll say your greenhouse controller automatically logs these input lists. We'll use some of this log data for an example dataset: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon <- Don't forget to register the construct.\par
set_Input 0 3 2 4 1 5 /end/ encode 0\par
set_Input 0 2 3 3 2 4 /end/ encode 0\par
set_Input 0 4 1 2 5 3 /end/ encode 0\par
set_Input 0 5 4 3 2 1 /end/ encode 0\par
set_Input 0 1 5 2 4 3 /end/ encode 0\par
set_Input 0 3 2 1 4 5 /end/ encode 0\par
set_Input 0 4 3 2 5 1 /end/ encode 0\par
set_Input 0 1 4 3 2 5 /end/ encode 0\par
set_Input 0 2 3 4 1 5 /end/ encode 0\par
set_Input 0 5 1 2 3 4 /end/ encode 0\par
set_Input 0 3 4 2 1 5 /end/ encode 0\par
set_Input 0 2 1 3 5 3 /end/ encode 0\par
set_Input 0 4 5 1 2 3 /end/ encode 0\par
set_Input 0 1 2 3 4 5 /end/ encode 0\par
set_Input 0 3 2 5 1 4 /end/ encode 0\par
set_Input 0 2 3 4 5 1 /end/ encode 0\par
set_Input 0 4 5 2 3 1 /end/ encode 0\par
set_Input 0 5 1 3 2 4 /end/ encode 0\par
set_Input 0 1 4 5 3 2 /end/ encode 0\par
set_Input 0 3 2 4 5 1 /end/ encode 0\par
set_Input 0 2 1 5 3 3 /end/ encode 0\par
set_Input 0 4 3 1 2 5 /end/ encode 0\par
set_Input 0 5 4 2 1 3 /end/ encode 0\par
set_Input 0 1 5 4 3 2 /end/ encode 0\par
set_Input 0 3 2 1 5 4 /end/ encode 0\par
}
 Now we need to find the temperatures, the \{ 4, 5 \}. We do this by setting the input appropriately.\par
To formulate the input strings we create an input string from out input indexes with no whitespace between them, this is because each one is the smallest unit of information so we don't risk losing any by placing characters next to each other. Being single digit values 1-5 we can do that with this string based input: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 45\par
}
 This 45 is represented as a string internally so each digit is a separate integer value even though a human reads it as forty-five.\par
Then formulate it into the set_Input string for the construct 0 (ExaCon as defined using 'register_Assembly Many_To_One ExaCon' above) we are working with: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 45 /end/\par
}
 Finally we query the network with 'query_Given_Index' to search the network for all traces containing one of \{ 4, 5 \} on leg 4, which corresponds to 4. Temperature, so index/leg/dendrite/axon_hillock #4. You might wonder why we are setting it to index 4 and not 2 like one would expect. This is because we have to count each whitespace as an index in the input string, "1 2 3 4 5" equals '1' + ' ' + '2' + ' ' + '3' + ' ' + '4' + ' ' + '5'.\par
Here is the query string: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid query_Given_Index 0 4\par
}
 Then use 'gather_Output' to get the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Output 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7 10 2 9 3 2 4 1 5\par
15 10 2 9 2 3 4 1 5\par
22 10 2 9 2 3 4 5 1\par
26 10 2 9 3 2 4 5 1\par
30 10 2 9 1 5 4 3 2\par
21 10 2 9 3 2 5 1 4\par
25 10 2 9 1 4 5 3 2\par
27 10 2 9 2 1 5 3 3\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 2.\par}
This example builds on the above one to search for temperatures matching 1, 2, & 3. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 123 /end/\par
}
 Then the query and gather: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid query_Given_Index 0 4\par
gather_Output 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 10 2 9 3 2 1 4 5\par
19 10 2 9 4 5 1 2 3\par
28 10 2 9 4 3 1 2 5\par
31 10 2 9 3 2 1 5 4\par
 9 10 2 9 4 1 2 5 3\par
11 10 2 9 1 5 2 4 3\par
13 10 2 9 4 3 2 5 1\par
16 10 2 9 5 1 2 3 4\par
17 10 2 9 3 4 2 1 5\par
23 10 2 9 4 5 2 3 1\par
29 10 2 9 5 4 2 1 3\par
 8 10 2 9 2 3 3 2 4\par
10 10 2 9 5 4 3 2 1\par
14 10 2 9 1 4 3 2 5\par
18 10 2 9 2 1 3 5 3\par
20 10 2 9 1 2 3 4 5\par
24 10 2 9 5 1 3 2 4\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 3.\par}
In this example we basically redo the same environmental search again, but this time we'll use the uint interface.\par
Start with encoding, but with uint and the syntax that requires (set_Input_uint CONSTRUCT_ID COUNT INPUT[]): {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon <- Don't forget to register the construct.\par
set_Input_uint 0 5 3 2 4 1 5 encode 0\par
set_Input_uint 0 5 2 3 3 2 4 encode 0\par
set_Input_uint 0 5 4 1 2 5 3 encode 0\par
set_Input_uint 0 5 5 4 3 2 1 encode 0\par
set_Input_uint 0 5 1 5 2 4 3 encode 0\par
set_Input_uint 0 5 3 2 1 4 5 encode 0\par
set_Input_uint 0 5 4 3 2 5 1 encode 0\par
set_Input_uint 0 5 1 4 3 2 5 encode 0\par
set_Input_uint 0 5 2 3 4 1 5 encode 0\par
set_Input_uint 0 5 5 1 2 3 4 encode 0\par
set_Input_uint 0 5 3 4 2 1 5 encode 0\par
set_Input_uint 0 5 2 1 3 5 3 encode 0\par
set_Input_uint 0 5 4 5 1 2 3 encode 0\par
set_Input_uint 0 5 1 2 3 4 5 encode 0\par
set_Input_uint 0 5 3 2 5 1 4 encode 0\par
set_Input_uint 0 5 2 3 4 5 1 encode 0\par
set_Input_uint 0 5 4 5 2 3 1 encode 0\par
set_Input_uint 0 5 5 1 3 2 4 encode 0\par
set_Input_uint 0 5 1 4 5 3 2 encode 0\par
set_Input_uint 0 5 3 2 4 5 1 encode 0\par
set_Input_uint 0 5 2 1 5 3 3 encode 0\par
set_Input_uint 0 5 4 3 1 2 5 encode 0\par
set_Input_uint 0 5 5 4 2 1 3 encode 0\par
set_Input_uint 0 5 1 5 4 3 2 encode 0\par
set_Input_uint 0 5 3 2 1 5 4 encode 0\par
}
 For the input search string we use the uint format of stating the number of elements and our inputs, so 'set_Input 45 /end/' becomes 'set_Input_uint 2 4 5': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 2 4 5\par
}
 The different input methods result in different input indexes for the values, meaning our query is different. The uint version gives us the intuitive index of [2] for our temperature because each number is a sequential input, rather than input - space - input: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid query_Given_Index 0 2\par
}
 We gather using the uint interface so it outputs the integers to the textfile properly: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Output_uint 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6 10 2 5 3 2 4 1 5\par
14 10 2 5 2 3 4 1 5\par
21 10 2 5 2 3 4 5 1\par
25 10 2 5 3 2 4 5 1\par
29 10 2 5 1 5 4 3 2\par
20 10 2 5 3 2 5 1 4\par
24 10 2 5 1 4 5 3 2\par
26 10 2 5 2 1 5 3 3\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example Meta-Explanation:\par}
The difference in the node IDs is due to the string interface not encoding the ' ' as the second character. With the input set of 'n n n n n', and each 'n' being a value 1-5, this means the second index in the string will be ' ' and read in as NID[2]. You can compare the patterns between the string version and the uint version to see the data is the same, but the node IDs are off by one:\par
String version 'set_Input': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7 10 2 9 3 2 4 1 5\par
15 10 2 9 2 3 4 1 5\par
22 10 2 9 2 3 4 5 1\par
26 10 2 9 3 2 4 5 1\par
30 10 2 9 1 5 4 3 2\par
21 10 2 9 3 2 5 1 4\par
25 10 2 9 1 4 5 3 2\par
27 10 2 9 2 1 5 3 3\par
}
 uint Version 'set_Input_uint': {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6 10 2 5 3 2 4 1 5\par
14 10 2 5 2 3 4 1 5\par
21 10 2 5 2 3 4 5 1\par
25 10 2 5 3 2 4 5 1\par
29 10 2 5 1 5 4 3 2\par
20 10 2 5 3 2 5 1 4\par
24 10 2 5 1 4 5 3 2\par
26 10 2 5 2 1 5 3 3\par
}
\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. \par}
}}
{\xe \v query_Given_Legs\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:query_Given_Legs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::query_Given_Legs (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network using the current input set of the given assembly, however, an array of legs is passed that signifies whether or not each individual leg is to be charged and every input queried to all axon_hillocks/legs set to fire. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
query_Given_Legs CONSTRUCT_ID LEG_COUNT LGS[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to search. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{LEG_COUNT The number of legs you are passing. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bool} \cell }{LEGS[] The array of legs as boolean values used to determine whether or not to charge nodes connected on that axon_hillock/dendrite_index. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, the data resulting from this function is handled through traces.\cell }
{\row }
}
This function works by taking this set of 'legs' which is a boolean array. It then takes every input of the construct and puts them in a pool of unorganized nodes. It then steps through the boolean array checking whether that step needs to be charged or not. If it needs charged the program then steps through every node in the pool having it charge any axons on the current index, which would be the axon_hillock to the node.\par
So if we are on the second leg in the array then we would step through each node, go check the axon_hillock population count, and if any are found we charge them into the charging buffers.\par
This means you will search for the set of inputs you give, not in order but individually, on the legs you specify.\par
Example Usage:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 1.\par}
In this example we'll use the scenario of running a game server such as Minecraft and needing to track down some hackers. You have the chatlogs which are immense, and you have the user account database. One of your mods remembers that the hacker had an x or z in the first character or four of their name.\par
Using this function we can search for \{ 'X', 'Z', 'x','z' \} on the first 4 characters of each name. So to start we need to encode the database of names by formatting them with the set_Input command: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon /end/ encode 0\par
set_Input 0 PotatoChipCrunch /end/ encode 0\par
set_Input 0 NotARealIdentity /end/ encode 0\par
set_Input 0 BabyDollXOXO /end/ encode 0\par
set_Input 0 SpaceCowboy /end/ encode 0\par
set_Input 0 NinjaGuy22 /end/ encode 0\par
set_Input 0 ElectroExile /end/ encode 0\par
set_Input 0 ArcaneAdventurer /end/ encode 0\par
set_Input 0 Xx_KawaiiAngel_xX /end/ encode 0\par
set_Input 0 FireDragon99 /end/ encode 0\par
set_Input 0 ProUser2024 /end/ encode 0\par
set_Input 0 MySpaceStar /end/ encode 0\par
set_Input 0 RealNameJane /end/ encode 0\par
set_Input 0 xXx_P0t4t0Ch1p_xXx /end/ encode 0\par
set_Input 0 PixelPilgrim /end/ encode 0\par
set_Input 0 d4t4b4s3Qu33n /end/ encode 0\par
set_Input 0 NeonNomad /end/ encode 0\par
set_Input 0 ByteBandit23 /end/ encode 0\par
set_Input 0 DataMinerX /end/ encode 0\par
set_Input 0 -R4v3n-Cl4w- /end/ encode 0\par
set_Input 0 G1tGuD /end/ encode 0\par
set_Input 0 d00d!3_H4xx0r /end/ encode 0\par
set_Input 0 -MysticMoon- /end/ encode 0\par
set_Input 0 Vyrail_Vyxian /end/ encode 0\par
set_Input 0 xX_D@rk_P@ssw0rd_Xx /end/ encode 0\par
set_Input 0 8BitCh4rm3r /end/ encode 0\par
set_Input 0 $p4c3C@d3t /end/ encode 0\par
set_Input 0 W1z4rd0f0s /end/ encode 0\par
set_Input 0 C0mm@nd_L1n3_H3ro /end/ encode 0\par
set_Input 0 ScriptKiddieSupreme /end/ encode 0\par
}
 Now that we have the database to search we can formulate the input query, punch it, and gather the output. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 XZxz /end/\par
query_Given_Legs 0 4 1 1 1 1\par
gather_Output 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 20 2 17 Xx_KawaiiAngel_xX\par
59 30 2 18 xXx_P0t4t0Ch1p_xXx <- Notice how this one had 3 matches to the character pool 'XZxz' in the searched string "xXx_"\par
78 20 2 19 xX_D@rk_P@ssw0rd_Xx\par
60 10 2 12 PixelPilgrim\par
86 10 2 10 W1z4rd0f0s\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 2.\par}
Building on the previous example we have another mod say he saw one of them with a '-' or '_' so we'll expand the search: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 Xx-_ /end/\par
query_Given_Legs 0 4 1 1 1 1\par
output_Newline 0\par
gather_Output 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 30 2 17 Xx_KawaiiAngel_xX\par
59 40 2 18 xXx_P0t4t0Ch1p_xXx <- With the addition of the '_' to the pool of states we find that this "xXx_" now has a match on all characters evaluated. Making the charge 40.\par
78 30 2 19 xX_D@rk_P@ssw0rd_Xx\par
60 10 2 12 PixelPilgrim\par
68 10 2 12 -R4v3n-Cl4w-\par
73 10 2 12 -MysticMoon-\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 3.\par}
If we examine the last example we find the charges are dependent on the number of matches.\par
The query treats the input as a pool of states, rather than an input string. This means that an input with repeated characters or states will evalaute them each time it encounters them.\par
Using this you can "weigh" inputs manually. If we want to weight the '-' character we cna input it multiple times like this: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 Xx-----_ /end/ <- We input the '-' character 5 times.\par
output_Newline 0\par
query_Given_Legs 0 4 1 1 1 1\par
gather_Output 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv": {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 30 2 17 Xx_KawaiiAngel_xX\par
59 40 2 18 xXx_P0t4t0Ch1p_xXx\par
78 30 2 19 xX_D@rk_P@ssw0rd_Xx\par
60 10 2 12 PixelPilgrim\par
68 50 2 12 -R4v3n-Cl4w-\par
73 50 2 12 -MysticMoon-\par
}
 Notice how the last two have charges of 50 vs the previous example where they had 10? With Many_To_One constructs the upper tier node charge is directly proportionate to how many inputs are linked to it (and modified by weights and such but you get the point).\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v query_Spacial\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:query_Spacial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::query_Spacial (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Queries the network with the current input set of the given assembly, but the input index determines what leg is charged. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Meaning if an input at index [3] is charged then only upper tier nodes connected on axon hillock [3] will be charged.\par
query_Spacial CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{CONSTRUCT_ID The construct that encapsulates the state space to search. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values, the data resulting from this function is handled through traces.\cell }
{\row }
}
This query is used when the position of the input relative to the rest matters. Such as in time series searches, or context dependent inputs. The input position determines which connections get charged, this allows for searching nodes based on both the state of the input and the position.\par
This would be useful for things such as time-series prediction, such as stock data or an environmental variable.\par
Example Usage:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 1.\par}
If we were trying to predict temperatures based on the previous temperatures and their fluctuations we might use this function. For example, if we have the current set of temperatures as \{ 50, 55, 60 \} then we would want to know what comes after 60. First though we'll encode a sample history to search through.\par
Here's the sample history: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50 55 60 65 70 70 65 60 55 50\par
}
 We'll do this by encoding 3 temperatures at a time starting at the beginning of the sample history. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 5 3 50 55 60\par
encode 0\par
set_Input_uint 0 5 3 55 60 65\par
encode 0\par
set_Input_uint 0 5 3 60 65 70\par
encode 0\par
set_Input_uint 0 5 3 65 70 70\par
encode 0\par
set_Input_uint 0 5 3 70 70 65\par
encode 0\par
set_Input_uint 0 5 3 70 65 60\par
encode 0\par
set_Input_uint 0 5 3 65 60 55\par
encode 0\par
set_Input_uint 0 5 3 60 55 50\par
encode 0\par
}
 Assuming we encoded 3 temperatures at a time we can create a prediction by setting the first two indexes and searching "forward".\par
So we input the set \{ 55, 60 \} for the first two numbers, then search using this query_Spacial. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input_uint 0 5 2 55 60\par
query_Spacial 0\par
gather_Output_uint 0\par
}
 This means that only patterns with 55 as position [0], and 60 as position [1] will be found. This means those found will have position [2] as the "next" temperature.\par
Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6 20 2 3 55 60 65\par
12 10 2 3 65 60 55\par
}
 We may choose to evaluate them through simple averaging the predicted index (number [2]). Or, alternatively we can weight them based on charge, or both.\par
In this case we can choose the trace with the charge of 20 for our prediction, which is \{ 55, 60, 65 \}\par
A pure average would return 60, so trace selection is an important aspect that goes beyond this simple example. The choice on how to select the traces and filter them can make or break an algorithm.\par
So we take our current input and add the new trace to get a prediction: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55 60 ?? <- Current, the ?? is the index we are searching for, the prediction.\par
55 60 65 <- Found\par
=\par
55 60 65 <- Resulting predicted pattern.\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 2.\par}
For an example that hopefully illistrates the purpose of this function we can walk through searching for a string when you know only a couple characters and their position in the string. Pretend you are sleuthing around online hunting down pedo scum, suddenly discord dings, a message! One of your contacts has a lead, a screenshot from a twitch stream with the kingpin distributor you've been tracking for a while now. He's in this twitch chat, you know that avatar, but there's a problem. The chat animations have caused a cloud of emoji to be floating over the name right as the screenshot was taken. You have only the second and third characters, 'aw', but it is a lead.\par
So we have the clue to work on [ '?' 'a' 'w' '?' ]. We know 'aw' are the second and third character, and the first char is a mystery, as are the rest if they even exist, which is liklely given how short that username would be.\par
Luckily you have a dataset of usernames to look through, we'll train these into the network (obviously we are using a completely insufficient number but we aren't including 10k usernames here), then search the network using our clue.\par
One thing to note, we have these usernames from sites we've scraped, and they have characters not allowed in the name. This means we can take our knowledge of how the network works and use this by inputting characters that cannot appear in usernames like a "greenscreen" in the string. The network during query doesn't create nodes, and if the username network never has these illegal characters encoded to a node then we will sure we are only searching for our intended characters, as no nodes will be in the scaffold for the invalid ones to charge.\par
Code for our initial dataset, notice some names such as Flawless1337 do not have the 'aw' in the right spot: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 SawBones9000 /end/ encode 0\par
set_Input 0 MawOfD00M /end/ encode 0\par
set_Input 0 PawPatriot1337 /end/ encode 0\par
set_Input 0 DawgWalker2000 /end/ encode 0\par
set_Input 0 TawTacticLol /end/ encode 0\par
set_Input 0 RawRampage2001 /end/ encode 0\par
set_Input 0 KawKungFuMaster /end/ encode 0\par
set_Input 0 LawlessLegion1337 /end/ encode 0\par
set_Input 0 Jawbreaker9001 /end/ encode 0\par
set_Input 0 VawVandal2000 /end/ encode 0\par
set_Input 0 AwkwardWarrior /end/ encode 0\par
set_Input 0 Flawless1337 /end/ encode 0\par
set_Input 0 StrawHat2000` /end/ encode 0\par
set_Input 0 ClawClasherLol /end/ encode 0\par
set_Input 0 GnawingGamer2001 /end/ encode 0\par
set_Input 0 HacksawHavoc /end/ encode 0\par
set_Input 0 Jawdropper2000 /end/ encode 0\par
set_Input 0 MawMauler1337 /end/ encode 0\par
set_Input 0 YawYawkerLol /end/ encode 0\par
set_Input 0 ZawZapper2001 /end/ encode 0\par
}
 After the dataset we setup the query and submit it, using the 'illega' character of '_' to create "NULLCAN" nodes, which are positions in the current active node (CAN) scaffold, the datastructure which corrdinates encoding and charging, which don't have a node, therefore are "NULLCAN" nodes. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 _aw\par
query_Spacial 0\par
}
 Gather the output traces into the "./Output/ExaCon.ssv" file. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gather_Output 0\par
}
 Put a newline in the output file so we can tell the difference between the two queries we are doing. Two queries to compare this function to the 'normal' query. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
}
 The input is still set to "_aw" so we don't have to reinput our string. We can instead call 'query 0' because the prep work is all done. We then gather the output as normal with 'gather_Output 0'. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid query 0\par
gather_Output 0\par
}
 Output:\par
Contents of "./Output/ExaCon.Output.ssv":\par
Compare the first set returned with this query_Spacial function here: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11 20 2 12 SawBones9000\par
16 20 2  9 MawOfD00M\par
24 20 2 14 PawPatriot1337\par
30 20 2 14 DawgWalker2000\par
34 20 2 12 TawTacticLol\par
38 20 2 14 RawRampage2001\par
42 20 2 15 KawKungFuMaster\par
43 20 2 17 LawlessLegion1337\par
46 20 2 14 Jawbreaker9001\par
49 20 2 13 VawVandal2000\par
62 10 2 12 HacksawHavoc\par
63 20 2 14 Jawdropper2000\par
64 20 2 13 MawMauler1337\par
66 20 2 12 YawYawkerLol\par
68 20 2 13 ZawZapper2001\par
}
 To this set returned with the nondifferentiated query function: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11 20 2 12 SawBones9000\par
16 20 2  9 MawOfD00M\par
24 30 2 14 PawPatriot1337\par
30 30 2 14 DawgWalker2000\par
34 30 2 12 TawTacticLol\par
38 40 2 14 RawRampage2001 <- Notice the high charge of [40] due to the frequency of 'a' characters with the 'aw' sub-string.\par
42 30 2 15 KawKungFuMaster\par
43 20 2 17 LawlessLegion1337\par
46 30 2 14 Jawbreaker9001\par
49 40 2 13 VawVandal2000\par
62 40 2 12 HacksawHavoc\par
63 20 2 14 Jawdropper2000\par
64 30 2 13 MawMauler1337\par
66 40 2 12 YawYawkerLol\par
68 30 2 13 ZawZapper2001\par
52 20 2 12 Flawless1337\par
58 30 2 14 ClawClasherLol\par
60 30 2 16 GnawingGamer2001\par
55 30 2 13 StrawHat2000`\par
51 40 2 14 AwkwardWarrior\par
}
 Full code for the previous example if you wish to copy/paste: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 SawBones9000 /end/ encode 0\par
set_Input 0 MawOfD00M /end/ encode 0\par
set_Input 0 PawPatriot1337 /end/ encode 0\par
set_Input 0 DawgWalker2000 /end/ encode 0\par
set_Input 0 TawTacticLol /end/ encode 0\par
set_Input 0 RawRampage2001 /end/ encode 0\par
set_Input 0 KawKungFuMaster /end/ encode 0\par
set_Input 0 LawlessLegion1337 /end/ encode 0\par
set_Input 0 Jawbreaker9001 /end/ encode 0\par
set_Input 0 VawVandal2000 /end/ encode 0\par
set_Input 0 AwkwardWarrior /end/ encode 0\par
set_Input 0 Flawless1337 /end/ encode 0\par
set_Input 0 StrawHat2000` /end/ encode 0\par
set_Input 0 ClawClasherLol /end/ encode 0\par
set_Input 0 GnawingGamer2001 /end/ encode 0\par
set_Input 0 HacksawHavoc /end/ encode 0\par
set_Input 0 Jawdropper2000 /end/ encode 0\par
set_Input 0 MawMauler1337 /end/ encode 0\par
set_Input 0 YawYawkerLol /end/ encode 0\par
set_Input 0 ZawZapper2001 /end/ encode 0\par
set_Input 0 _aw\par
query_Spacial 0\par
gather_Output 0\par
output_Newline 0\par
query 0\par
gather_Output 0\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 3.\par}
There may be times when you have a set number of inputs and you want to search for any patterns with that state in that spot. For example, you have your input set from your greenhouse sensors, oxygen, carbon dioxide, temperature, humidity, etc.\par
Each of these is an row in your input list:\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab Oxygen\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Carbon Dioxide\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab Temperature\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
4.\tab Humidity\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
5.\tab Etc\par}
They are read in as a string of values 1 - 5, "O2 Co2 Temp Hum Etc", and example with values may be "2 4 2 1 3" to give an idea what an input list might look like to the neural network.\par
So you encode each list, each snapshot, once every hour or so as your standard datakeeping, in fact it is automated. We'll use these made up snapshots for an example dataset: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon <- Don't forget to register the construct.\par
set_Input 0 3 2 4 1 5 /end/ encode 0\par
set_Input 0 2 3 3 2 4 /end/ encode 0\par
set_Input 0 4 1 2 5 3 /end/ encode 0\par
set_Input 0 5 4 3 2 1 /end/ encode 0\par
set_Input 0 1 5 2 4 3 /end/ encode 0\par
set_Input 0 3 2 1 4 5 /end/ encode 0\par
set_Input 0 4 3 2 5 1 /end/ encode 0\par
set_Input 0 1 4 3 2 5 /end/ encode 0\par
set_Input 0 2 3 4 1 5 /end/ encode 0\par
set_Input 0 5 1 2 3 4 /end/ encode 0\par
set_Input 0 3 4 2 1 5 /end/ encode 0\par
set_Input 0 2 1 3 5 3 /end/ encode 0\par
set_Input 0 4 5 1 2 3 /end/ encode 0\par
set_Input 0 1 2 3 4 5 /end/ encode 0\par
set_Input 0 3 2 5 1 4 /end/ encode 0\par
set_Input 0 2 3 4 5 1 /end/ encode 0\par
set_Input 0 4 5 2 3 1 /end/ encode 0\par
set_Input 0 5 1 3 2 4 /end/ encode 0\par
set_Input 0 1 4 5 3 2 /end/ encode 0\par
set_Input 0 3 2 4 5 1 /end/ encode 0\par
set_Input 0 2 1 5 3 3 /end/ encode 0\par
set_Input 0 4 3 1 2 5 /end/ encode 0\par
set_Input 0 5 4 2 1 3 /end/ encode 0\par
set_Input 0 1 5 4 3 2 /end/ encode 0\par
set_Input 0 3 2 1 5 4 /end/ encode 0\par
}
 Now, your boss comes in one day and says they need some data for a research project. They want every snapshop that has a humity value of 3 (everything here is 1 - 5 in range for simplicity) and a O2 of 2.\par
So you formulate your input string, using the greenscreen illegal character mask again, where the first and last are set to '2' and '3' respectively: "2 _ _ _ 3". There is a major issue with this that may not be apparent right away, the spaces are counted as valid symbols by the network. So we need to invalidate them as well to remove them from the query, "2_______3"\par
This is because the input array is treated as an array of characters, with the caveat that extra whitespace is ignored and condensed down to a single space, ' ', which can be odd if not expected. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 2_______3 /end/\par
}
 Then use this query_Spacial function & gather the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid query_Spacial 0\par
gather_Output 0\par
}
 Which gives us the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8 10 2 9 2 3 3 2 4\par
15 10 2 9 2 3 4 1 5\par
18 20 2 9 2 1 3 5 3 <- The charge here is [20] because both of the nodes were found in the right location.\par
22 10 2 9 2 3 4 5 1\par
27 20 2 9 2 1 5 3 3\par
 9 10 2 9 4 1 2 5 3\par
11 10 2 9 1 5 2 4 3\par
19 10 2 9 4 5 1 2 3\par
29 10 2 9 5 4 2 1 3\par
}
 To further this example we will search for a temperature with a value of 1, and humidity of 4 to see what was going on when it was a wee bit chilly with high humidity.\par
First we output a newline to the file to separate our searches, then we set the input. After setting the input we can then query_Spacial and gather_Output as normal. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Newline 0\par
set_Input 0 ____1___4 /end/\par
query_Spacial 0\par
gather_Output 0\par
}
 This gives the following output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12 10 2 9 3 2 1 4 5\par
19 10 2 9 4 5 1 2 3\par
28 10 2 9 4 3 1 2 5\par
31 20 2 9 3 2 1 5 4 <- This appears to be the only really good match.\par
 8 10 2 9 2 3 3 2 4\par
16 10 2 9 5 1 2 3 4\par
21 10 2 9 3 2 5 1 4\par
24 10 2 9 5 1 3 2 4\par
}
 Using this you can selectively search your traces.\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action. \par}
}}
{\xe \v register_Assembly\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:register_Assembly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::register_Assembly (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registers a Construct with the neural net engine of the given architecture and name desired. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
register_Assembly TYPE NAME\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i TYPE} \cell }{The node network architecture, Many_To_One, pyramidal, etc. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{Outputs the ID of the newly constructed construct to "./Output/returns.ssv".\cell }
{\row }
}
Registers a construct with the engine. This calls "register_Construct" with the {\b c_Node_Network} object NNet in the {\b c_Construct}, which:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Creates an instance of a CAN scaffold of the type specified.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Creates a fractal state tree for the construct.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The name is registered in an array.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
These are all encapsulated in a "construct".\par}
Currently these are the types of constructs available:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Many_To_One\par}
Many_To_One: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid This type is only 2 tiers, the state tier, and one treetop node per trace. You encode all the state nodes, then submit them as one to "get_Upper_Tier_Node".\par
}
 Example Usage:\par
We'll register 3 constructs, then output the assemblies: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
register_Assembly Many_To_One ConExa\par
register_Assembly Many_To_One ExaMSC\par
\par
output_Assemblies\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __COMMAND__| output_assemblies |\par
[0]: ExaCon\par
[1]: ConExa\par
[2]: ExaMSC\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v register_New_Construct\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:register_New_Construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::register_New_Construct (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to differentiate a new construct, allocates a state tree to handle a state-node space. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
register_New_Construct {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function returns the ID of the construct created, this is the index for the state ndoe arrays and such.\cell }
{\row }
}
The node network is shared among all the constructs, however, it is typically desirable for each construct to have its own state nodes separate from others. This is done by having an array of fractal state trees on the bottom, one fractal tree for each node network. Or in some cases, for each input index, or sub-set of the input.\par
Example Usage:\par
In this example there are three constructs already declared, meaning the depth of the fractal state tree array is 3. This is with one state tree per construct, so the newly registered one will return the index of [3] for the new construct and the new depth of the fractal state tree array will be 4. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_New_Construct\par
}
 Output:\par
Contents of the RETURN_FILE: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In the class {\b c_Construct} you'll find the continued abstraction of the networks by assigning names to constructs for each index and such. These may get misaligned due to some networks using more than one state fractal tree per network, so don't rely on the alignment of the fractal state tree indexes and the abstraction in the {\b c_Construct}. \par}
}}
{\xe \v reset_Input\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:reset_Input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::reset_Input (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to wipe the input array of a given construct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
reset_Input CONSTRUCT_ID {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's input we are to wipe. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
For oopsies and when you need to prep a construct for new input.\par
Example Usage:\par
Let's setup a construct, set the input, output the input (lel), wipe the input, and output it again to confirm: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 This is amazing wheee /end/ encode 0\par
output_Input 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==--\par
[0] > T <\par
[1] > h <\par
[2] > i <\par
[3] > s <\par
[4] >   <\par
[5] > i <\par
[6] > s <\par
[7] >   <\par
[8] > a <\par
[9] > m <\par
[10] > a <\par
[11] > z <\par
[12] > i <\par
[13] > n <\par
[14] > g <\par
[15] >   <\par
[16] > w <\par
[17] > h <\par
[18] > e <\par
[19] > e <\par
[20] > e <\par
}
 Now wipe the output and check it again!: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid wipe_Input 0\par
output_Input 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid --==   CAN_Input   ==--\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v run\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::run (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main loop for the neuro-server. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
run\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Call this to start the server in C++.\par
This loop outputs a the message as a means of delay, then checks the flag file, and if anything is found it calls the interpreter.\par
Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v set_Dendrites\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:set_Dendrites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::set_Dendrites (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the dendrites of the node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set_Dendrites NID COUNT DENDRITE_IDS[] {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID of the node being manipulated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{COUNT The number of dendrites in the array DENDRITE_IDS[] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{DENDRITE_IDS[] An array of NIDs that represent the dendritic connections. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
The choice of encoding method will determine dendrite count. This is left with a dynamic leg count though so that bespoke networks can be created with ease. It is dangerous, but that is up to the user to handle.\par
Example Usage:\par
Setting the dendrites of imaginary node 43 to NIDs 2 & 3 representing the connections to "lower" tier nodes making up the sub-symbols of the current node's represented pattern. Before and after setting them we output the node. This assumes no axonic connections. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 43\par
set_Dendrites 43 2 2 3\par
output_Node_Raw 43\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 43 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 43 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [0] 2 [1] 3 --- Axon_Hillock_Count: 0\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This assumes the node has no dendrites yet, if it does you be dangling and jangling.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling it and assigning dendrites invalid NID IDs will cause a crash when bp_O, create_Connection, does_Lower_Ter_Connection_Exist, or any other operation which touches the dendrites. \par}
}}
{\xe \v set_Input\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:set_Input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int c_Construct_Text_Server::set_Input (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This command sets the input of a given construct to the given input string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set_input CONSTRUCT_ID INPUT_STRING {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's input you wish to set. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i INPUT_STRING} \cell }{The input string, either terminates from endl, or the token '/end/' \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
The sub-string '/end/' can be used as a string terminator. This is useful when you want to string multiple commands together, otherwise anything after the input command would be considered input. 'set_Input 0 Example_Text encode 0' would end up setting construct [0]'s input to 'Example_Text encode 0' and nothing would be encoded.\par
Use this function to set the input of the construct you'll be either encoding or evaluating, or both.\par
Use characters or numbers that you know won't appear in the dataset to create a "greenscreen" over your input for the network. This is due to the NULLCAN, where a node that isn't found is set to NULL on the CAN scaffold, and subsequently is skipped during charging as there is nothing to charge. Alternatively just use the query_Given_Legs command.\par
Whitespace is weird when doing text input through set_Input! It reads from the text file using "file >> tmp_Variable", then this variable is concatenated to the others, "full_Variable = full_Variable + " " + tmp_Variable. If the next token is the '/end/' tag it does not append whitespace to the token, so 'set_Input 0 10 /end/' would only input '10' not '10 '. This full string is then read in as input and the network evaluates each character including spaces, even though whitespace was ignored in tokenization. This means that if you are trying to search for multiple tokens in a single string you need to be aware that spaces between the words may cause false positive associations due to the space or other whitespace. The greenscreen masking technique detailed in set_Input can be used to handle this behavior through input formatting only. So be aware these two behaviours stack to form a strange and peculiar action.\par
Example Usage:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 1.\par}
We'll register a construct, then set the input, then output the input so we can see it. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 Careful lads, I think there's a sni- /end/\par
output_Input 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==--\par
[0] > C <\par
[1] > a <\par
[2] > r <\par
[3] > e <\par
[4] > f <\par
[5] > u <\par
[6] > l <\par
[7] >   <\par
[8] > l <\par
[9] > a <\par
[10] > d <\par
[11] > s <\par
[12] > , <\par
[13] >   <\par
[14] > I <\par
[15] >   <\par
[16] > t <\par
[17] > h <\par
[18] > i <\par
[19] > n <\par
[20] > k <\par
[21] >   <\par
[22] > t <\par
[23] > h <\par
[24] > e <\par
[25] > r <\par
[26] > e <\par
[27] > ' <\par
[28] > s <\par
[29] >   <\par
[30] > a <\par
[31] >   <\par
[32] > s <\par
[33] > n <\par
[34] > i <\par
[35] > - <\par
}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 2.\par}
We're going to show what happens if you forget the '/end/' on a compound statement with set_Input in it. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input 0 Example_Text encode 0\par
output_Input 0\par
}
 Gives the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==--\par
[0] > E <\par
[1] > x <\par
[2] > a <\par
[3] > m <\par
[4] > p <\par
[5] > l <\par
[6] > e <\par
[7] > _ <\par
[8] > T <\par
[9] > e <\par
[10] > x <\par
[11] > t <\par
[12] >   <\par
[13] > e <\par
[14] > n <\par
[15] > c <\par
[16] > o <\par
[17] > d <\par
[18] > e <\par
[19] >   <\par
[20] > 0 <\par
}
 Whereas including the '/end/' closing tag: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 Example_Text /end/ encode 0\par
output_Input 0\par
}
 Gives the output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==--\par
[0] > E <\par
[1] > x <\par
[2] > a <\par
[3] > m <\par
[4] > p <\par
[5] > l <\par
[6] > e <\par
[7] > _ <\par
[8] > T <\par
[9] > e <\par
[10] > x <\par
[11] > t <\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v set_Input_uint\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:set_Input_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::set_Input_uint (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the input of a given construct to the given array of uint64_t values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set_Input_uint CONSTRUCT_ID COUNT INPUT[]\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's input will be getting set. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i COUNT} \cell }{The number of elements to expect in the Input[] array. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i INPUT[]} \cell }{The uint64_t array that will be read into the input of the given construct. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This function is used when you have arrays of unsigned integer values to work with. Used for handling nodes with multi-sensory constructs and others that use nodes as their I/O states.\par
Example Usage:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Example 1.\par}
Imagine we have an array of unsigned integers representing the number of deaths a team has in a video game. Say 4 players: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
set_Input_uint 0 4 3 10 12 87\par
output_Input_uint 0\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Input   ==--\par
[0] > 3 <\par
[1] > 10 <\par
[2] > 12 <\par
[3] > 87 <\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
None. \par}
}}
{\xe \v set_State_Nodes_Index\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:set_State_Nodes_Index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::set_State_Nodes_Index (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the index for the given Construct state_Node_Tree. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set_State_Nodes_Index CONSTRUCT_ID INDEX {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CONSTRUCT_ID} \cell }{The construct who's state node tree you are setting. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i INDEX} \cell }{The index you are setting the state tree to. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
Sets the index for the given Construct state_Node_Tree in the c_Node_Network::State_Nodes[] fractal state tree array. This keeps the state spaces separate and discrete. Most networks you don't want to share state nodes. Some you do, that's where this function comes in, allows you to point a construct to the state tree you want.\par
It is important to remember that the state tree indices and the constructs don't line up. Construct[1] likely doesn't have State_Tree[1]!\par
Example Usage:\par
Create 2 constructs to work with, we'll be pointing ConExa's State Tree at ExaCon's State Tree: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid register_Assembly Many_To_One ExaCon\par
register_Assembly Many_To_One ConExa\par
}
 Set the ConExa to ExaCon: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_State_Nodes_Index 1 1\par
}
 Encode a string into ExaCon & output the scaffold, then encode a similar one in ConExa & output the scaffold. Comparing these you can see the shared nodes underneath. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid set_Input 0 Control_String Variable /end/\par
encode 0\par
output_Scaffold 0\par
\par
set_Input 1 Control_String New_Data /end/\par
encode 1\par
output_Scaffold 1\par
}
 All constructs share the underlying node network, so those NIDs are unique to the entire network, not just a single construct. This means when you see the same node in both scaffolds you are seeing the exact same node.\par
Output:\par
Construct[0]: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 5\par
  [5]  <> 2\par
  [6]  <> 6\par
  [7]  <> 7\par
  [8]  <> 8\par
  [9]  <> 4\par
  [10]  <> 5\par
  [11]  <> 9\par
  [12]  <> 3\par
  [13]  <> 10\par
  [14]  <> 11\par
  [15]  <> 12\par
  [16]  <> 13\par
  [17]  <> 5\par
  [18]  <> 9\par
  [19]  <> 13\par
  [20]  <> 14\par
  [21]  <> 6\par
  [22]  <> 15\par
<- Tier[1] ->\par
  [0]  <> 16\par
}
 Construct[1]: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  --==   CAN_Scaffold   ==--\par
<- Tier[0] ->\par
  [0]  <> 1\par
  [1]  <> 2\par
  [2]  <> 3\par
  [3]  <> 4\par
  [4]  <> 5\par
  [5]  <> 2\par
  [6]  <> 6\par
  [7]  <> 7\par
  [8]  <> 8\par
  [9]  <> 4\par
  [10]  <> 5\par
  [11]  <> 9\par
  [12]  <> 3\par
  [13]  <> 10\par
  [14]  <> 11\par
  [15]  <> 17\par
  [16]  <> 15\par
  [17]  <> 18\par
  [18]  <> 7\par
  [19]  <> 19\par
  [20]  <> 13\par
  [21]  <> 4\par
  [22]  <> 13\par
<- Tier[1] ->\par
  [0]  <> 20\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
State tree indices and the constructs don't line up. Construct[1] likely doesn't have State_Tree[1]! \par}
}}
{\xe \v set_Type\:c_Construct_Text_Server}
{\xe \v c_Construct_Text_Server\:set_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void c_Construct_Text_Server::set_Type (std::ifstream *  {\i p_File}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the type of a given node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set_Type NID TYPE {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{NID The Node ID (NID) of the node being manipulated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint64_t} \cell }{TYPE The type you are assigning the node to: (0: State), (1: Branch), (2: Treetop), (3: State/Treetop) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Return values\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i None} \cell }{This function doesn't return any values.\cell }
{\row }
}
This type is used for determining how to handle the node. You may want to set one to a treetop that way you can then write a charging function that has a different behavior for treetop nodes.\par
Example Usage:\par
Setting the type of node 66 to the value of 2 flagging it as a treetop node. Before and after setting the type we use output_Node_Raw to view the results. This assumes node 66 has two dendrites \{ 7, 14 \}. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid output_Node_Raw 66\par
set_Type 66 2\par
output_Node_Raw 66\par
}
 Output: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Node_ID (NID) 66 RC: 1 Type: 0  State \{ 0 \} --- Dendrites:  [7]  [14]  --- Axon_Hillock_Count: 0\par
Node_ID (NID) 66 RC: 1 Type: 2  State \{ 0 \} --- Dendrites:  [7]  [14]  --- Axon_Hillock_Count: 0\par
}
 Error Handling:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
No error handling is implemented in this function.\par}
Additional Notes:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Calling this function with an invalid node will cause a crash.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
You can set the type to any value you want, this allows for extending functionality, but can cause a crash if you set it to an invalid type and the node is mishandled. \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Construct_Text_Server.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Fractal_Node Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Fractal_Node}
{\xe \v c_Fractal_Node}
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b Data}{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b NAdd}{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b c_Fractal_Tree}{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Fractal_Tree.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Fractal_Tree Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Fractal_Tree}
{\xe \v c_Fractal_Tree}
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b search} (uint64_t p_Data){\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b query_Node} ({\b c_Fractal_Node} *&p_Node, uint64_t p_Data, int p_Shift){\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Tree} (){\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node} ({\b c_Fractal_Node} *&p_Node, int p_Tab){\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Tree_BP} (){\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_BP} ({\b c_Fractal_Node} *&p_Node){\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Node_NAdd} ({\b c_Fractal_Node} *&p_Node){\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Node_NAdd} ({\b c_Fractal_Node} *&p_Node, {\b c_Node} *p_NAdd){\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b set_Current_Node_NAdd} ({\b c_Node} *p_NAdd){\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Current_Node_NAdd} (){\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save_Tree} (std::ofstream *p_SF){\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b save_Tree_Node} ({\b c_Fractal_Node} *&p_Node, std::ofstream *p_SF){\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Fractal_Node} * {\b Root}{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Fractal_Node} ** {\b Current}{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b flg_Foundit}{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b tmp_Data}{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Count}{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Fractal_Tree.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_IO_Set Class Reference\par \pard\plain 
{\tc\tcl2 \v c_IO_Set}
{\xe \v c_IO_Set}
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Depth} (int p_Depth){\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b wipe_Data} (){\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Value} (uint64_t p_Value, int p_Index=-1){\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Array_Value} (uint64_t *p_Data_Array, int p_Depth){\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Value} (int p_Index=-1){\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b shift_Data} (){\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (){\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t * {\b Data}{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Depth}{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_IO.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Linked_List Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Linked_List}
{\xe \v c_Linked_List}
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_LL} (){\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Linked_List} * {\b Next}{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Linked_List} * {\b Previous}{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b Quanta}{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Linked_List_Handler.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Linked_List_Handler Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Linked_List_Handler}
{\xe \v c_Linked_List_Handler}
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b init} (){\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Linked_List} * {\b new_LL} (uint64_t p_Quanta){\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (){\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Linked_List} * {\b Root}{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Linked_List} ** {\b Current_LL}{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Depth}{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Linked_List_Handler.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Node Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Node}
{\xe \v c_Node}
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Type} (int p_Type){\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b resize_Axon_Hillocks} (int p_Count){\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b add_Axon_Index} ({\b c_Node} *p_Axon, int p_Index){\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Dendrites} ({\b c_Node} **p_Dendrites, int p_Count){\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b does_Upper_Tier_Connection_Exist} ({\b c_Node} **p_Nodes, int p_Count){\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b does_Lower_Connection_Exist} ({\b c_Node} **p_Nodes, int p_Count){\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bind_State} (uint64_t p_State){\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_O} (){\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_F} (){\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_M} (){\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_Trace_O} ({\b c_Linked_List_Handler} *p_LL){\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_Trace_F} ({\b c_Linked_List_Handler} *p_LL){\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b bp_Trace_M} ({\b c_Linked_List_Handler} *p_LL){\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Raw} (){\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Node_Char} (){\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b NID}{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b Next}{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} *** {\b Axons}{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int * {\b Axon_Count}{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Axon_Hillock_Count}{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} ** {\b Dendrites}{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Dendrite_Count}{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b RC}{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Current_Charge}{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b State}{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

short int {\b Type}{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Node.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Node_Network Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Node_Network}
{\xe \v c_Node_Network}
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b register_New_Construct} (){\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b new_Node} (){\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b new_State_Node} (int p_Construct, double p_State){\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b assign_State_Node} (int p_State_Tree, {\b c_Node} *p_Node, double p_State){\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b create_Connections} ({\b c_Node} *p_To, {\b c_Node} **p_From, int p_Count){\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b does_Upper_Tier_Connection_Exist} ({\b c_Node} **p_Legs, int p_Count){\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Upper_Tier_Node} ({\b c_Node} **p_Legs, int p_Count, int p_Type){\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b does_State_Node_Exist} (int p_Index, uint64_t p_Data){\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_State_Node} (int p_Index, uint64_t p_Data){\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Node_Ref_By_NID} (uint64_t p_NID){\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_BP} (){\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_Raw} (){\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_BP_NID} (uint64_t p_NID){\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Fractal_Tree} {\b Nodes}{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b Root}{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} ** {\b Current_Node}{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b Node_Count}{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Fractal_Tree} ** {\b State_Nodes}{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b State_Node_Tree_Count}{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Node_Network.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Sim Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Sim}
{\xe \v c_Sim}
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b iterate} (int p_O2_Pump=-1, int p_Heater=-1){\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (){\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output_F} (std::string p_FName){\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Iteration}{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b O2}{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b O2_Delta}{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Temp}{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Temp_Delta}{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b O2_Pump}{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Heater}{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/c_Sim.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Trace Class Reference\par \pard\plain 
{\tc\tcl2 \v c_Trace}
{\xe \v c_Trace}
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Depth} (int p_Depth){\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b wipe_Data} (){\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (){\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Pattern_Index} (uint64_t p_Value, int p_Index=-1){\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Charge} (double p_Charge){\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_RC} (double p_RC){\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Treetop} ({\b c_Node} *p_Treetop){\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set_Pattern_Array} (uint64_t *p_Pattern_Array, int p_Depth){\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b get_Pattern_Index} (int p_Index=-1){\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b get_Charge} (){\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b get_RC} (){\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b get_Treetop} (){\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b shift_Data} (){\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b output} (int p_Type){\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t * {\b Pattern}{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b Charge}{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b RC}{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b c_Node} * {\b Treetop}{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b Depth}{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Trace.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Base_CAN::tmp_Union Union Reference\par \pard\plain 
{\tc\tcl2 \v c_Base_CAN::tmp_Union}
{\xe \v c_Base_CAN::tmp_Union}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char {\b C}{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b U}{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this union was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_CAN.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
u_Tmp Union Reference\par \pard\plain 
{\tc\tcl2 \v u_Tmp}
{\xe \v u_Tmp}
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b D}{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

uint64_t {\b U}{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this union was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/NT4/c_Node.h\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Sim.h\par \pard\plain 
{\tc\tcl2 \v include/c_Sim.h}
{\xe \v include/c_Sim.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 \par
3 {\cf17 class }c_Sim\par
4 \{\par
5 {\cf17 public}:\par
6 \par
7     {\cf18 int} Iteration;\par
8 \par
9     {\cf18 int} O2;\par
10     {\cf18 int} O2_Delta;\par
11 \par
12     {\cf18 int} Temp;\par
13     {\cf18 int} Temp_Delta;\par
14 \par
15     {\cf18 int} O2_Pump;\par
16     {\cf18 int} Heater;\par
17 \par
18     c_Sim()\par
19     \{\par
20         Iteration = 0;\par
21 \par
22         O2 = 5;\par
23         O2_Delta = 1;\par
24 \par
25         Temp = 5;\par
26         Temp_Delta = 1;\par
27 \par
28         O2_Pump = 0;\par
29         Heater = 0;\par
30     \}\par
31 \par
32     {\cf20 // Afferent Sensors - Goals}\par
33     {\cf20 // O2      | -1/iteration //Breathing   | Goal: 5 | G:5 Y:(4 & 6)      R: (< 4 & > 6)  | Priority: 2  }\par
34     {\cf20 // Temp    | -2/iteration //Winter      | Goal: 8 | G:8 Y:(6-7 & 9-10) R: (< 6 & > 10) | Priority: 2  }\par
35 \par
36     {\cf20 // Actuator Systems - Feedback}\par
37     {\cf20 // O2 Pump | +4/Iteration [O2]          | -1/Iteration [Temperature] | if (O2 < 5) (Heater = 1) else (Heater = 0)}\par
38     {\cf20 // Heater  | +3/Iteration [Temperature] |                            | if (Temp < 8) (Heater = 1) else (Heater = 0)}\par
39 \par
40     {\cf18 int} iterate({\cf18 int} p_O2_Pump = -1, {\cf18 int} p_Heater = -1)\par
41     \{\par
42         Iteration++;\par
43 \par
44         {\cf20 //Environmental}\par
45         {\cf18 int} tmp_O2 = O2;\par
46         O2 -= 1; {\cf20 //Breathing}\par
47 \par
48         {\cf18 int} tmp_Temp = Temp;\par
49         Temp -= 2; {\cf20 //Winter}\par
50 \par
51         {\cf20 //Calculate actuator effects.}\par
52         {\cf19 if} (O2_Pump) \{ O2 += 4; Temp -= 1; \} {\cf20 //O2 Pump}\par
53         {\cf19 if} (Heater) \{ Temp += 3; \} {\cf20 //Heater}\par
54 \par
55         {\cf20 //Calculate the environmental changes based on the previous iterations.}\par
56         {\cf19 if} (O2 < tmp_O2) \{ O2_Delta = 0; \}\par
57         {\cf19 if} (O2 == tmp_O2) \{ O2_Delta = 1; \}\par
58         {\cf19 if} (O2 > tmp_O2) \{ O2_Delta = 2; \}\par
59 \par
60         {\cf19 if} (Temp < tmp_Temp) \{ Temp_Delta = 0; \}\par
61         {\cf19 if} (Temp == tmp_Temp) \{ Temp_Delta = 1; \}\par
62         {\cf19 if} (Temp > tmp_Temp) \{ Temp_Delta = 2; \}\par
63 \par
64         {\cf19 if} ((p_Heater != -1) && (p_O2_Pump != -1))\par
65         \{\par
66             Heater = p_Heater;\par
67             O2_Pump = p_O2_Pump;\par
68         \}\par
69         {\cf19 else}\par
70         \{\par
71             {\cf20 //Calculate the actuator state.}\par
72             {\cf19 if} (tmp_Temp < 8) \{ Heater = 1; \}\par
73             {\cf19 if} (tmp_O2 < 5) \{ O2_Pump = 1; \}\par
74 \par
75             {\cf19 if} (tmp_Temp >= 8) \{ Heater = 0; \}\par
76             {\cf19 if} (tmp_O2 >= 5) \{ O2_Pump = 0; \}\par
77         \}\par
78 \par
79         {\cf19 return} Iteration;\par
80     \}\par
81 \par
82     {\cf18 void} output()\par
83     \{\par
84         std::cout << {\cf22 "\\n"};\par
85         std::cout << Iteration;\par
86         std::cout << {\cf22 "\\nencode 0 set_input 0 O2 "} << O2;\par
87         std::cout << {\cf22 "\\nencode 0 set_input 0 O2_Delta "} << O2_Delta;\par
88 \par
89         std::cout << {\cf22 "\\nencode 0 set_input 0 Temp "} << Temp;\par
90         std::cout << {\cf22 "\\nencode 0 set_input 0 Temp_Delta "} << Temp_Delta;\par
91 \par
92         std::cout << {\cf22 "\\nencode 0 set_input 0 O2_Pump "} << O2_Pump;\par
93         std::cout << {\cf22 "\\nencode 0 set_input 0 Heater "} << Heater;\par
94     \}\par
95 \par
96     {\cf18 void} output_F(std::string p_FName)\par
97     \{\par
98         std::ofstream tmp_F;\par
99 \par
100         tmp_F.open(p_FName, std::ios::app);\par
101 \par
102 \par
103         tmp_F << {\cf22 "\\n"};\par
104         tmp_F << {\cf22 "\\noutput_newline"};\par
105         tmp_F << {\cf22 "\\nset_input 0 O2 "} << O2 << {\cf22 " /end/ encode 0 gather_treetop_node 0 "};\par
106         tmp_F << {\cf22 "\\nset_input 0 O2_Delta "} << O2_Delta << {\cf22 " /end/ encode 0 gather_treetop_node 0 "};\par
107 \par
108         tmp_F << {\cf22 "\\nset_input 0 Temp "} << Temp << {\cf22 " /end/ encode 0 gather_treetop_node 0 "};\par
109         tmp_F << {\cf22 "\\nset_input 0 Temp_Delta "} << Temp_Delta << {\cf22 " /end/ encode 0 gather_treetop_node 0 "};\par
110 \par
111         tmp_F << {\cf22 "\\nset_input 0 O2_Pump "} << O2_Pump << {\cf22 " /end/ encode 0 gather_treetop_node 0 "};\par
112         tmp_F << {\cf22 "\\nset_input 0 Heater "} << Heater << {\cf22 " /end/ encode 0 gather_treetop_node 0 "};\par
113 \par
114         tmp_F.close();\par
115     \}\par
116 \};\par
117 \par
118  \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN.h}
{\xe \v include/NT4/c_CAN.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //The Current Active Node Scaffold for Trace Encoding (CAN) is the scaffold we use to iteratively encode traces.}\par
2 {\cf20 //For example, a network with an I/O depth of 5 and a single tier w/ one 5 legged node may look like this:}\par
3 {\cf20 // Memory_Tier[1]: [0] //The top node, represents one permutation of the input tier. Multiple Memory tiers.}\par
4 {\cf20 // The memory tiers start at [1] since the State tier is technically Memory tier [0].}\par
5 {\cf20 // State_Tier (0): [0] [1] [2] [3] [4] //This is the tier with the states. }\par
6 {\cf20 // Each [] represents a pointer to a node. We iterate from bottom to top, using get_State_Node,}\par
7 {\cf20 // and get_Upper_Tier_Node() to fill it out tier by tier.}\par
8 \par
9 {\cf20 //--Not using a polymorphic base class here, different CANs may have wildly different features.}\par
10 {\cf20 //--Once enough are written then we can go back and write one if need be.}\par
11 {\cf20 //Scratch that, making a base class so that when an assembly is registered a CAN can (hue hue hue) be chosen and function as the interface.}\par
12 \par
13 {\cf20 //This is the base class for a CAN. It has the input, encode, and outputs.}\par
14 {\cf17 class }c_Base_CAN {\cf20 //Man}\par
15 \{\par
16 {\cf17 public}:\par
17 \par
18     {\cf20 //The reference to the node network to query for nodes.}\par
19     c_Node_Network* NNet;\par
20 \par
21     {\cf20 //This is the index in the c_Node_Network::State_Nodes[] array to request from.}\par
22     {\cf18 int} State_Nodes_Index;\par
23 \par
24     {\cf20 //The inputs for the CAN, they are uint64_t internally, the data is not modified so as long as the correct interface is used then none will be lost.}\par
25     {\cf20 //uint64_t* Input;}\par
26     {\cf20 //int Input_Depth;}\par
27     c_IO_Set Input;\par
28     c_2D_IO_Set Input_2D;\par
29     c_3D_IO_Set Input_3D;\par
30     \par
31     {\cf20 //The output is an array of traces retrieved from charging the buffers.}\par
32     c_Trace* Output;\par
33     {\cf18 int} Output_Depth;\par
34 \par
35     {\cf20 //These may vary wildly depending on the CAN structure, the scaffold will be completely internal.}\par
36     {\cf20 //Because of this we will declare the actual scaffold in the derived classes rather than here.}\par
37     {\cf20 //c_Node** Scaffold[2];}\par
38     {\cf20 //int State_Depth; //We track this so that if the input is changed we can still properly delete the scaffold.}\par
39 \par
40     {\cf20 //==--   Member functions   --==//}\par
41 \par
42     {\cf20 //This encodes the p_Input data, if the nodes aren't found they are created, used for training.}\par
43     {\cf17 virtual} {\cf18 void} encode(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0)=0;\par
44 \par
45     {\cf20 //This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN}\par
46     {\cf20 //Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs.}\par
47     {\cf20 //Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.}\par
48     {\cf17 virtual} {\cf18 void} query(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int}* p_Legs = NULL)=0;\par
49 \par
50     {\cf20 //This allows for passing unordered sets of nodes}\par
51     {\cf17 virtual} {\cf18 void} submit_Set(uint64_t* p_Input, {\cf18 int} p_Depth)=0;\par
52 \par
53     {\cf20 //This returns the treetop node at a given index, for most structures this will be a single node, but for those like stiched-base networks with a treetop node count equal to the input node count then you can access them by index.}\par
54     {\cf17 virtual} c_Node* get_Treetop({\cf18 int} p_Index = 0)=0;\par
55     \par
56     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
57     {\cf17 virtual} {\cf18 void} gather_Given_Trace(uint64_t p_NID)=0;\par
58     \par
59     {\cf17 virtual} {\cf18 void} gather_All_Traces()=0;\par
60 \par
61     {\cf20 //Wipe the input array.}\par
62     {\cf18 void} reset_Input()\par
63     \{\par
64         Input.reset();\par
65         Input_2D.reset();\par
66         Input_3D.reset();\par
67     \}\par
68 \par
69     {\cf20 //Associate the CAN with a network from which to draw nodes.}\par
70     {\cf18 void} set_NNet(c_Node_Network* p_NNet)\par
71     \{\par
72         NNet = p_NNet;\par
73     \}\par
74 \par
75     {\cf20 //Sets the index for the state_Node_Tree in the c_Node_Network::State_Nodes[]}\par
76     {\cf18 void} set_State_Nodes_Index({\cf18 int} p_Index)\par
77     \{\par
78         std::cout << {\cf22 "\\n State_Nodes_Index set to "} << p_Index;\par
79         State_Nodes_Index = p_Index;\par
80     \}\par
81 \par
82     {\cf20 //This violates every good practice I know hue hue hue}\par
83     {\cf17 union }tmp_Union\par
84     \{\par
85         {\cf18 char} C;\par
86         uint64_t U;\par
87     \};\par
88 \par
89     {\cf20 //Sets the input to the given uint64_t array.}\par
90     {\cf20 //The input array is 1D, but for more complex constructs dimensional index slicing is used.}\par
91     {\cf18 void} set_Input(uint64_t* p_Input, {\cf18 int} p_Input_Depth)\par
92     \{\par
93         Input.set_Array_Value(p_Input, p_Input_Depth);\par
94     \}\par
95 \par
96     {\cf20 //This is used for setting the input array to reflect a sequence of characters.}\par
97     {\cf18 void} set_Input_String(std::string p_Input)\par
98     \{\par
99         tmp_Union * tmp_Input = NULL;\par
100         uint64_t * tmp_Input_U = NULL;\par
101 \par
102         tmp_Input = {\cf17 new} tmp_Union[p_Input.length()];\par
103         tmp_Input_U = {\cf17 new} uint64_t[p_Input.length()];\par
104 \par
105         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Input.length(); cou_Index++ )\par
106         \{\par
107             tmp_Input[cou_Index].U = 0;\par
108             tmp_Input_U[cou_Index] = 0;\par
109             tmp_Input[cou_Index].C = p_Input[cou_Index];\par
110             tmp_Input_U[cou_Index] = tmp_Input[cou_Index].U;\par
111         \}\par
112 \par
113         Input.set_Array_Value(tmp_Input_U, {\cf18 int}(p_Input.length()));\par
114 \par
115         {\cf19 if} (tmp_Input != NULL) \{ {\cf17 delete}[] tmp_Input; \}\par
116         tmp_Input = NULL;\par
117         {\cf19 if} (tmp_Input_U != NULL) \{ {\cf17 delete}[] tmp_Input_U; \}\par
118         tmp_Input_U = NULL;\par
119     \}\par
120 \par
121     {\cf20 //Sets the input to the given uint64_t array.}\par
122     {\cf20 //The input array is 1D, but for more complex constructs dimensional index slicing is used.}\par
123     {\cf18 void} set_2D_Input(uint64_t** p_Input, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth)\par
124     \{\par
125         Input_2D.set_Array_Value(p_Input, p_X_Depth, p_Y_Depth);\par
126     \}\par
127 \par
128     {\cf20 //This is used for setting the input array to reflect a 2d set of characters.}\par
129     {\cf18 void} set_2D_Input_String({\cf18 char} ** p_Input, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth)\par
130     \{\par
131         tmp_Union** tmp_Input = NULL;\par
132         uint64_t** tmp_Input_U = NULL;\par
133 \par
134         tmp_Input = {\cf17 new} tmp_Union*[p_X_Depth];\par
135         tmp_Input_U = {\cf17 new} uint64_t*[p_X_Depth];\par
136 \par
137         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < p_X_Depth; cou_X++)\par
138         \{\par
139             tmp_Input[cou_X] = {\cf17 new} tmp_Union[p_Y_Depth];\par
140             tmp_Input_U[cou_X] = {\cf17 new} uint64_t[p_Y_Depth];\par
141 \par
142             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < p_Y_Depth; cou_Y++)\par
143             \{\par
144                 tmp_Input[cou_X][cou_Y].U = 0;\par
145                 tmp_Input_U[cou_X][cou_Y] = 0;\par
146                 tmp_Input[cou_X][cou_Y].C = p_Input[cou_X][cou_Y];\par
147                 tmp_Input_U[cou_X][cou_Y] = tmp_Input[cou_X][cou_Y].U;\par
148             \}\par
149 \par
150         \}\par
151 \par
152         Input_2D.set_Array_Value(tmp_Input_U, p_X_Depth, p_Y_Depth);\par
153 \par
154         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < p_X_Depth; cou_X++)\par
155         \{\par
156             {\cf19 if} (tmp_Input[cou_X] != NULL) \{ {\cf17 delete}[] tmp_Input[cou_X]; \}\par
157             tmp_Input[cou_X] = NULL;\par
158             {\cf19 if} (tmp_Input_U[cou_X] != NULL) \{ {\cf17 delete}[] tmp_Input_U[cou_X]; \}\par
159             tmp_Input_U[cou_X] = NULL;\par
160         \}\par
161         {\cf19 if} (tmp_Input != NULL) \{ {\cf17 delete}[] tmp_Input; \}\par
162         tmp_Input = NULL;\par
163         {\cf19 if} (tmp_Input_U != NULL) \{ {\cf17 delete}[] tmp_Input_U; \}\par
164         tmp_Input_U = NULL;\par
165     \}\par
166 \par
167     {\cf20 //Sets the input to the given uint64_t array.}\par
168     {\cf20 //The input array is 1D, but for more complex constructs dimensional index slicing is used.}\par
169     {\cf18 void} set_3D_Input(uint64_t*** p_Input, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, {\cf18 int} p_Z_Depth)\par
170     \{\par
171         Input_3D.set_Array_Value(p_Input, p_X_Depth, p_Y_Depth, p_Z_Depth);\par
172     \}\par
173 \par
174     {\cf20 //This is used for setting the input array to reflect a 3d set of characters.}\par
175     {\cf18 void} set_3D_Input_String({\cf18 char} *** p_Input, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, {\cf18 int} p_Z_Depth)\par
176     \{\par
177         tmp_Union*** tmp_Input = NULL;\par
178         uint64_t*** tmp_Input_U = NULL;\par
179 \par
180         tmp_Input = {\cf17 new} tmp_Union**[p_X_Depth];\par
181         tmp_Input_U = {\cf17 new} uint64_t**[p_X_Depth];\par
182 \par
183         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < p_X_Depth; cou_X++)\par
184         \{\par
185             tmp_Input[cou_X] = {\cf17 new} tmp_Union*[p_Y_Depth];\par
186             tmp_Input_U[cou_X] = {\cf17 new} uint64_t*[p_Y_Depth];\par
187 \par
188             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < p_Y_Depth; cou_Y++)\par
189             \{\par
190                 tmp_Input[cou_X][cou_Y] = {\cf17 new} tmp_Union[p_Z_Depth];\par
191                 tmp_Input_U[cou_X][cou_Y] = {\cf17 new} uint64_t[p_Z_Depth];\par
192 \par
193                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < p_Z_Depth; cou_Z++)\par
194                 \{\par
195                     tmp_Input[cou_X][cou_Y][cou_Z].U = 0;\par
196                     tmp_Input_U[cou_X][cou_Y][cou_Z] = 0;\par
197                     tmp_Input[cou_X][cou_Y][cou_Z].C = p_Input[cou_X][cou_Y][cou_Z];\par
198                     tmp_Input_U[cou_X][cou_Y][cou_Z] = tmp_Input[cou_X][cou_Y][cou_Z].U;\par
199                 \}\par
200             \}\par
201         \}\par
202 \par
203         Input_3D.set_Array_Value(tmp_Input_U, p_X_Depth, p_Y_Depth, p_Z_Depth);\par
204 \par
205         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < p_X_Depth; cou_X++)\par
206         \{\par
207             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < p_Y_Depth; cou_Y++)\par
208             \{\par
209                 {\cf19 if} (tmp_Input[cou_X][cou_Y] != NULL) \{ {\cf17 delete}[] tmp_Input[cou_X][cou_Y]; \}\par
210                 tmp_Input[cou_X][cou_Y] = NULL;\par
211                 {\cf19 if} (tmp_Input_U[cou_X][cou_Y] != NULL) \{ {\cf17 delete}[] tmp_Input_U[cou_X][cou_Y]; \}\par
212                 tmp_Input_U[cou_X][cou_Y] = NULL;\par
213             \}\par
214             {\cf19 if} (tmp_Input[cou_X] != NULL) \{ {\cf17 delete}[] tmp_Input[cou_X]; \}\par
215             tmp_Input[cou_X] = NULL;\par
216             {\cf19 if} (tmp_Input_U[cou_X] != NULL) \{ {\cf17 delete}[] tmp_Input_U[cou_X]; \}\par
217             tmp_Input_U[cou_X] = NULL;\par
218         \}\par
219         {\cf19 if} (tmp_Input != NULL) \{ {\cf17 delete}[] tmp_Input; \}\par
220         tmp_Input = NULL;\par
221         {\cf19 if} (tmp_Input_U != NULL) \{ {\cf17 delete}[] tmp_Input_U; \}\par
222         tmp_Input_U = NULL;\par
223     \}\par
224 \par
225     {\cf20 //==--   Output Functions   --==//}\par
226 \par
227     {\cf20 //Outputs the scaffold as addresses.}\par
228     {\cf17 virtual} {\cf18 void} output_Scaffold()=0;\par
229 \par
230     {\cf20 //Outputs the input array.}\par
231     {\cf18 void} output_Input({\cf18 int} p_Type = 0)\par
232     \{\par
233         std::cout << {\cf22 "\\n  --==   CAN_Input   ==--"};\par
234         std::cout << {\cf22 "\\n 1D:\\n"};\par
235         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Input.Depth; cou_Index++)\par
236         \{\par
237             {\cf19 if} (p_Type == 0) \{ std::cout << {\cf22 "\\n ["} << cou_Index << {\cf22 "] > "} << char(Input.Data[cou_Index]) << {\cf22 " <"}; \}\par
238             {\cf19 if} (p_Type == 1) \{ std::cout << {\cf22 "\\n ["} << cou_Index << {\cf22 "] > "} << Input.Data[cou_Index] << {\cf22 " <"}; \}\par
239         \}\par
240         std::cout << {\cf22 "\\n 2D:\\n"};\par
241         Input_2D.output();\par
242         std::cout << {\cf22 "\\n 3D:\\n"};\par
243         Input_3D.output();\par
244     \}\par
245 \par
246     {\cf20 //Outputs the input array.}\par
247     {\cf18 void} output_Output({\cf18 int} p_Type = 0)\par
248     \{\par
249         std::cout << {\cf22 "\\n  --==   Output_Traces ["} << Output_Depth << {\cf22 "]   ==--"};\par
250         {\cf19 for} ({\cf18 int} cou_Output = 0; cou_Output < Output_Depth; cou_Output++)\par
251         \{\par
252             std::cout << {\cf22 "\\n  Trace["} << cou_Output << {\cf22 "]: "};\par
253 \par
254             std::cout << {\cf22 " Pat_Depth: "} << Output[cou_Output].Depth;\par
255             Output[cou_Output].output(p_Type);\par
256             {\cf20 /*}\par
257 {\cf20             for (int cou_Index = 0; cou_Index < Output[cou_Output].Depth; cou_Index++)}\par
258 {\cf20             \{}\par
259 {\cf20                 //std::cout << "\\n [" << cou_Index << "] ";}\par
260 {\cf20                 std::cout << " " << Output[cou_Output].Pattern[cou_Index];}\par
261 {\cf20             \}}\par
262 {\cf20             */}\par
263         \}\par
264         std::cout << {\cf22 "\\n   --==   /Output_Traces   ==--"};\par
265     \}\par
266 \par
267 \par
268     {\cf20 //Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.}\par
269     {\cf17 virtual} {\cf18 void} output_Scaffold_Char()=0;\par
270 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_1D_Pyramid.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN_1D_Pyramid.h}
{\xe \v include/NT4/c_CAN_1D_Pyramid.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //This functions to create a trace where all legs are connected to one node.}\par
3 {\cf20 //Load up the input, hit encode(), boom you single permutation of all legs bound to that node.}\par
4 {\cf20 //Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good}\par
5 {\cf17 class }c_CAN_1D_Pyramid : {\cf17 public} c_Base_CAN\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Each CAN node is just a pointer to a node in the network.}\par
10     {\cf20 //Scaffold[Tier][Index]}\par
11     {\cf20 //Tier_Depth == where T = current tier: (Input_Depth - T)}\par
12     c_Node*** Scaffold;\par
13 \par
14     {\cf18 int} State_Depth; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
15 \par
16     {\cf20 //The temporary buffer used during charging.}\par
17     c_Charging_Buffer tmp_Buffman;\par
18 \par
19     c_CAN_1D_Pyramid()\par
20     \{\par
21         NNet = NULL;\par
22 \par
23         Input.reset();\par
24         Output = NULL;\par
25         Output_Depth = 0;\par
26 \par
27         Scaffold = NULL;\par
28 \par
29         State_Depth = 0;\par
30         State_Nodes_Index = 0;\par
31     \}\par
32 \par
33     ~c_CAN_1D_Pyramid()\par
34     \{\par
35         NNet = NULL;\par
36         reset_Scaffold();\par
37         reset_Input();\par
38     \}\par
39 \par
40     {\cf20 //Resets the CAN to NULL, and deletes the state tier + treetop.}\par
41     {\cf18 void} reset_Scaffold()\par
42     \{\par
43         {\cf19 if} (Scaffold != NULL)\par
44         \{\par
45             {\cf20 //For every tier}\par
46             {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < State_Depth; cou_T++)\par
47             \{\par
48                 {\cf19 if} (Scaffold[cou_T] != NULL)\par
49                 \{\par
50                     {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)\par
51                     \{\par
52                         {\cf20 //Make sure to NULL the scaffold first.}\par
53                         {\cf20 //DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.}\par
54                         Scaffold[cou_T][cou_Index] = NULL;\par
55                     \}\par
56 \par
57                     {\cf17 delete}[] Scaffold[cou_T];\par
58                     Scaffold[cou_T] = NULL;\par
59                 \}\par
60             \}\par
61             {\cf17 delete}[] Scaffold;\par
62             Scaffold = NULL;\par
63         \}\par
64     \}\par
65 \par
66     {\cf20 //This sets up the actual CAN scaffold to use.}\par
67     {\cf20 //It assumes the input array is filled out, the size is based upon that array.}\par
68     {\cf18 void} setup_CAN_Scaffold()\par
69     \{\par
70         {\cf20 //Take it out back and put it down.}\par
71         reset_Scaffold();\par
72 \par
73         {\cf20 //Sizing her up!}\par
74         State_Depth = Input.Depth;\par
75 \par
76         {\cf20 //Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.}\par
77         Scaffold = {\cf17 new} c_Node ** [State_Depth];\par
78 \par
79         {\cf20 //Through the tiers we brings beers.}\par
80         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < State_Depth; cou_T++)\par
81         \{\par
82             {\cf20 //Through the steps Randolph Carter crept.}\par
83             Scaffold[cou_T] = {\cf17 new} c_Node * [State_Depth - cou_T];\par
84 \par
85             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)\par
86             \{\par
87                 Scaffold[cou_T][cou_Index] = NULL;\par
88             \}\par
89         \}\par
90     \}\par
91 \par
92     {\cf20 //This fills the state tier by querying the node network.}\par
93     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
94     {\cf18 void} fill_State(std::string p_How = {\cf22 "Encode"})\par
95     \{\par
96         std::cout << {\cf22 "\\n Encoding with State_Nodes_Index: "} << State_Nodes_Index;\par
97         {\cf19 if} (p_How == {\cf22 "Encode"})\par
98         \{\par
99             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
100             \{\par
101                 {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
102                 {\cf20 //We have to make sure we request the correct state tree.}\par
103                 Scaffold[0][cou_Index] = NNet->get_State_Node(State_Nodes_Index, Input.Data[cou_Index]);\par
104                 Scaffold[0][cou_Index]->RC++;\par
105 \par
106                 {\cf20 //If the node is also a treetop then set it to state/treetop.}\par
107                 {\cf19 if} ((Scaffold[0][cou_Index]->Type == 2))\par
108                 \{\par
109                     Scaffold[0][cou_Index]->Type = 3;\par
110                 \}\par
111             \}\par
112         \}\par
113         {\cf19 if} (p_How == {\cf22 "Query"})\par
114         \{\par
115             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
116             \{\par
117                 {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
118                 {\cf20 //We have to make sure we request the correct state tree.}\par
119                 Scaffold[0][cou_Index] = NNet->does_State_Node_Exist(State_Nodes_Index, Input.Data[cou_Index]);\par
120             \}\par
121         \}\par
122     \}\par
123 \par
124     {\cf20 //Just one node at the tippy top.}\par
125     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
126     {\cf18 void} fill_Scaffold(std::string p_How = {\cf22 "Encode"})\par
127     \{\par
128         {\cf19 if} (State_Depth == 0)\par
129         \{\par
130             {\cf19 return};\par
131         \}\par
132         {\cf19 for} ({\cf18 int} cou_T = 1; cou_T < State_Depth; cou_T++)\par
133         \{\par
134             std::cerr << {\cf22 "\\n T: "} << cou_T;\par
135             {\cf20 //The extra -1 is so we don't step to the last node and reach into the void.}\par
136             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)\par
137             \{\par
138                 std::cerr << {\cf22 " - "} << cou_Index;\par
139                 {\cf19 if} (p_How == {\cf22 "Encode"})\par
140                 \{\par
141                     {\cf20 //We request a node that links 2 nodes together.}\par
142                     Scaffold[cou_T][cou_Index] = NNet->get_Upper_Tier_Node(&(Scaffold[cou_T - 1][cou_Index]), 2, 1);\par
143                     Scaffold[cou_T][cou_Index]->RC++;\par
144                 \}\par
145                 {\cf19 if} (p_How == {\cf22 "Query"})\par
146                 \{\par
147                     {\cf20 //We request a node that links the entire state tier together, but do not create them.}\par
148                     Scaffold[cou_T][cou_Index] = NNet->does_Upper_Tier_Connection_Exist(&(Scaffold[cou_T][cou_Index]), 2);\par
149                 \}\par
150             \}\par
151         \}\par
152         Scaffold[State_Depth - 1][0]->Type = 2;\par
153     \}\par
154 \par
155     {\cf20 //Encodes a single trace, forcibly.}\par
156     {\cf18 void} encode(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0)\par
157     \{\par
158         std::cout << {\cf22 "\\n\\n<<-- Begin Encoding -->>\\n\\n"};\par
159 \par
160         {\cf20 //Firstly we gather the inputly}\par
161         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
162 \par
163         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
164         setup_CAN_Scaffold();\par
165 \par
166         output_Scaffold();\par
167 \par
168         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
169         fill_State({\cf22 "Encode"});\par
170 \par
171         std::cerr << {\cf22 "\\n State Filled."};\par
172         output_Scaffold();\par
173 \par
174         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
175         fill_Scaffold({\cf22 "Encode"});\par
176 \par
177         {\cf20 //To be removed later after testing.}\par
178         {\cf20 //output_Input();}\par
179         output_Scaffold();\par
180         output_Scaffold_Char();\par
181 \par
182         std::cout << {\cf22 "\\n\\n-- End Encoding --\\n\\n"};\par
183     \}\par
184 \par
185     {\cf20 //Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.}\par
186     {\cf20 //Assumes the CAN is setup.}\par
187     {\cf18 void} charge_Buffers({\cf18 int} p_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
188     \{\par
189 \par
190         tmp_Buffman.reset();\par
191 \par
192         tmp_Buffman.Input_Position = 0;\par
193 \par
194         tmp_Buffman.charge_Outputs();\par
195 \par
196         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < State_Depth; cou_T++)\par
197         \{\par
198             {\cf19 for} ({\cf18 int} cou_Input = 0; cou_Input < (State_Depth - cou_T); cou_Input++)\par
199             \{\par
200                 {\cf19 if} (Scaffold[cou_T][cou_Input] != NULL)\par
201                 \{\par
202                     {\cf20 //std::cout << "\\n\\n ~~++==++~~ Charging Node: CAN[cou_T][" << cou_Input << "]: " << Scaffold[cou_T][cou_Input] << " ~ " << Scaffold[cou_T][cou_Input]->NID;}\par
203 \par
204                     {\cf20 //tmp_Buffman.submit(Scaffold[0][cou_Input], (1.0));}\par
205                     {\cf19 if} (p_Style == -1)\par
206                     \{\par
207                         tmp_Buffman.submit(Scaffold[cou_T][cou_Input], (10.0));\par
208                     \}\par
209                     {\cf19 if} (p_Style == 1)\par
210                     \{\par
211                         tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_Input], (10.0), cou_Input);\par
212                     \}\par
213                     {\cf19 if} (p_Style == 2)\par
214                     \{\par
215                         {\cf20 //p_Leg specifies which leg to charge in this function, p_Legs[] being unused.}\par
216                         tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_Input], (10.0), p_Leg);\par
217                     \}\par
218                     {\cf19 if} (p_Style == 3)\par
219                     \{\par
220                         {\cf20 //p_Leg is used here as the count of elements in p_Legs[].}\par
221                         tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_Input], p_Leg, p_Legs, (10.0));\par
222                     \}\par
223                 \}\par
224             \}\par
225         \}\par
226 \par
227         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ Before ++++++++++++++++++++++++++++++ \\n\\n";}\par
228 \par
229         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
230 \par
231         tmp_Buffman.gather();\par
232 \par
233         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ After ++++++++++++++++++++++++++++++ \\n\\n";}\par
234 \par
235         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
236 \par
237         {\cf19 while} (tmp_Buffman.flg_Not_Done)\par
238         \{\par
239             {\cf20 //std::cout << "\\n\\n flg_Not_Done\\n";}\par
240 \par
241             tmp_Buffman.charge_Outputs();\par
242 \par
243             tmp_Buffman.gather();\par
244 \par
245             {\cf20 //tmp_Buffman.output_All_Buffers();}\par
246         \}\par
247 \par
248         {\cf20 //std::cout << "\\n\\n Completed:\\n";}\par
249 \par
250         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
251 \par
252         {\cf20 //std::cout << "\\n\\n Treetops:\\n";}\par
253         {\cf20 //tmp_Buffman.output_Treetops();}\par
254 \par
255         c_Charging_Linked_List * tmp_Current_LL = NULL;\par
256         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
257 \par
258         {\cf20 /*}\par
259 {\cf20         while (tmp_Current_LL != NULL)}\par
260 {\cf20         \{}\par
261 {\cf20             tmp_Current_LL->NID->bp_O();}\par
262 {\cf20 }\par
263 {\cf20             tmp_Current_LL = tmp_Current_LL->Next;}\par
264 {\cf20         \}}\par
265 {\cf20         */}\par
266     \}\par
267 \par
268     {\cf18 void} gather_Treetops()\par
269     \{\par
270         {\cf20 //---std::cout << "\\n\\n Gathering Treetops...";}\par
271 \par
272         c_Charging_Linked_List* tmp_Current_LL = NULL;\par
273         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
274 \par
275         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
276 \par
277         Output = {\cf17 new} c_Trace[tmp_Buffman.Treetops.Depth];\par
278         Output_Depth = tmp_Buffman.Treetops.Depth;\par
279 \par
280         {\cf18 int} tmp_Current_Index = 0;\par
281 \par
282         c_Linked_List_Handler tmp_Pattern;\par
283 \par
284         c_Linked_List* tmp_LL_Pat = NULL;\par
285 \par
286         {\cf19 while} (tmp_Current_LL != NULL)\par
287         \{\par
288             tmp_Pattern.reset();\par
289 \par
290             {\cf20 //Get the pattern into a linked list}\par
291             tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);\par
292 \par
293             std::cout << {\cf22 "\\n NID: "} << tmp_Current_LL->NID->NID;\par
294             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
295             {\cf20 //---tmp_Pattern.output();}\par
296 \par
297             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
298             {\cf20 //Copy the pattern over}\par
299             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
300 \par
301             {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
302 \par
303             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
304 \par
305             tmp_LL_Pat = tmp_Pattern.Root;\par
306 \par
307             {\cf20 //We can iterate through given we know how big the linked list is.}\par
308             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
309             \{\par
310                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
311                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
312             \}\par
313 \par
314             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->Current_Charge: " << tmp_Current_LL->NID->Current_Charge;}\par
315             {\cf20 //---std::cout << "\\n tmp_Current_LL->Charge: " << tmp_Current_LL->Charge;}\par
316             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->RC: " << tmp_Current_LL->NID->RC;}\par
317             Output[tmp_Current_Index].set_Charge(tmp_Current_LL->Charge);\par
318             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
319             Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);\par
320             Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);\par
321 \par
322             tmp_Current_LL = tmp_Current_LL->Next;\par
323             \par
324             {\cf20 //---Output[tmp_Current_Index].output(0);}\par
325             {\cf20 //---Output[tmp_Current_Index].output(1);}\par
326 \par
327             tmp_Current_Index++;\par
328         \}\par
329     \}\par
330 \par
331     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
332     {\cf18 void} gather_All_Traces()\par
333     \{\par
334         std::cout << {\cf22 "\\n\\n Gathering All Traces!!!"};\par
335 \par
336 \par
337 \par
338         c_Node* tmp_Node = NULL;\par
339         tmp_Node = NNet->Root;\par
340 \par
341         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
342 \par
343         Output = {\cf17 new} c_Trace[NNet->Node_Count];\par
344         Output_Depth = NNet->Node_Count;\par
345 \par
346         {\cf18 int} tmp_Current_Index = 0;\par
347 \par
348         c_Linked_List_Handler tmp_Pattern;\par
349 \par
350         c_Linked_List* tmp_LL_Pat = NULL;\par
351 \par
352         {\cf19 while} (tmp_Node != NULL)\par
353         \{\par
354             std::cout << {\cf22 "\\nNode ("} << tmp_Node->NID << {\cf22 ") "};\par
355             tmp_Node->bp_O();\par
356 \par
357 \par
358             tmp_Pattern.reset();\par
359 \par
360             {\cf20 //Get the pattern into a linked list}\par
361             tmp_Node->bp_Trace_O(&tmp_Pattern);\par
362 \par
363             std::cout << {\cf22 "\\n NID: "} << tmp_Node->NID;\par
364             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
365             tmp_Pattern.output();\par
366 \par
367             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
368             {\cf20 //Copy the pattern over}\par
369             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
370 \par
371             std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
372 \par
373             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
374 \par
375             tmp_LL_Pat = tmp_Pattern.Root;\par
376 \par
377             {\cf20 //We can iterate through given we know how big the linked list is.}\par
378             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
379             \{\par
380                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
381                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
382             \}\par
383 \par
384             std::cout << {\cf22 "\\n tmp_Current_LL->NID->Current_Charge: "} << tmp_Node->Current_Charge;\par
385             std::cout << {\cf22 "\\n tmp_Current_LL->NID->RC: "} << tmp_Node->RC;\par
386             Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
387             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
388             Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
389             Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
390 \par
391             Output[tmp_Current_Index].output(0);\par
392             Output[tmp_Current_Index].output(1);\par
393 \par
394             tmp_Current_Index++;\par
395 \par
396             tmp_Node = tmp_Node->Next;\par
397         \}\par
398     \}\par
399 \par
400     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
401     {\cf18 void} gather_Given_Trace(uint64_t p_NID)\par
402     \{\par
403         {\cf20 //---std::cout << "\\n\\n Gathering Given Trace " << p_NID << "...";}\par
404 \par
405         c_Node* tmp_Node = NULL;\par
406         tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);\par
407 \par
408         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
409 \par
410         Output = {\cf17 new} c_Trace[1];\par
411         Output_Depth = 1;\par
412 \par
413         {\cf18 int} tmp_Current_Index = 0;\par
414 \par
415         c_Linked_List_Handler tmp_Pattern;\par
416 \par
417         c_Linked_List* tmp_LL_Pat = NULL;\par
418 \par
419         tmp_Pattern.reset();\par
420 \par
421         {\cf20 //Get the pattern into a linked list}\par
422         tmp_Node->bp_Trace_O(&tmp_Pattern);\par
423 \par
424         {\cf20 //---std::cout << "\\n NID: " << tmp_Node->NID;}\par
425         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
426         {\cf20 //---tmp_Pattern.output();}\par
427 \par
428         {\cf20 //Copy the pattern over}\par
429         Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
430 \par
431         {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
432 \par
433         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
434 \par
435         tmp_LL_Pat = tmp_Pattern.Root;\par
436 \par
437         {\cf20 //We can iterate through given we know how big the linked list is.}\par
438         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
439         \{\par
440             Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
441             tmp_LL_Pat = tmp_LL_Pat->Next;\par
442         \}\par
443 \par
444         {\cf20 //---std::cout << "\\n tmp_Node->Current_Charge: " << tmp_Node->Current_Charge;}\par
445         {\cf20 //---std::cout << "\\n tmp_Node->RC: " << tmp_Node->RC;}\par
446         Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
447         {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
448         Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
449         Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
450 \par
451         {\cf20 //---Output[tmp_Current_Index].output(0);}\par
452         {\cf20 //---Output[tmp_Current_Index].output(1);}\par
453 \par
454         tmp_Current_Index++;\par
455     \}\par
456 \par
457 \par
458     {\cf20 //Fills out the NULLCAN, does not forcibly encode, and then charges the network.}\par
459     {\cf20 //Charging style determines leg charging. May move it to be a setting.}\par
460     {\cf20 //     -1: Charge by giving the input node the base charge, normal node charging.}\par
461     {\cf20 //      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].}\par
462     {\cf20 //      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.}\par
463     {\cf20 //       This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.}\par
464     {\cf18 void} query(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
465     \{\par
466         {\cf20 //Firstly we gather the inputly}\par
467         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
468 \par
469         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
470         setup_CAN_Scaffold();\par
471 \par
472         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
473         fill_State({\cf22 "Query"});\par
474 \par
475         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
476         fill_Scaffold({\cf22 "Query"});\par
477 \par
478         charge_Buffers(p_Charging_Style, p_Leg, p_Legs);\par
479 \par
480         gather_Treetops();\par
481 \par
482 \par
483         {\cf20 //To be removed later after testing.}\par
484         output_Input();\par
485         output_Scaffold();\par
486         output_Scaffold_Char();\par
487         output_Output();\par
488     \}\par
489 \par
490     {\cf20 //This allows for passing unordered sets of nodes}\par
491     {\cf18 void} submit_Set(uint64_t* p_Input, {\cf18 int} p_Depth)\par
492     \{\par
493         {\cf20 //Firstly we gather the inputly}\par
494         set_Input(p_Input, p_Depth);\par
495 \par
496         {\cf20 //We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.}\par
497         {\cf20 //The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.}\par
498         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
499         fill_State({\cf22 "Query"});\par
500 \par
501         {\cf20 //Then charge the buffers as normal.}\par
502         charge_Buffers();\par
503     \}\par
504 \par
505     {\cf20 //Gets the current treetop at the given index.}\par
506     c_Node* get_Treetop({\cf18 int} p_Index = -1)\par
507     \{\par
508         {\cf19 if} (State_Depth > 0)\par
509         \{\par
510             {\cf19 return} Scaffold[State_Depth - 1][0];\par
511         \}\par
512         {\cf19 return} NULL;\par
513     \}\par
514 \par
515     {\cf20 //Outputs the scaffold.}\par
516     {\cf18 void} output_Scaffold()\par
517     \{\par
518         std::cout << {\cf22 "\\n  --==   CAN_Scaffold   ==--"};\par
519         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < State_Depth; cou_T++)\par
520         \{\par
521             std::cout << {\cf22 "\\n <- Tier["} << cou_T << {\cf22 "] ->"};\par
522             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)\par
523             \{\par
524                 std::cout << {\cf22 " - ["} << cou_Index << {\cf22 "] "};\par
525                 {\cf19 if} (Scaffold[cou_T][cou_Index] != NULL) \{ std::cout << Scaffold[cou_T][cou_Index]->NID; \} {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
526             \}\par
527         \}\par
528     \}\par
529 \par
530     {\cf20 //Outputs the scaffold as character representing the address.}\par
531     {\cf18 void} output_Scaffold_Char()\par
532     \{\par
533         std::cout << {\cf22 "\\n\\n("} << {\cf17 this} << {\cf22 ")\\n"};\par
534         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < State_Depth; cou_T++)\par
535         \{\par
536             std::cout << {\cf22 "\\n"};\par
537             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (State_Depth - cou_T); cou_Index++)\par
538             \{\par
539                 std::cout << char(Scaffold[cou_T][cou_Index]);\par
540             \}\par
541         \}\par
542     \}\par
543 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_2D_Pyramid.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN_2D_Pyramid.h}
{\xe \v include/NT4/c_CAN_2D_Pyramid.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //This functions to create a trace where all legs are connected to one node.}\par
3 {\cf20 //Load up the input, hit encode(), boom you single permutation of all legs bound to that node.}\par
4 {\cf20 //Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good}\par
5 {\cf17 class }c_CAN_2D_Pyramid : {\cf17 public} c_Base_CAN\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Each CAN node is just a pointer to a node in the network.}\par
10     {\cf20 //Scaffold[Tier][X][Y]}\par
11     {\cf20 //Tier_Depth == where T = current tier: (Input_Depth - T)}\par
12     c_Node**** Scaffold;\par
13 \par
14     {\cf18 int} State_Depth_X; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
15     {\cf18 int} State_Depth_Y; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
16     {\cf18 int} Top_Tier; {\cf20 //Whichever dimension is lowest is the limiting factor on the height for nodes with the same leg count. For every dimsension that 'closes' you want to drop a lower dimensional construct on top.}\par
17     {\cf20 //The temporary buffer used during charging.}\par
18     c_Charging_Buffer tmp_Buffman;\par
19 \par
20     c_CAN_2D_Pyramid()\par
21     \{\par
22         NNet = NULL;\par
23 \par
24         Input.reset();\par
25         Output = NULL;\par
26         Output_Depth = 0;\par
27 \par
28         Scaffold = NULL;\par
29 \par
30         State_Depth_X = 0;\par
31         State_Depth_Y = 0;\par
32         State_Nodes_Index = 0;\par
33     \}\par
34 \par
35     ~c_CAN_2D_Pyramid()\par
36     \{\par
37         NNet = NULL;\par
38         reset_Scaffold();\par
39         reset_Input();\par
40     \}\par
41 \par
42     {\cf20 //Resets the CAN to NULL, and deletes the state tier + treetop.}\par
43     {\cf18 void} reset_Scaffold()\par
44     \{\par
45         {\cf19 if} (Scaffold != NULL)\par
46         \{\par
47             {\cf20 //For every tier}\par
48             {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
49             \{\par
50                 {\cf19 if} (Scaffold[cou_T] != NULL)\par
51                 \{\par
52                     {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
53                     \{\par
54                         {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
55                         \{\par
56                             {\cf20 //Make sure to NULL the scaffold first.}\par
57                             {\cf20 //DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.}\par
58                             Scaffold[cou_T][cou_X][cou_Y] = NULL;\par
59                         \}\par
60                         {\cf17 delete}[] Scaffold[cou_T][cou_X];\par
61                         Scaffold[cou_T][cou_X] = NULL;\par
62                     \}\par
63 \par
64                     {\cf17 delete}[] Scaffold[cou_T];\par
65                     Scaffold[cou_T] = NULL;\par
66                 \}\par
67             \}\par
68             {\cf17 delete}[] Scaffold;\par
69             Scaffold = NULL;\par
70         \}\par
71     \}\par
72 \par
73     {\cf20 //This sets up the actual CAN scaffold to use.}\par
74     {\cf20 //It assumes the input array is filled out, the size is based upon that array.}\par
75     {\cf18 void} setup_CAN_Scaffold()\par
76     \{\par
77         {\cf20 //Take it out back and put it down.}\par
78         reset_Scaffold();\par
79 \par
80         {\cf20 //Sizing her up!}\par
81         State_Depth_X = Input_2D.Depth[0];\par
82         State_Depth_Y = Input_2D.Depth[1];\par
83 \par
84         Top_Tier = State_Depth_X;\par
85         {\cf19 if} (State_Depth_Y < State_Depth_X) \{ Top_Tier = State_Depth_Y; \}\par
86 \par
87         {\cf20 //Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.}\par
88         Scaffold = {\cf17 new} c_Node *** [Top_Tier];\par
89 \par
90         {\cf20 //Through the tiers we brings beers.}\par
91         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
92         \{\par
93             {\cf20 //Through the steps Randolph Carter crept.}\par
94             Scaffold[cou_T] = {\cf17 new} c_Node ** [State_Depth_X - cou_T];\par
95 \par
96             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
97             \{\par
98                 Scaffold[cou_T][cou_X] = {\cf17 new} c_Node * [State_Depth_Y - cou_T];\par
99 \par
100                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
101                 \{\par
102                     Scaffold[cou_T][cou_X][cou_Y] = NULL;\par
103                 \}\par
104             \}\par
105         \}\par
106     \}\par
107 \par
108     {\cf20 //This fills the state tier by querying the node network.}\par
109     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
110     {\cf18 void} fill_State(std::string p_How = {\cf22 "Encode"})\par
111     \{\par
112         std::cout << {\cf22 "\\n Encoding with State_Nodes_Index: "} << State_Nodes_Index;\par
113         {\cf19 if} (p_How == {\cf22 "Encode"})\par
114         \{\par
115             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < State_Depth_X; cou_X++)\par
116             \{\par
117                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)\par
118                 \{\par
119                     {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
120                     {\cf20 //We have to make sure we request the correct state tree.}\par
121                     Scaffold[0][cou_X][cou_Y] = NNet->get_State_Node(State_Nodes_Index, Input_2D.get_Value(cou_X, cou_Y));\par
122                     Scaffold[0][cou_X][cou_Y]->RC++;\par
123 \par
124                     {\cf20 //If the node is also a treetop then set it to state/treetop.}\par
125                     {\cf19 if} ((Scaffold[0][cou_X][cou_Y]->Type == 2))\par
126                     \{\par
127                         Scaffold[0][cou_X][cou_Y]->Type = 3;\par
128                     \}\par
129                 \}\par
130             \}\par
131         \}\par
132         {\cf19 if} (p_How == {\cf22 "Query"})\par
133         \{\par
134             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < State_Depth_X; cou_X++)\par
135             \{\par
136                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)\par
137                 \{\par
138                     {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
139                     {\cf20 //We have to make sure we request the correct state tree.}\par
140                     Scaffold[0][cou_X][cou_Y] = NNet->does_State_Node_Exist(State_Nodes_Index, Input_2D.get_Value(cou_X, cou_Y));\par
141                 \}\par
142             \}\par
143         \}\par
144     \}\par
145 \par
146     {\cf20 //Just one node at the tippy top.}\par
147     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
148     {\cf18 void} fill_Scaffold(std::string p_How = {\cf22 "Encode"})\par
149     \{\par
150         {\cf19 if} ((State_Depth_X == 0) || (State_Depth_Y == 0))\par
151         \{\par
152             {\cf19 return};\par
153         \}\par
154 \par
155         {\cf20 //These hold the matrix we use to get the nodes to submit to the get upper tier node.}\par
156         c_Node* tmp_Nodes[4];\par
157 \par
158         {\cf19 for} ({\cf18 int} cou_T = 1; cou_T < Top_Tier; cou_T++)\par
159         \{\par
160             std::cerr << {\cf22 "\\n T: "} << cou_T;\par
161             {\cf20 //The extra -1 is so we don't step to the last node and reach into the void.}\par
162             {\cf20 /*}\par
163 {\cf20             We need to take them in a 2x2 grid.}\par
164 {\cf20             0[0, 0] 1[1, 0]}\par
165 {\cf20             2[0, 1] 3[1, 1]}\par
166 {\cf20             */}\par
167             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
168             \{\par
169                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
170                 \{\par
171                     std::cerr << {\cf22 " - "} << cou_X << {\cf22 ", "} << cou_Y;\par
172 \par
173                     {\cf20 //Get the legs for the node, the 2x2}\par
174                     tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y];\par
175                     tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X + 1][cou_Y];\par
176                     tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X][cou_Y + 1];\par
177                     tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1];\par
178 \par
179                     {\cf19 if} (p_How == {\cf22 "Encode"})\par
180                     \{\par
181                         {\cf20 //We request a node that links 4 nodes together.}\par
182                         Scaffold[cou_T][cou_X][cou_Y] = NNet->get_Upper_Tier_Node(tmp_Nodes, 4, 1);\par
183                         Scaffold[cou_T][cou_X][cou_Y]->RC++;\par
184                     \}\par
185                     {\cf19 if} (p_How == {\cf22 "Query"})\par
186                     \{\par
187                         {\cf20 //We request a node that links the entire state tier together, but do not create them.}\par
188                         Scaffold[cou_T][cou_X][cou_Y] = NNet->does_Upper_Tier_Connection_Exist(tmp_Nodes, 4);\par
189                     \}\par
190                 \}\par
191             \}\par
192         \}\par
193 \par
194         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - Top_Tier - 1); cou_X++)\par
195         \{\par
196             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - Top_Tier - 1); cou_Y++)\par
197             \{\par
198                 Scaffold[Top_Tier - 1][cou_X][cou_Y]->Type = 2;\par
199             \}\par
200         \}\par
201     \}\par
202 \par
203     {\cf20 //Encodes a single trace, forcibly.}\par
204     {\cf18 void} encode(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0)\par
205     \{\par
206         std::cout << {\cf22 "\\n\\n<<-- Begin Encoding -->>\\n\\n"};\par
207 \par
208         {\cf20 //Firstly we gather the inputly}\par
209         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
210 \par
211         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
212         setup_CAN_Scaffold();\par
213 \par
214         output_Scaffold();\par
215 \par
216         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
217         fill_State({\cf22 "Encode"});\par
218 \par
219         std::cerr << {\cf22 "\\n State Filled."};\par
220         output_Scaffold();\par
221 \par
222         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
223         fill_Scaffold({\cf22 "Encode"});\par
224 \par
225         {\cf20 //To be removed later after testing.}\par
226         {\cf20 //output_Input();}\par
227         output_Scaffold();\par
228         output_Scaffold_Char();\par
229 \par
230         std::cout << {\cf22 "\\n\\n-- End Encoding --\\n\\n"};\par
231     \}\par
232 \par
233     {\cf20 //Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.}\par
234     {\cf20 //Assumes the CAN is setup.}\par
235     {\cf18 void} charge_Buffers({\cf18 int} p_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
236     \{\par
237 \par
238         tmp_Buffman.reset();\par
239 \par
240         tmp_Buffman.Input_Position = 0;\par
241 \par
242         tmp_Buffman.charge_Outputs();\par
243 \par
244         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
245         \{\par
246             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
247             \{\par
248                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
249                 \{\par
250                     {\cf19 if} (Scaffold[cou_T][cou_X][cou_Y] != NULL)\par
251                     \{\par
252                         {\cf20 //std::cout << "\\n\\n ~~++==++~~ Charging Node: CAN[cou_T][" << cou_Input << "]: " << Scaffold[cou_T][cou_Input] << " ~ " << Scaffold[cou_T][cou_Input]->NID;}\par
253 \par
254                         {\cf20 //tmp_Buffman.submit(Scaffold[0][cou_Input], (1.0));}\par
255                         {\cf19 if} (p_Style == -1)\par
256                         \{\par
257                             tmp_Buffman.submit(Scaffold[cou_T][cou_X][cou_Y], (10.0));\par
258                         \}\par
259                         {\cf19 if} (p_Style == 1)\par
260                         \{\par
261                             {\cf20 //This style not used in pyramidal.}\par
262                             {\cf20 //tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (10.0), cou_Input);}\par
263                         \}\par
264                         {\cf19 if} (p_Style == 2)\par
265                         \{\par
266                             {\cf20 //p_Leg specifies which leg to charge in this function, p_Legs[] being unused.}\par
267                             tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (10.0), p_Leg);\par
268                         \}\par
269                         {\cf19 if} (p_Style == 3)\par
270                         \{\par
271                             {\cf20 //p_Leg is used here as the count of elements in p_Legs[].}\par
272                             tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_X][cou_Y], p_Leg, p_Legs, (10.0));\par
273                         \}\par
274                     \}\par
275                 \}\par
276             \}\par
277         \}\par
278 \par
279         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ Before ++++++++++++++++++++++++++++++ \\n\\n";}\par
280 \par
281         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
282 \par
283         tmp_Buffman.gather();\par
284 \par
285         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ After ++++++++++++++++++++++++++++++ \\n\\n";}\par
286 \par
287         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
288 \par
289         {\cf19 while} (tmp_Buffman.flg_Not_Done)\par
290         \{\par
291             {\cf20 //std::cout << "\\n\\n flg_Not_Done\\n";}\par
292 \par
293             tmp_Buffman.charge_Outputs();\par
294 \par
295             tmp_Buffman.gather();\par
296 \par
297             {\cf20 //tmp_Buffman.output_All_Buffers();}\par
298         \}\par
299 \par
300         {\cf20 //std::cout << "\\n\\n Completed:\\n";}\par
301 \par
302         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
303 \par
304         {\cf20 //std::cout << "\\n\\n Treetops:\\n";}\par
305         {\cf20 //tmp_Buffman.output_Treetops();}\par
306 \par
307         c_Charging_Linked_List * tmp_Current_LL = NULL;\par
308         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
309 \par
310         {\cf20 /*}\par
311 {\cf20         while (tmp_Current_LL != NULL)}\par
312 {\cf20         \{}\par
313 {\cf20             tmp_Current_LL->NID->bp_O();}\par
314 {\cf20 }\par
315 {\cf20             tmp_Current_LL = tmp_Current_LL->Next;}\par
316 {\cf20         \}}\par
317 {\cf20         */}\par
318     \}\par
319 \par
320     {\cf18 void} gather_Treetops()\par
321     \{\par
322         {\cf20 //---std::cout << "\\n\\n Gathering Treetops...";}\par
323 \par
324         c_Charging_Linked_List* tmp_Current_LL = NULL;\par
325         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
326 \par
327         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
328 \par
329         Output = {\cf17 new} c_Trace[tmp_Buffman.Treetops.Depth];\par
330         Output_Depth = tmp_Buffman.Treetops.Depth;\par
331 \par
332         {\cf18 int} tmp_Current_Index = 0;\par
333 \par
334         c_Linked_List_Handler tmp_Pattern;\par
335 \par
336         c_Linked_List* tmp_LL_Pat = NULL;\par
337 \par
338         {\cf19 while} (tmp_Current_LL != NULL)\par
339         \{\par
340             tmp_Pattern.reset();\par
341 \par
342             {\cf20 //Get the pattern into a linked list}\par
343             tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);\par
344 \par
345             std::cout << {\cf22 "\\n NID: "} << tmp_Current_LL->NID->NID;\par
346             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
347             {\cf20 //---tmp_Pattern.output();}\par
348 \par
349             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
350             {\cf20 //Copy the pattern over}\par
351             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
352 \par
353             {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
354 \par
355             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
356 \par
357             tmp_LL_Pat = tmp_Pattern.Root;\par
358 \par
359             {\cf20 //We can iterate through given we know how big the linked list is.}\par
360             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
361             \{\par
362                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
363                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
364             \}\par
365 \par
366             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->Current_Charge: " << tmp_Current_LL->NID->Current_Charge;}\par
367             {\cf20 //---std::cout << "\\n tmp_Current_LL->Charge: " << tmp_Current_LL->Charge;}\par
368             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->RC: " << tmp_Current_LL->NID->RC;}\par
369             Output[tmp_Current_Index].set_Charge(tmp_Current_LL->Charge);\par
370             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
371             Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);\par
372             Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);\par
373 \par
374             tmp_Current_LL = tmp_Current_LL->Next;\par
375             \par
376             {\cf20 //---Output[tmp_Current_Index].output(0);}\par
377             {\cf20 //---Output[tmp_Current_Index].output(1);}\par
378 \par
379             tmp_Current_Index++;\par
380         \}\par
381     \}\par
382 \par
383     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
384     {\cf18 void} gather_All_Traces()\par
385     \{\par
386         std::cout << {\cf22 "\\n\\n Gathering All Traces!!!"};\par
387 \par
388 \par
389 \par
390         c_Node* tmp_Node = NULL;\par
391         tmp_Node = NNet->Root;\par
392 \par
393         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
394 \par
395         Output = {\cf17 new} c_Trace[NNet->Node_Count];\par
396         Output_Depth = NNet->Node_Count;\par
397 \par
398         {\cf18 int} tmp_Current_Index = 0;\par
399 \par
400         c_Linked_List_Handler tmp_Pattern;\par
401 \par
402         c_Linked_List* tmp_LL_Pat = NULL;\par
403 \par
404         {\cf19 while} (tmp_Node != NULL)\par
405         \{\par
406             std::cout << {\cf22 "\\nNode ("} << tmp_Node->NID << {\cf22 ") "};\par
407             tmp_Node->bp_O();\par
408 \par
409 \par
410             tmp_Pattern.reset();\par
411 \par
412             {\cf20 //Get the pattern into a linked list}\par
413             tmp_Node->bp_Trace_O(&tmp_Pattern);\par
414 \par
415             std::cout << {\cf22 "\\n NID: "} << tmp_Node->NID;\par
416             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
417             tmp_Pattern.output();\par
418 \par
419             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
420             {\cf20 //Copy the pattern over}\par
421             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
422 \par
423             std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
424 \par
425             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
426 \par
427             tmp_LL_Pat = tmp_Pattern.Root;\par
428 \par
429             {\cf20 //We can iterate through given we know how big the linked list is.}\par
430             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
431             \{\par
432                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
433                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
434             \}\par
435 \par
436             std::cout << {\cf22 "\\n tmp_Current_LL->NID->Current_Charge: "} << tmp_Node->Current_Charge;\par
437             std::cout << {\cf22 "\\n tmp_Current_LL->NID->RC: "} << tmp_Node->RC;\par
438             Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
439             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
440             Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
441             Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
442 \par
443             Output[tmp_Current_Index].output(0);\par
444             Output[tmp_Current_Index].output(1);\par
445 \par
446             tmp_Current_Index++;\par
447 \par
448             tmp_Node = tmp_Node->Next;\par
449         \}\par
450     \}\par
451 \par
452     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
453     {\cf18 void} gather_Given_Trace(uint64_t p_NID)\par
454     \{\par
455         {\cf20 //---std::cout << "\\n\\n Gathering Given Trace " << p_NID << "...";}\par
456 \par
457         c_Node* tmp_Node = NULL;\par
458         tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);\par
459 \par
460         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
461 \par
462         Output = {\cf17 new} c_Trace[1];\par
463         Output_Depth = 1;\par
464 \par
465         {\cf18 int} tmp_Current_Index = 0;\par
466 \par
467         c_Linked_List_Handler tmp_Pattern;\par
468 \par
469         c_Linked_List* tmp_LL_Pat = NULL;\par
470 \par
471         tmp_Pattern.reset();\par
472 \par
473         {\cf20 //Get the pattern into a linked list}\par
474         tmp_Node->bp_Trace_O(&tmp_Pattern);\par
475 \par
476         {\cf20 //---std::cout << "\\n NID: " << tmp_Node->NID;}\par
477         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
478         {\cf20 //---tmp_Pattern.output();}\par
479 \par
480         {\cf20 //Copy the pattern over}\par
481         Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
482 \par
483         {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
484 \par
485         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
486 \par
487         tmp_LL_Pat = tmp_Pattern.Root;\par
488 \par
489         {\cf20 //We can iterate through given we know how big the linked list is.}\par
490         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
491         \{\par
492             Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
493             tmp_LL_Pat = tmp_LL_Pat->Next;\par
494         \}\par
495 \par
496         {\cf20 //---std::cout << "\\n tmp_Node->Current_Charge: " << tmp_Node->Current_Charge;}\par
497         {\cf20 //---std::cout << "\\n tmp_Node->RC: " << tmp_Node->RC;}\par
498         Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
499         {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
500         Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
501         Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
502 \par
503         {\cf20 //---Output[tmp_Current_Index].output(0);}\par
504         {\cf20 //---Output[tmp_Current_Index].output(1);}\par
505 \par
506         tmp_Current_Index++;\par
507     \}\par
508 \par
509 \par
510     {\cf20 //Fills out the NULLCAN, does not forcibly encode, and then charges the network.}\par
511     {\cf20 //Charging style determines leg charging. May move it to be a setting.}\par
512     {\cf20 //     -1: Charge by giving the input node the base charge, normal node charging.}\par
513     {\cf20 //      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].}\par
514     {\cf20 //      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.}\par
515     {\cf20 //       This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.}\par
516     {\cf18 void} query(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
517     \{\par
518         {\cf20 //Firstly we gather the inputly}\par
519         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
520 \par
521         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
522         setup_CAN_Scaffold();\par
523 \par
524         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
525         fill_State({\cf22 "Query"});\par
526 \par
527         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
528         fill_Scaffold({\cf22 "Query"});\par
529 \par
530         charge_Buffers(p_Charging_Style, p_Leg, p_Legs);\par
531 \par
532         gather_Treetops();\par
533 \par
534 \par
535         {\cf20 //To be removed later after testing.}\par
536         output_Input();\par
537         output_Scaffold();\par
538         output_Scaffold_Char();\par
539         output_Output();\par
540     \}\par
541 \par
542     {\cf20 //This allows for passing unordered sets of nodes}\par
543     {\cf18 void} submit_Set(uint64_t* p_Input, {\cf18 int} p_Depth)\par
544     \{\par
545         {\cf20 //Firstly we gather the inputly}\par
546         set_Input(p_Input, p_Depth);\par
547 \par
548         {\cf20 //We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.}\par
549         {\cf20 //The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.}\par
550         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
551         fill_State({\cf22 "Query"});\par
552 \par
553         {\cf20 //Then charge the buffers as normal.}\par
554         charge_Buffers();\par
555     \}\par
556 \par
557     {\cf20 //Gets the current treetop at the given index.}\par
558     c_Node* get_Treetop({\cf18 int} p_Index = -1)\par
559     \{\par
560         {\cf19 if} (Top_Tier > 0)\par
561         \{\par
562             {\cf19 if} (p_Index == -1)\par
563             \{\par
564                 {\cf19 return} Scaffold[Top_Tier - 1][0][0];\par
565             \}\par
566 \par
567             {\cf20 //This construct is 2d which means at the highest point of 4 legged nodes before it turns to 2D then the dimension which is longer than the pyramid is tall will have treetops in a 1D line, like if you took a pyramid of Gaza and click-dragged it sideways with tracers on.}\par
568             {\cf19 if} (State_Depth_X >= Top_Tier)\par
569             \{\par
570                 {\cf19 return} Scaffold[Top_Tier - 1][p_Index][0];\par
571             \}\par
572             {\cf20 //>= in case X == Y and we don't want fall-through on a perfect one.}\par
573             {\cf19 if} (State_Depth_Y >= Top_Tier)\par
574             \{\par
575                 {\cf19 return} Scaffold[Top_Tier - 1][0][p_Index];\par
576             \}\par
577         \}\par
578         {\cf19 return} NULL;\par
579     \}\par
580 \par
581     {\cf20 //Outputs the scaffold.}\par
582     {\cf18 void} output_Scaffold()\par
583     \{\par
584         std::cout << {\cf22 "\\n  --==   CAN_Scaffold   ==--"};\par
585 \par
586         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
587         \{\par
588             std::cout << {\cf22 "\\n <- Tier["} << cou_T << {\cf22 "] ->"};\par
589             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
590             \{\par
591                 std::cout << {\cf22 "\\n"};\par
592                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
593                 \{\par
594                     std::cout << {\cf22 " - ["} << cou_X << {\cf22 ", "} << cou_Y << {\cf22 "] "};\par
595                     {\cf19 if} (Scaffold[cou_T][cou_X][cou_Y] != NULL) \{ std::cout << Scaffold[cou_T][cou_X][cou_Y]->NID; \}\par
596                     {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
597                 \}\par
598             \}\par
599         \}\par
600     \}\par
601 \par
602     {\cf20 //Outputs the scaffold as character representing the address.}\par
603     {\cf18 void} output_Scaffold_Char()\par
604     \{\par
605         std::cout << {\cf22 "\\n("} << {\cf17 this} << {\cf22 ")\\n"};\par
606         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
607         \{\par
608             std::cout << {\cf22 "\\n"};\par
609             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
610             \{\par
611                 std::cout << {\cf22 "\\n["};\par
612                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
613                 \{\par
614                     std::cout << char(Scaffold[cou_T][cou_X][cou_Y]);\par
615                 \}\par
616                 std::cout << {\cf22 "]"};\par
617             \}\par
618         \}\par
619     \}\par
620 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_3D_Pyramid.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN_3D_Pyramid.h}
{\xe \v include/NT4/c_CAN_3D_Pyramid.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //This functions to create a trace where all legs are connected to one node.}\par
3 {\cf20 //Load up the input, hit encode(), boom you single permutation of all legs bound to that node.}\par
4 {\cf20 //Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good}\par
5 {\cf17 class }c_CAN_3D_Pyramid : {\cf17 public} c_Base_CAN\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Each CAN node is just a pointer to a node in the network.}\par
10     {\cf20 //Scaffold[Tier][X][Y]}\par
11     {\cf20 //Tier_Depth == where T = current tier: (Input_Depth - T)}\par
12     c_Node***** Scaffold;\par
13 \par
14     {\cf18 int} State_Depth_X; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
15     {\cf18 int} State_Depth_Y; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
16     {\cf18 int} State_Depth_Z; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
17     {\cf18 int} Top_Tier; {\cf20 //Whichever dimension is lowest is the limiting factor on the height for nodes with the same leg count. For every dimsension that 'closes' you want to drop a lower dimensional construct on top.}\par
18     {\cf20 //The temporary buffer used during charging.}\par
19     c_Charging_Buffer tmp_Buffman;\par
20 \par
21     c_CAN_3D_Pyramid()\par
22     \{\par
23         NNet = NULL;\par
24 \par
25         Input.reset();\par
26         Output = NULL;\par
27         Output_Depth = 0;\par
28 \par
29         Scaffold = NULL;\par
30 \par
31         State_Depth_X = 0;\par
32         State_Depth_Y = 0;\par
33         State_Depth_Z = 0;\par
34         State_Nodes_Index = 0;\par
35     \}\par
36 \par
37     ~c_CAN_3D_Pyramid()\par
38     \{\par
39         NNet = NULL;\par
40         reset_Scaffold();\par
41         reset_Input();\par
42     \}\par
43 \par
44     {\cf20 //Resets the CAN to NULL, and deletes the state tier + treetop.}\par
45     {\cf18 void} reset_Scaffold()\par
46     \{\par
47         {\cf19 if} (Scaffold != NULL)\par
48         \{\par
49             {\cf20 //For every tier}\par
50             {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
51             \{\par
52                 {\cf19 if} (Scaffold[cou_T] != NULL)\par
53                 \{\par
54                     {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
55                     \{\par
56                         {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
57                         \{\par
58                             {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
59                             \{\par
60                                 {\cf20 //Make sure to NULL the scaffold first.}\par
61                                 {\cf20 //DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.}\par
62                                 Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NULL;\par
63                             \}\par
64                             {\cf17 delete}[] Scaffold[cou_T][cou_X][cou_Y];\par
65                             Scaffold[cou_T][cou_X][cou_Y] = NULL;\par
66                         \}\par
67                         {\cf17 delete}[] Scaffold[cou_T][cou_X];\par
68                         Scaffold[cou_T][cou_X] = NULL;\par
69                     \}\par
70                     {\cf17 delete}[] Scaffold[cou_T];\par
71                     Scaffold[cou_T] = NULL;\par
72                 \}\par
73             \}\par
74             {\cf17 delete}[] Scaffold;\par
75             Scaffold = NULL;\par
76         \}\par
77     \}\par
78 \par
79     {\cf20 //This sets up the actual CAN scaffold to use.}\par
80     {\cf20 //It assumes the input array is filled out, the size is based upon that array.}\par
81     {\cf18 void} setup_CAN_Scaffold()\par
82     \{\par
83         {\cf20 //Take it out back and put it down.}\par
84         reset_Scaffold();\par
85 \par
86         {\cf20 //Sizing her up!}\par
87         State_Depth_X = Input_3D.Depth[0];\par
88         State_Depth_Y = Input_3D.Depth[1];\par
89         State_Depth_Z = Input_3D.Depth[2];\par
90 \par
91         std::cout << {\cf22 "\\n State_Depth_X: "} << State_Depth_X;\par
92         std::cout << {\cf22 "\\n State_Depth_Y: "} << State_Depth_Y;\par
93         std::cout << {\cf22 "\\n State_Depth_Z: "} << State_Depth_Y;\par
94 \par
95         {\cf20 //Find the shortest side to set the top tier to as that is when the symbol will reduce in dimension.}\par
96         Top_Tier = State_Depth_X;\par
97         {\cf19 if} (State_Depth_Y < Top_Tier) \{ Top_Tier = State_Depth_Y; \}\par
98         {\cf19 if} (State_Depth_Z < Top_Tier) \{ Top_Tier = State_Depth_Z; \}\par
99 \par
100         {\cf20 //Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.}\par
101         Scaffold = {\cf17 new} c_Node **** [Top_Tier];\par
102 \par
103         {\cf20 //Through the tiers we brings beers.}\par
104         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
105         \{\par
106             {\cf20 //Through the steps Randolph Carter crept.}\par
107             Scaffold[cou_T] = {\cf17 new} c_Node *** [State_Depth_X - cou_T];\par
108 \par
109             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
110             \{\par
111                 Scaffold[cou_T][cou_X] = {\cf17 new} c_Node ** [State_Depth_Y - cou_T];\par
112 \par
113                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
114                 \{\par
115                     Scaffold[cou_T][cou_X][cou_Y] = {\cf17 new} c_Node *[State_Depth_Z - cou_T];\par
116 \par
117                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
118                     \{\par
119                         Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NULL;\par
120                     \}\par
121                 \}\par
122             \}\par
123         \}\par
124     \}\par
125 \par
126     {\cf20 //This fills the state tier by querying the node network.}\par
127     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
128     {\cf18 void} fill_State(std::string p_How = {\cf22 "Encode"})\par
129     \{\par
130         std::cout << {\cf22 "\\n Encoding with State_Nodes_Index: "} << State_Nodes_Index;\par
131         {\cf19 if} (p_How == {\cf22 "Encode"})\par
132         \{\par
133             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < State_Depth_X; cou_X++)\par
134             \{\par
135                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)\par
136                 \{\par
137                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < State_Depth_Z; cou_Z++)\par
138                     \{\par
139                         {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
140                         {\cf20 //We have to make sure we request the correct state tree.}\par
141                         Scaffold[0][cou_X][cou_Y][cou_Z] = NNet->get_State_Node(State_Nodes_Index, Input_3D.get_Value(cou_X, cou_Y, cou_Z));\par
142                         Scaffold[0][cou_X][cou_Y][cou_Z]->RC++;\par
143 \par
144                         {\cf20 //If the node is also a treetop then set it to state/treetop.}\par
145                         {\cf19 if} ((Scaffold[0][cou_X][cou_Y][cou_Z]->Type == 2))\par
146                         \{\par
147                             Scaffold[0][cou_X][cou_Y][cou_Z]->Type = 3;\par
148                         \}\par
149                     \}\par
150                 \}\par
151             \}\par
152         \}\par
153         {\cf19 if} (p_How == {\cf22 "Query"})\par
154         \{\par
155             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < State_Depth_X; cou_X++)\par
156             \{\par
157                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)\par
158                 \{\par
159                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < State_Depth_Z; cou_Z++)\par
160                     \{\par
161                         {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
162                         {\cf20 //We have to make sure we request the correct state tree.}\par
163                         Scaffold[0][cou_X][cou_Y][cou_Z] = NNet->does_State_Node_Exist(State_Nodes_Index, Input_3D.get_Value(cou_X, cou_Y, cou_Z));\par
164                     \}\par
165                 \}\par
166             \}\par
167         \}\par
168     \}\par
169 \par
170     {\cf20 //Just one node at the tippy top.}\par
171     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
172     {\cf18 void} fill_Scaffold(std::string p_How = {\cf22 "Encode"})\par
173     \{\par
174         {\cf19 if} ((State_Depth_X == 0) || (State_Depth_Y == 0) || (State_Depth_Z == 0))\par
175         \{\par
176             {\cf19 return};\par
177         \}\par
178 \par
179         {\cf20 //These hold the matrix we use to get the nodes to submit to the get upper tier node.}\par
180         {\cf20 //It takes 8 points to define a cube, each point is a sub-symbol, so we gather the 8 sub-symbols and abstract them.}\par
181         c_Node* tmp_Nodes[8];\par
182 \par
183         {\cf19 for} ({\cf18 int} cou_T = 1; cou_T < Top_Tier; cou_T++)\par
184         \{\par
185             std::cerr << {\cf22 "\\n T: "} << cou_T;\par
186             {\cf20 //The extra -1 is so we don't step to the last node and reach into the void.}\par
187             {\cf20 /*}\par
188 {\cf20             We need to take them in a 2x2x2 block my dude don't be rude or crude unless you've got a job to Derude.}\par
189 {\cf20             }\par
190 {\cf20             0[0, 0, 0] 1[1, 0, 0]}\par
191 {\cf20             2[0, 1, 0] 3[1, 1, 0]}\par
192 {\cf20 }\par
193 {\cf20             4[0, 0, 1] 5[1, 0, 1]}\par
194 {\cf20             6[0, 1, 1] 7[1, 1, 1]}\par
195 {\cf20 }\par
196 {\cf20             */}\par
197             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
198             \{\par
199                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
200                 \{\par
201                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
202                     \{\par
203                         std::cerr << {\cf22 " - "} << cou_X << {\cf22 ", "} << cou_Y << {\cf22 ", "} << cou_Z;\par
204 \par
205                         {\cf20 //Get the legs for the node, the 2x2}\par
206                         tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z];\par
207                         tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z];\par
208                         tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z];\par
209                         tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z];\par
210 \par
211                         tmp_Nodes[4] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z + 1];\par
212                         tmp_Nodes[5] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z + 1];\par
213                         tmp_Nodes[6] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z + 1];\par
214                         tmp_Nodes[7] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z + 1];\par
215 \par
216                         {\cf19 if} (p_How == {\cf22 "Encode"})\par
217                         \{\par
218                             {\cf20 //We request a node that links 4 nodes together.}\par
219                             Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NNet->get_Upper_Tier_Node(tmp_Nodes, 8, 1);\par
220                             Scaffold[cou_T][cou_X][cou_Y][cou_Z]->RC++;\par
221                         \}\par
222                         {\cf19 if} (p_How == {\cf22 "Query"})\par
223                         \{\par
224                             {\cf20 //We request a node that links the entire state tier together, but do not create them.}\par
225                             Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NNet->does_Upper_Tier_Connection_Exist(tmp_Nodes, 8);\par
226                         \}\par
227                     \}\par
228                 \}\par
229             \}\par
230         \}\par
231 \par
232         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - Top_Tier - 1); cou_X++)\par
233         \{\par
234             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - Top_Tier - 1); cou_Y++)\par
235             \{\par
236                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - Top_Tier - 1); cou_Z++)\par
237                 \{\par
238                     Scaffold[Top_Tier - 1][cou_X][cou_Y][cou_Z]->Type = 2;\par
239                 \}\par
240             \}\par
241         \}\par
242     \}\par
243 \par
244     {\cf20 //Encodes a single trace, forcibly.}\par
245     {\cf20 //Arguments no longer used, need to remove during refactoria.}\par
246     {\cf18 void} encode(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0)\par
247     \{\par
248         std::cout << {\cf22 "\\n\\n<<-- Begin Encoding 3D -->>\\n\\n"};\par
249 \par
250         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
251         setup_CAN_Scaffold();\par
252 \par
253         output_Scaffold();\par
254 \par
255         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
256         fill_State({\cf22 "Encode"});\par
257 \par
258         std::cerr << {\cf22 "\\n State Filled."};\par
259         output_Scaffold();\par
260 \par
261         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
262         fill_Scaffold({\cf22 "Encode"});\par
263 \par
264         {\cf20 //To be removed later after testing.}\par
265         {\cf20 //output_Input();}\par
266         output_Scaffold();\par
267         output_Scaffold_Char();\par
268 \par
269         std::cout << {\cf22 "\\n\\n-- End Encoding --\\n\\n"};\par
270     \}\par
271 \par
272     {\cf20 //Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.}\par
273     {\cf20 //Assumes the CAN is setup.}\par
274     {\cf18 void} charge_Buffers({\cf18 int} p_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
275     \{\par
276 \par
277         tmp_Buffman.reset();\par
278 \par
279         tmp_Buffman.Input_Position = 0;\par
280 \par
281         tmp_Buffman.charge_Outputs();\par
282 \par
283         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
284         \{\par
285             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
286             \{\par
287                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
288                 \{\par
289                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
290                     \{\par
291                         {\cf19 if} (Scaffold[cou_T][cou_X][cou_Y][cou_Z] != NULL)\par
292                         \{\par
293                             {\cf20 //std::cout << "\\n\\n ~~++==++~~ Charging Node: CAN[cou_T][" << cou_Input << "]: " << Scaffold[cou_T][cou_Input] << " ~ " << Scaffold[cou_T][cou_Input]->NID;}\par
294 \par
295                             {\cf20 //tmp_Buffman.submit(Scaffold[0][cou_Input], (1.0));}\par
296                             {\cf19 if} (p_Style == -1)\par
297                             \{\par
298                                 tmp_Buffman.submit(Scaffold[cou_T][cou_X][cou_Y][cou_Z], (10.0));\par
299                             \}\par
300                             {\cf19 if} (p_Style == 1)\par
301                             \{\par
302                                 {\cf20 //This style not used in pyramidal.}\par
303                                 {\cf20 //tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (10.0), cou_Input);}\par
304                             \}\par
305                             {\cf19 if} (p_Style == 2)\par
306                             \{\par
307                                 {\cf20 //p_Leg specifies which leg to charge in this function, p_Legs[] being unused.}\par
308                                 tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y][cou_Z], (10.0), p_Leg);\par
309                             \}\par
310                             {\cf19 if} (p_Style == 3)\par
311                             \{\par
312                                 {\cf20 //p_Leg is used here as the count of elements in p_Legs[].}\par
313                                 tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_X][cou_Y][cou_Z], p_Leg, p_Legs, (10.0));\par
314                             \}\par
315                         \}\par
316                     \}\par
317                 \}\par
318             \}\par
319         \}\par
320 \par
321         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ Before ++++++++++++++++++++++++++++++ \\n\\n";}\par
322 \par
323         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
324 \par
325         tmp_Buffman.gather();\par
326 \par
327         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ After ++++++++++++++++++++++++++++++ \\n\\n";}\par
328 \par
329         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
330 \par
331         {\cf19 while} (tmp_Buffman.flg_Not_Done)\par
332         \{\par
333             {\cf20 //std::cout << "\\n\\n flg_Not_Done\\n";}\par
334 \par
335             tmp_Buffman.charge_Outputs();\par
336 \par
337             tmp_Buffman.gather();\par
338 \par
339             {\cf20 //tmp_Buffman.output_All_Buffers();}\par
340         \}\par
341 \par
342         {\cf20 //std::cout << "\\n\\n Completed:\\n";}\par
343 \par
344         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
345 \par
346         {\cf20 //std::cout << "\\n\\n Treetops:\\n";}\par
347         {\cf20 //tmp_Buffman.output_Treetops();}\par
348 \par
349         c_Charging_Linked_List * tmp_Current_LL = NULL;\par
350         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
351 \par
352         {\cf20 /*}\par
353 {\cf20         while (tmp_Current_LL != NULL)}\par
354 {\cf20         \{}\par
355 {\cf20             tmp_Current_LL->NID->bp_O();}\par
356 {\cf20 }\par
357 {\cf20             tmp_Current_LL = tmp_Current_LL->Next;}\par
358 {\cf20         \}}\par
359 {\cf20         */}\par
360     \}\par
361 \par
362     {\cf18 void} gather_Treetops()\par
363     \{\par
364         {\cf20 //---std::cout << "\\n\\n Gathering Treetops...";}\par
365 \par
366         c_Charging_Linked_List* tmp_Current_LL = NULL;\par
367         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
368 \par
369         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
370 \par
371         Output = {\cf17 new} c_Trace[tmp_Buffman.Treetops.Depth];\par
372         Output_Depth = tmp_Buffman.Treetops.Depth;\par
373 \par
374         {\cf18 int} tmp_Current_Index = 0;\par
375 \par
376         c_Linked_List_Handler tmp_Pattern;\par
377 \par
378         c_Linked_List* tmp_LL_Pat = NULL;\par
379 \par
380         {\cf19 while} (tmp_Current_LL != NULL)\par
381         \{\par
382             tmp_Pattern.reset();\par
383 \par
384             {\cf20 //Get the pattern into a linked list}\par
385             tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);\par
386 \par
387             std::cout << {\cf22 "\\n NID: "} << tmp_Current_LL->NID->NID;\par
388             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
389             {\cf20 //---tmp_Pattern.output();}\par
390 \par
391             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
392             {\cf20 //Copy the pattern over}\par
393             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
394 \par
395             {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
396 \par
397             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
398 \par
399             tmp_LL_Pat = tmp_Pattern.Root;\par
400 \par
401             {\cf20 //We can iterate through given we know how big the linked list is.}\par
402             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
403             \{\par
404                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
405                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
406             \}\par
407 \par
408             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->Current_Charge: " << tmp_Current_LL->NID->Current_Charge;}\par
409             {\cf20 //---std::cout << "\\n tmp_Current_LL->Charge: " << tmp_Current_LL->Charge;}\par
410             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->RC: " << tmp_Current_LL->NID->RC;}\par
411             Output[tmp_Current_Index].set_Charge(tmp_Current_LL->Charge);\par
412             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
413             Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);\par
414             Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);\par
415 \par
416             tmp_Current_LL = tmp_Current_LL->Next;\par
417             \par
418             {\cf20 //---Output[tmp_Current_Index].output(0);}\par
419             {\cf20 //---Output[tmp_Current_Index].output(1);}\par
420 \par
421             tmp_Current_Index++;\par
422         \}\par
423     \}\par
424 \par
425     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
426     {\cf18 void} gather_All_Traces()\par
427     \{\par
428         std::cout << {\cf22 "\\n\\n Gathering All Traces!!!"};\par
429 \par
430 \par
431 \par
432         c_Node* tmp_Node = NULL;\par
433         tmp_Node = NNet->Root;\par
434 \par
435         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
436 \par
437         Output = {\cf17 new} c_Trace[NNet->Node_Count];\par
438         Output_Depth = NNet->Node_Count;\par
439 \par
440         {\cf18 int} tmp_Current_Index = 0;\par
441 \par
442         c_Linked_List_Handler tmp_Pattern;\par
443 \par
444         c_Linked_List* tmp_LL_Pat = NULL;\par
445 \par
446         {\cf19 while} (tmp_Node != NULL)\par
447         \{\par
448             std::cout << {\cf22 "\\nNode ("} << tmp_Node->NID << {\cf22 ") "};\par
449             tmp_Node->bp_O();\par
450 \par
451 \par
452             tmp_Pattern.reset();\par
453 \par
454             {\cf20 //Get the pattern into a linked list}\par
455             tmp_Node->bp_Trace_O(&tmp_Pattern);\par
456 \par
457             std::cout << {\cf22 "\\n NID: "} << tmp_Node->NID;\par
458             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
459             tmp_Pattern.output();\par
460 \par
461             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
462             {\cf20 //Copy the pattern over}\par
463             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
464 \par
465             std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
466 \par
467             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
468 \par
469             tmp_LL_Pat = tmp_Pattern.Root;\par
470 \par
471             {\cf20 //We can iterate through given we know how big the linked list is.}\par
472             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
473             \{\par
474                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
475                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
476             \}\par
477 \par
478             std::cout << {\cf22 "\\n tmp_Current_LL->NID->Current_Charge: "} << tmp_Node->Current_Charge;\par
479             std::cout << {\cf22 "\\n tmp_Current_LL->NID->RC: "} << tmp_Node->RC;\par
480             Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
481             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
482             Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
483             Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
484 \par
485             Output[tmp_Current_Index].output(0);\par
486             Output[tmp_Current_Index].output(1);\par
487 \par
488             tmp_Current_Index++;\par
489 \par
490             tmp_Node = tmp_Node->Next;\par
491         \}\par
492     \}\par
493 \par
494     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
495     {\cf18 void} gather_Given_Trace(uint64_t p_NID)\par
496     \{\par
497         {\cf20 //---std::cout << "\\n\\n Gathering Given Trace " << p_NID << "...";}\par
498 \par
499         c_Node* tmp_Node = NULL;\par
500         tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);\par
501 \par
502         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
503 \par
504         Output = {\cf17 new} c_Trace[1];\par
505         Output_Depth = 1;\par
506 \par
507         {\cf18 int} tmp_Current_Index = 0;\par
508 \par
509         c_Linked_List_Handler tmp_Pattern;\par
510 \par
511         c_Linked_List* tmp_LL_Pat = NULL;\par
512 \par
513         tmp_Pattern.reset();\par
514 \par
515         {\cf20 //Get the pattern into a linked list}\par
516         tmp_Node->bp_Trace_O(&tmp_Pattern);\par
517 \par
518         {\cf20 //---std::cout << "\\n NID: " << tmp_Node->NID;}\par
519         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
520         {\cf20 //---tmp_Pattern.output();}\par
521 \par
522         {\cf20 //Copy the pattern over}\par
523         Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
524 \par
525         {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
526 \par
527         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
528 \par
529         tmp_LL_Pat = tmp_Pattern.Root;\par
530 \par
531         {\cf20 //We can iterate through given we know how big the linked list is.}\par
532         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
533         \{\par
534             Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
535             tmp_LL_Pat = tmp_LL_Pat->Next;\par
536         \}\par
537 \par
538         {\cf20 //---std::cout << "\\n tmp_Node->Current_Charge: " << tmp_Node->Current_Charge;}\par
539         {\cf20 //---std::cout << "\\n tmp_Node->RC: " << tmp_Node->RC;}\par
540         Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
541         {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
542         Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
543         Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
544 \par
545         {\cf20 //---Output[tmp_Current_Index].output(0);}\par
546         {\cf20 //---Output[tmp_Current_Index].output(1);}\par
547 \par
548         tmp_Current_Index++;\par
549     \}\par
550 \par
551 \par
552     {\cf20 //Fills out the NULLCAN, does not forcibly encode, and then charges the network.}\par
553     {\cf20 //Charging style determines leg charging. May move it to be a setting.}\par
554     {\cf20 //     -1: Charge by giving the input node the base charge, normal node charging.}\par
555     {\cf20 //      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].}\par
556     {\cf20 //      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.}\par
557     {\cf20 //       This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.}\par
558     {\cf18 void} query(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
559     \{\par
560         {\cf20 //Firstly we gather the inputly}\par
561         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
562 \par
563         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
564         setup_CAN_Scaffold();\par
565 \par
566         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
567         fill_State({\cf22 "Query"});\par
568 \par
569         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
570         fill_Scaffold({\cf22 "Query"});\par
571 \par
572         charge_Buffers(p_Charging_Style, p_Leg, p_Legs);\par
573 \par
574         gather_Treetops();\par
575 \par
576 \par
577         {\cf20 //To be removed later after testing.}\par
578         output_Input();\par
579         output_Scaffold();\par
580         output_Scaffold_Char();\par
581         output_Output();\par
582     \}\par
583 \par
584     {\cf20 //This allows for passing unordered sets of nodes}\par
585     {\cf18 void} submit_Set(uint64_t* p_Input, {\cf18 int} p_Depth)\par
586     \{\par
587         {\cf20 //Firstly we gather the inputly}\par
588         set_Input(p_Input, p_Depth);\par
589 \par
590         {\cf20 //We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.}\par
591         {\cf20 //The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.}\par
592         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
593         fill_State({\cf22 "Query"});\par
594 \par
595         {\cf20 //Then charge the buffers as normal.}\par
596         charge_Buffers();\par
597     \}\par
598 \par
599     {\cf20 //Gets the current treetop at the given index.}\par
600     c_Node* get_Treetop({\cf18 int} p_Index = -1)\par
601     \{\par
602         {\cf19 if} (Top_Tier > 0)\par
603         \{\par
604             {\cf19 if} (p_Index == -1)\par
605             \{\par
606                 {\cf19 return} Scaffold[Top_Tier - 1][0][0][0];\par
607             \}\par
608 \par
609             {\cf20 //This construct is 4d which means at the highest point of 8 legged nodes before it turns to 2D then the dimension which is longer than the pyramid is tall will have treetops in a 1D line, like if you took a pyramid of Gaza and click-dragged it sideways with tracers on. Same with this 3D object except describing dragging a 3D 0bject is not intuitive to monke brayne.}\par
610             {\cf19 if} (State_Depth_X >= Top_Tier)\par
611             \{\par
612                 {\cf19 return} Scaffold[Top_Tier - 1][p_Index][0][0];\par
613             \}\par
614             {\cf20 //>= in case X == Y and we don't want fall-through on a perfect one.}\par
615             {\cf19 if} (State_Depth_Y >= Top_Tier)\par
616             \{\par
617                 {\cf19 return} Scaffold[Top_Tier - 1][0][p_Index][0];\par
618             \}\par
619             {\cf20 //>= in case X == Y == Z and we don't want fall-through on a perfect one.}\par
620             {\cf19 if} (State_Depth_Z >= Top_Tier)\par
621             \{\par
622                 {\cf19 return} Scaffold[Top_Tier - 1][0][0][p_Index];\par
623             \}\par
624         \}\par
625         {\cf19 return} NULL;\par
626     \}\par
627 \par
628     {\cf20 //Outputs the scaffold.}\par
629     {\cf18 void} output_Scaffold()\par
630     \{\par
631         std::cout << {\cf22 "\\n  --==   CAN_Scaffold   ==--"};\par
632 \par
633         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
634         \{\par
635             std::cout << {\cf22 "\\n <- Tier["} << cou_T << {\cf22 "] ->"};\par
636             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
637             \{\par
638                 std::cout << {\cf22 "\\n"};\par
639                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
640                 \{\par
641                     std::cout << {\cf22 "\\n"};\par
642                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
643                     \{\par
644                         std::cout << {\cf22 " [("} << cou_X << {\cf22 ", "} << cou_Y << {\cf22 ", "} << cou_Z << {\cf22 ") "};\par
645                         {\cf19 if} (Scaffold[cou_T][cou_X][cou_Y][cou_Z] != NULL) \{ std::cout << Scaffold[cou_T][cou_X][cou_Y][cou_Z]->NID; \} {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
646                         std::cout << {\cf22 "]"};\par
647                     \}\par
648                 \}\par
649             \}\par
650         \}\par
651     \}\par
652 \par
653     {\cf20 //Outputs the scaffold as character representing the address.}\par
654     {\cf18 void} output_Scaffold_Char()\par
655     \{\par
656         std::cout << {\cf22 "\\n("} << {\cf17 this} << {\cf22 ")\\n"};\par
657         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
658         \{\par
659             std::cout << {\cf22 "\\n"};\par
660             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
661             \{\par
662                 std::cout << {\cf22 "\\n"};\par
663                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
664                 \{\par
665                     std::cout << {\cf22 "\\n["};\par
666                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
667                     \{\par
668                         std::cout << char(Scaffold[cou_T][cou_X][cou_Y][cou_Z]);\par
669                     \}\par
670                     std::cout << {\cf22 "]"};\par
671                 \}\par
672             \}\par
673         \}\par
674     \}\par
675 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_7D_Pyramid.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN_7D_Pyramid.h}
{\xe \v include/NT4/c_CAN_7D_Pyramid.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //This functions to create a trace where all legs are connected to one node.}\par
3 {\cf20 //Load up the input, hit encode(), boom you single permutation of all legs bound to that node.}\par
4 {\cf20 //Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good}\par
5 {\cf17 class }c_CAN_3D_Pyramid : {\cf17 public} c_Base_CAN\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Each CAN node is just a pointer to a node in the network.}\par
10     {\cf20 //Scaffold[Tier][X][Y]}\par
11     {\cf20 //Tier_Depth == where T = current tier: (Input_Depth - T)}\par
12     c_Node********* Scaffold;\par
13 \par
14     {\cf18 int} State_Depth_X; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
15     {\cf18 int} State_Depth_Y; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
16     {\cf18 int} State_Depth_Z; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
17     {\cf18 int} State_Depth_W; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
18     {\cf18 int} State_Depth_A; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
19     {\cf18 int} State_Depth_B; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
20     {\cf18 int} State_Depth_C; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
21     {\cf18 int} Top_Tier; {\cf20 //Whichever dimension is lowest is the limiting factor on the height for nodes with the same leg count. For every dimsension that 'closes' you want to drop a lower dimensional construct on top.}\par
22     {\cf20 //The temporary buffer used during charging.}\par
23     c_Charging_Buffer tmp_Buffman;\par
24 \par
25     c_CAN_3D_Pyramid()\par
26     \{\par
27         NNet = NULL;\par
28 \par
29         Input.reset();\par
30         Output = NULL;\par
31         Output_Depth = 0;\par
32 \par
33         Scaffold = NULL;\par
34 \par
35         State_Depth_X = 0;\par
36         State_Depth_Y = 0;\par
37         State_Depth_Z = 0;\par
38         State_Depth_W = 0;\par
39         State_Depth_A = 0;\par
40         State_Depth_B = 0;\par
41         State_Depth_C = 0;\par
42         State_Nodes_Index = 0;\par
43     \}\par
44 \par
45     ~c_CAN_3D_Pyramid()\par
46     \{\par
47         NNet = NULL;\par
48         reset_Scaffold();\par
49         reset_Input();\par
50     \}\par
51 \par
52     {\cf20 //Resets the CAN to NULL, and deletes the state tier + treetop.}\par
53     {\cf18 void} reset_Scaffold()\par
54     \{\par
55         {\cf19 if} (Scaffold != NULL)\par
56         \{\par
57             {\cf20 //For every tier}\par
58             {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
59             \{\par
60                 {\cf19 if} (Scaffold[cou_T] != NULL)\par
61                 \{\par
62                     {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
63                     \{\par
64                         {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
65                         \{\par
66                             {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
67                             \{\par
68                             {\cf19 for} ({\cf18 int} cou_W = 0; cou_W < (State_Depth_W - cou_T); cou_W++)\par
69                             \{\par
70                             {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < (State_Depth_A - cou_T); cou_A++)\par
71                             \{\par
72                             {\cf19 for} ({\cf18 int} cou_B = 0; cou_B < (State_Depth_B - cou_T); cou_B++)\par
73                             \{\par
74                             {\cf19 for} ({\cf18 int} cou_C = 0; cou_C < (State_Depth_C - cou_T); cou_C++)\par
75                             \{\par
76                             {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
77                             \{\par
78                             {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
79                             \{\par
80                                 {\cf20 //Make sure to NULL the scaffold first.}\par
81                                 {\cf20 //DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.}\par
82                                 Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NULL;\par
83                             \}\par
84                             {\cf17 delete}[] Scaffold[cou_T][cou_X][cou_Y];\par
85                             Scaffold[cou_T][cou_X][cou_Y] = NULL;\par
86                         \}\par
87                         {\cf17 delete}[] Scaffold[cou_T][cou_X];\par
88                         Scaffold[cou_T][cou_X] = NULL;\par
89                     \}\par
90                     {\cf17 delete}[] Scaffold[cou_T];\par
91                     Scaffold[cou_T] = NULL;\par
92                 \}\par
93             \}\par
94             {\cf17 delete}[] Scaffold;\par
95             Scaffold = NULL;\par
96         \}\par
97     \}\par
98 \par
99     {\cf20 //This sets up the actual CAN scaffold to use.}\par
100     {\cf20 //It assumes the input array is filled out, the size is based upon that array.}\par
101     {\cf18 void} setup_CAN_Scaffold()\par
102     \{\par
103         {\cf20 //Take it out back and put it down.}\par
104         reset_Scaffold();\par
105 \par
106         {\cf20 //Sizing her up!}\par
107         State_Depth_X = Input_3D.Depth[0];\par
108         State_Depth_Y = Input_3D.Depth[1];\par
109         State_Depth_Z = Input_3D.Depth[2];\par
110 \par
111         std::cout << {\cf22 "\\n State_Depth_X: "} << State_Depth_X;\par
112         std::cout << {\cf22 "\\n State_Depth_Y: "} << State_Depth_Y;\par
113         std::cout << {\cf22 "\\n State_Depth_Z: "} << State_Depth_Y;\par
114 \par
115         {\cf20 //Find the shortest side to set the top tier to as that is when the symbol will reduce in dimension.}\par
116         Top_Tier = State_Depth_X;\par
117         {\cf19 if} (State_Depth_Y < Top_Tier) \{ Top_Tier = State_Depth_Y; \}\par
118         {\cf19 if} (State_Depth_Z < Top_Tier) \{ Top_Tier = State_Depth_Z; \}\par
119 \par
120         {\cf20 //Define the tiers, the number of tiers to hold a pyramid is equal to the depth of the pattern it represents.}\par
121         Scaffold = {\cf17 new} c_Node **** [Top_Tier];\par
122 \par
123         {\cf20 //Through the tiers we brings beers.}\par
124         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
125         \{\par
126             {\cf20 //Through the steps Randolph Carter crept.}\par
127             Scaffold[cou_T] = {\cf17 new} c_Node *** [State_Depth_X - cou_T];\par
128 \par
129             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
130             \{\par
131                 Scaffold[cou_T][cou_X] = {\cf17 new} c_Node ** [State_Depth_Y - cou_T];\par
132 \par
133                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
134                 \{\par
135                     Scaffold[cou_T][cou_X][cou_Y] = {\cf17 new} c_Node *[State_Depth_Z - cou_T];\par
136 \par
137                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
138                     \{\par
139                         Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NULL;\par
140                     \}\par
141                 \}\par
142             \}\par
143         \}\par
144     \}\par
145 \par
146     {\cf20 //This fills the state tier by querying the node network.}\par
147     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
148     {\cf18 void} fill_State(std::string p_How = {\cf22 "Encode"})\par
149     \{\par
150         std::cout << {\cf22 "\\n Encoding with State_Nodes_Index: "} << State_Nodes_Index;\par
151         {\cf19 if} (p_How == {\cf22 "Encode"})\par
152         \{\par
153             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < State_Depth_X; cou_X++)\par
154             \{\par
155                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)\par
156                 \{\par
157                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < State_Depth_Z; cou_Z++)\par
158                     \{\par
159                         {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
160                         {\cf20 //We have to make sure we request the correct state tree.}\par
161                         Scaffold[0][cou_X][cou_Y][cou_Z] = NNet->get_State_Node(State_Nodes_Index, Input_3D.get_Value(cou_X, cou_Y, cou_Z));\par
162                         Scaffold[0][cou_X][cou_Y][cou_Z]->RC++;\par
163 \par
164                         {\cf20 //If the node is also a treetop then set it to state/treetop.}\par
165                         {\cf19 if} ((Scaffold[0][cou_X][cou_Y][cou_Z]->Type == 2))\par
166                         \{\par
167                             Scaffold[0][cou_X][cou_Y][cou_Z]->Type = 3;\par
168                         \}\par
169                     \}\par
170                 \}\par
171             \}\par
172         \}\par
173         {\cf19 if} (p_How == {\cf22 "Query"})\par
174         \{\par
175             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < State_Depth_X; cou_X++)\par
176             \{\par
177                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < State_Depth_Y; cou_Y++)\par
178                 \{\par
179                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < State_Depth_Z; cou_Z++)\par
180                     \{\par
181                         {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
182                         {\cf20 //We have to make sure we request the correct state tree.}\par
183                         Scaffold[0][cou_X][cou_Y][cou_Z] = NNet->does_State_Node_Exist(State_Nodes_Index, Input_3D.get_Value(cou_X, cou_Y, cou_Z));\par
184                     \}\par
185                 \}\par
186             \}\par
187         \}\par
188     \}\par
189 \par
190     {\cf20 //Just one node at the tippy top.}\par
191     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
192     {\cf18 void} fill_Scaffold(std::string p_How = {\cf22 "Encode"})\par
193     \{\par
194         {\cf19 if} ((State_Depth_X == 0) || (State_Depth_Y == 0) || (State_Depth_Z == 0))\par
195         \{\par
196             {\cf19 return};\par
197         \}\par
198 \par
199         {\cf20 //These hold the matrix we use to get the nodes to submit to the get upper tier node.}\par
200         {\cf20 //It takes 8 points to define a cube, each point is a sub-symbol, so we gather the 8 sub-symbols and abstract them.}\par
201         c_Node* tmp_Nodes[8];\par
202 \par
203         {\cf19 for} ({\cf18 int} cou_T = 1; cou_T < Top_Tier; cou_T++)\par
204         \{\par
205             std::cerr << {\cf22 "\\n T: "} << cou_T;\par
206             {\cf20 //The extra -1 is so we don't step to the last node and reach into the void.}\par
207             {\cf20 /*}\par
208 {\cf20             We need to take them in a 2x2x2 block my dude don't be rude or crude unless you've got a job to Derude.}\par
209 {\cf20             }\par
210 {\cf20             0[0, 0, 0] 1[1, 0, 0]}\par
211 {\cf20             2[0, 1, 0] 3[1, 1, 0]}\par
212 {\cf20 }\par
213 {\cf20             4[0, 0, 1] 5[1, 0, 1]}\par
214 {\cf20             6[0, 1, 1] 7[1, 1, 1]}\par
215 {\cf20 }\par
216 {\cf20             */}\par
217             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
218             \{\par
219                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
220                 \{\par
221                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
222                     \{\par
223                         std::cerr << {\cf22 " - "} << cou_X << {\cf22 ", "} << cou_Y << {\cf22 ", "} << cou_Z;\par
224 \par
225                         {\cf20 //Get the legs for the node, the 2x2}\par
226                         tmp_Nodes[0] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z];\par
227                         tmp_Nodes[1] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z];\par
228                         tmp_Nodes[2] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z];\par
229                         tmp_Nodes[3] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z];\par
230 \par
231                         tmp_Nodes[4] = Scaffold[cou_T - 1][cou_X][cou_Y][cou_Z + 1];\par
232                         tmp_Nodes[5] = Scaffold[cou_T - 1][cou_X + 1][cou_Y][cou_Z + 1];\par
233                         tmp_Nodes[6] = Scaffold[cou_T - 1][cou_X][cou_Y + 1][cou_Z + 1];\par
234                         tmp_Nodes[7] = Scaffold[cou_T - 1][cou_X + 1][cou_Y + 1][cou_Z + 1];\par
235 \par
236                         {\cf19 if} (p_How == {\cf22 "Encode"})\par
237                         \{\par
238                             {\cf20 //We request a node that links 4 nodes together.}\par
239                             Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NNet->get_Upper_Tier_Node(tmp_Nodes, 8, 1);\par
240                             Scaffold[cou_T][cou_X][cou_Y][cou_Z]->RC++;\par
241                         \}\par
242                         {\cf19 if} (p_How == {\cf22 "Query"})\par
243                         \{\par
244                             {\cf20 //We request a node that links the entire state tier together, but do not create them.}\par
245                             Scaffold[cou_T][cou_X][cou_Y][cou_Z] = NNet->does_Upper_Tier_Connection_Exist(tmp_Nodes, 8);\par
246                         \}\par
247                     \}\par
248                 \}\par
249             \}\par
250         \}\par
251 \par
252         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - Top_Tier - 1); cou_X++)\par
253         \{\par
254             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - Top_Tier - 1); cou_Y++)\par
255             \{\par
256                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - Top_Tier - 1); cou_Z++)\par
257                 \{\par
258                     Scaffold[Top_Tier - 1][cou_X][cou_Y][cou_Z]->Type = 2;\par
259                 \}\par
260             \}\par
261         \}\par
262     \}\par
263 \par
264     {\cf20 //Encodes a single trace, forcibly.}\par
265     {\cf20 //Arguments no longer used, need to remove during refactoria.}\par
266     {\cf18 void} encode(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0)\par
267     \{\par
268         std::cout << {\cf22 "\\n\\n<<-- Begin Encoding 3D -->>\\n\\n"};\par
269 \par
270         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
271         setup_CAN_Scaffold();\par
272 \par
273         output_Scaffold();\par
274 \par
275         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
276         fill_State({\cf22 "Encode"});\par
277 \par
278         std::cerr << {\cf22 "\\n State Filled."};\par
279         output_Scaffold();\par
280 \par
281         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
282         fill_Scaffold({\cf22 "Encode"});\par
283 \par
284         {\cf20 //To be removed later after testing.}\par
285         {\cf20 //output_Input();}\par
286         output_Scaffold();\par
287         output_Scaffold_Char();\par
288 \par
289         std::cout << {\cf22 "\\n\\n-- End Encoding --\\n\\n"};\par
290     \}\par
291 \par
292     {\cf20 //Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.}\par
293     {\cf20 //Assumes the CAN is setup.}\par
294     {\cf18 void} charge_Buffers({\cf18 int} p_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
295     \{\par
296 \par
297         tmp_Buffman.reset();\par
298 \par
299         tmp_Buffman.Input_Position = 0;\par
300 \par
301         tmp_Buffman.charge_Outputs();\par
302 \par
303         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
304         \{\par
305             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
306             \{\par
307                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
308                 \{\par
309                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
310                     \{\par
311                         {\cf19 if} (Scaffold[cou_T][cou_X][cou_Y][cou_Z] != NULL)\par
312                         \{\par
313                             {\cf20 //std::cout << "\\n\\n ~~++==++~~ Charging Node: CAN[cou_T][" << cou_Input << "]: " << Scaffold[cou_T][cou_Input] << " ~ " << Scaffold[cou_T][cou_Input]->NID;}\par
314 \par
315                             {\cf20 //tmp_Buffman.submit(Scaffold[0][cou_Input], (1.0));}\par
316                             {\cf19 if} (p_Style == -1)\par
317                             \{\par
318                                 tmp_Buffman.submit(Scaffold[cou_T][cou_X][cou_Y][cou_Z], (10.0));\par
319                             \}\par
320                             {\cf19 if} (p_Style == 1)\par
321                             \{\par
322                                 {\cf20 //This style not used in pyramidal.}\par
323                                 {\cf20 //tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y], (10.0), cou_Input);}\par
324                             \}\par
325                             {\cf19 if} (p_Style == 2)\par
326                             \{\par
327                                 {\cf20 //p_Leg specifies which leg to charge in this function, p_Legs[] being unused.}\par
328                                 tmp_Buffman.charge_Given_Leg(Scaffold[cou_T][cou_X][cou_Y][cou_Z], (10.0), p_Leg);\par
329                             \}\par
330                             {\cf19 if} (p_Style == 3)\par
331                             \{\par
332                                 {\cf20 //p_Leg is used here as the count of elements in p_Legs[].}\par
333                                 tmp_Buffman.charge_Given_Legs(Scaffold[cou_T][cou_X][cou_Y][cou_Z], p_Leg, p_Legs, (10.0));\par
334                             \}\par
335                         \}\par
336                     \}\par
337                 \}\par
338             \}\par
339         \}\par
340 \par
341         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ Before ++++++++++++++++++++++++++++++ \\n\\n";}\par
342 \par
343         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
344 \par
345         tmp_Buffman.gather();\par
346 \par
347         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ After ++++++++++++++++++++++++++++++ \\n\\n";}\par
348 \par
349         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
350 \par
351         {\cf19 while} (tmp_Buffman.flg_Not_Done)\par
352         \{\par
353             {\cf20 //std::cout << "\\n\\n flg_Not_Done\\n";}\par
354 \par
355             tmp_Buffman.charge_Outputs();\par
356 \par
357             tmp_Buffman.gather();\par
358 \par
359             {\cf20 //tmp_Buffman.output_All_Buffers();}\par
360         \}\par
361 \par
362         {\cf20 //std::cout << "\\n\\n Completed:\\n";}\par
363 \par
364         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
365 \par
366         {\cf20 //std::cout << "\\n\\n Treetops:\\n";}\par
367         {\cf20 //tmp_Buffman.output_Treetops();}\par
368 \par
369         c_Charging_Linked_List * tmp_Current_LL = NULL;\par
370         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
371 \par
372         {\cf20 /*}\par
373 {\cf20         while (tmp_Current_LL != NULL)}\par
374 {\cf20         \{}\par
375 {\cf20             tmp_Current_LL->NID->bp_O();}\par
376 {\cf20 }\par
377 {\cf20             tmp_Current_LL = tmp_Current_LL->Next;}\par
378 {\cf20         \}}\par
379 {\cf20         */}\par
380     \}\par
381 \par
382     {\cf18 void} gather_Treetops()\par
383     \{\par
384         {\cf20 //---std::cout << "\\n\\n Gathering Treetops...";}\par
385 \par
386         c_Charging_Linked_List* tmp_Current_LL = NULL;\par
387         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
388 \par
389         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
390 \par
391         Output = {\cf17 new} c_Trace[tmp_Buffman.Treetops.Depth];\par
392         Output_Depth = tmp_Buffman.Treetops.Depth;\par
393 \par
394         {\cf18 int} tmp_Current_Index = 0;\par
395 \par
396         c_Linked_List_Handler tmp_Pattern;\par
397 \par
398         c_Linked_List* tmp_LL_Pat = NULL;\par
399 \par
400         {\cf19 while} (tmp_Current_LL != NULL)\par
401         \{\par
402             tmp_Pattern.reset();\par
403 \par
404             {\cf20 //Get the pattern into a linked list}\par
405             tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);\par
406 \par
407             std::cout << {\cf22 "\\n NID: "} << tmp_Current_LL->NID->NID;\par
408             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
409             {\cf20 //---tmp_Pattern.output();}\par
410 \par
411             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
412             {\cf20 //Copy the pattern over}\par
413             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
414 \par
415             {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
416 \par
417             {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
418 \par
419             tmp_LL_Pat = tmp_Pattern.Root;\par
420 \par
421             {\cf20 //We can iterate through given we know how big the linked list is.}\par
422             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
423             \{\par
424                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
425                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
426             \}\par
427 \par
428             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->Current_Charge: " << tmp_Current_LL->NID->Current_Charge;}\par
429             {\cf20 //---std::cout << "\\n tmp_Current_LL->Charge: " << tmp_Current_LL->Charge;}\par
430             {\cf20 //---std::cout << "\\n tmp_Current_LL->NID->RC: " << tmp_Current_LL->NID->RC;}\par
431             Output[tmp_Current_Index].set_Charge(tmp_Current_LL->Charge);\par
432             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
433             Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);\par
434             Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);\par
435 \par
436             tmp_Current_LL = tmp_Current_LL->Next;\par
437             \par
438             {\cf20 //---Output[tmp_Current_Index].output(0);}\par
439             {\cf20 //---Output[tmp_Current_Index].output(1);}\par
440 \par
441             tmp_Current_Index++;\par
442         \}\par
443     \}\par
444 \par
445     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
446     {\cf18 void} gather_All_Traces()\par
447     \{\par
448         std::cout << {\cf22 "\\n\\n Gathering All Traces!!!"};\par
449 \par
450 \par
451 \par
452         c_Node* tmp_Node = NULL;\par
453         tmp_Node = NNet->Root;\par
454 \par
455         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
456 \par
457         Output = {\cf17 new} c_Trace[NNet->Node_Count];\par
458         Output_Depth = NNet->Node_Count;\par
459 \par
460         {\cf18 int} tmp_Current_Index = 0;\par
461 \par
462         c_Linked_List_Handler tmp_Pattern;\par
463 \par
464         c_Linked_List* tmp_LL_Pat = NULL;\par
465 \par
466         {\cf19 while} (tmp_Node != NULL)\par
467         \{\par
468             std::cout << {\cf22 "\\nNode ("} << tmp_Node->NID << {\cf22 ") "};\par
469             tmp_Node->bp_O();\par
470 \par
471 \par
472             tmp_Pattern.reset();\par
473 \par
474             {\cf20 //Get the pattern into a linked list}\par
475             tmp_Node->bp_Trace_O(&tmp_Pattern);\par
476 \par
477             std::cout << {\cf22 "\\n NID: "} << tmp_Node->NID;\par
478             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
479             tmp_Pattern.output();\par
480 \par
481             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
482             {\cf20 //Copy the pattern over}\par
483             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
484 \par
485             std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
486 \par
487             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
488 \par
489             tmp_LL_Pat = tmp_Pattern.Root;\par
490 \par
491             {\cf20 //We can iterate through given we know how big the linked list is.}\par
492             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
493             \{\par
494                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
495                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
496             \}\par
497 \par
498             std::cout << {\cf22 "\\n tmp_Current_LL->NID->Current_Charge: "} << tmp_Node->Current_Charge;\par
499             std::cout << {\cf22 "\\n tmp_Current_LL->NID->RC: "} << tmp_Node->RC;\par
500             Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
501             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
502             Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
503             Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
504 \par
505             Output[tmp_Current_Index].output(0);\par
506             Output[tmp_Current_Index].output(1);\par
507 \par
508             tmp_Current_Index++;\par
509 \par
510             tmp_Node = tmp_Node->Next;\par
511         \}\par
512     \}\par
513 \par
514     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
515     {\cf18 void} gather_Given_Trace(uint64_t p_NID)\par
516     \{\par
517         {\cf20 //---std::cout << "\\n\\n Gathering Given Trace " << p_NID << "...";}\par
518 \par
519         c_Node* tmp_Node = NULL;\par
520         tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);\par
521 \par
522         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
523 \par
524         Output = {\cf17 new} c_Trace[1];\par
525         Output_Depth = 1;\par
526 \par
527         {\cf18 int} tmp_Current_Index = 0;\par
528 \par
529         c_Linked_List_Handler tmp_Pattern;\par
530 \par
531         c_Linked_List* tmp_LL_Pat = NULL;\par
532 \par
533         tmp_Pattern.reset();\par
534 \par
535         {\cf20 //Get the pattern into a linked list}\par
536         tmp_Node->bp_Trace_O(&tmp_Pattern);\par
537 \par
538         {\cf20 //---std::cout << "\\n NID: " << tmp_Node->NID;}\par
539         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
540         {\cf20 //---tmp_Pattern.output();}\par
541 \par
542         {\cf20 //Copy the pattern over}\par
543         Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
544 \par
545         {\cf20 //---std::cout << "\\n Output[" << tmp_Current_Index << "].Depth: " << Output[tmp_Current_Index].Depth;}\par
546 \par
547         {\cf20 //---std::cout << "\\n tmp_Pattern.Depth: " << tmp_Pattern.Depth;}\par
548 \par
549         tmp_LL_Pat = tmp_Pattern.Root;\par
550 \par
551         {\cf20 //We can iterate through given we know how big the linked list is.}\par
552         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
553         \{\par
554             Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
555             tmp_LL_Pat = tmp_LL_Pat->Next;\par
556         \}\par
557 \par
558         {\cf20 //---std::cout << "\\n tmp_Node->Current_Charge: " << tmp_Node->Current_Charge;}\par
559         {\cf20 //---std::cout << "\\n tmp_Node->RC: " << tmp_Node->RC;}\par
560         Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
561         {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
562         Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
563         Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
564 \par
565         {\cf20 //---Output[tmp_Current_Index].output(0);}\par
566         {\cf20 //---Output[tmp_Current_Index].output(1);}\par
567 \par
568         tmp_Current_Index++;\par
569     \}\par
570 \par
571 \par
572     {\cf20 //Fills out the NULLCAN, does not forcibly encode, and then charges the network.}\par
573     {\cf20 //Charging style determines leg charging. May move it to be a setting.}\par
574     {\cf20 //     -1: Charge by giving the input node the base charge, normal node charging.}\par
575     {\cf20 //      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].}\par
576     {\cf20 //      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.}\par
577     {\cf20 //       This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.}\par
578     {\cf18 void} query(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
579     \{\par
580         {\cf20 //Firstly we gather the inputly}\par
581         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
582 \par
583         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
584         setup_CAN_Scaffold();\par
585 \par
586         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
587         fill_State({\cf22 "Query"});\par
588 \par
589         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
590         fill_Scaffold({\cf22 "Query"});\par
591 \par
592         charge_Buffers(p_Charging_Style, p_Leg, p_Legs);\par
593 \par
594         gather_Treetops();\par
595 \par
596 \par
597         {\cf20 //To be removed later after testing.}\par
598         output_Input();\par
599         output_Scaffold();\par
600         output_Scaffold_Char();\par
601         output_Output();\par
602     \}\par
603 \par
604     {\cf20 //This allows for passing unordered sets of nodes}\par
605     {\cf18 void} submit_Set(uint64_t* p_Input, {\cf18 int} p_Depth)\par
606     \{\par
607         {\cf20 //Firstly we gather the inputly}\par
608         set_Input(p_Input, p_Depth);\par
609 \par
610         {\cf20 //We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.}\par
611         {\cf20 //The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.}\par
612         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
613         fill_State({\cf22 "Query"});\par
614 \par
615         {\cf20 //Then charge the buffers as normal.}\par
616         charge_Buffers();\par
617     \}\par
618 \par
619     {\cf20 //Gets the current treetop at the given index.}\par
620     c_Node* get_Treetop({\cf18 int} p_Index = -1)\par
621     \{\par
622         {\cf19 if} (Top_Tier > 0)\par
623         \{\par
624             {\cf19 if} (p_Index == -1)\par
625             \{\par
626                 {\cf19 return} Scaffold[Top_Tier - 1][0][0][0];\par
627             \}\par
628 \par
629             {\cf20 //This construct is 4d which means at the highest point of 8 legged nodes before it turns to 2D then the dimension which is longer than the pyramid is tall will have treetops in a 1D line, like if you took a pyramid of Gaza and click-dragged it sideways with tracers on. Same with this 3D object except describing dragging a 3D 0bject is not intuitive to monke brayne.}\par
630             {\cf19 if} (State_Depth_X >= Top_Tier)\par
631             \{\par
632                 {\cf19 return} Scaffold[Top_Tier - 1][p_Index][0][0];\par
633             \}\par
634             {\cf20 //>= in case X == Y and we don't want fall-through on a perfect one.}\par
635             {\cf19 if} (State_Depth_Y >= Top_Tier)\par
636             \{\par
637                 {\cf19 return} Scaffold[Top_Tier - 1][0][p_Index][0];\par
638             \}\par
639             {\cf20 //>= in case X == Y == Z and we don't want fall-through on a perfect one.}\par
640             {\cf19 if} (State_Depth_Z >= Top_Tier)\par
641             \{\par
642                 {\cf19 return} Scaffold[Top_Tier - 1][0][0][p_Index];\par
643             \}\par
644         \}\par
645         {\cf19 return} NULL;\par
646     \}\par
647 \par
648     {\cf20 //Outputs the scaffold.}\par
649     {\cf18 void} output_Scaffold()\par
650     \{\par
651         std::cout << {\cf22 "\\n  --==   CAN_Scaffold   ==--"};\par
652 \par
653         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
654         \{\par
655             std::cout << {\cf22 "\\n <- Tier["} << cou_T << {\cf22 "] ->"};\par
656             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
657             \{\par
658                 std::cout << {\cf22 "\\n"};\par
659                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
660                 \{\par
661                     std::cout << {\cf22 "\\n"};\par
662                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
663                     \{\par
664                         std::cout << {\cf22 " [("} << cou_X << {\cf22 ", "} << cou_Y << {\cf22 ", "} << cou_Z << {\cf22 ") "};\par
665                         {\cf19 if} (Scaffold[cou_T][cou_X][cou_Y][cou_Z] != NULL) \{ std::cout << Scaffold[cou_T][cou_X][cou_Y][cou_Z]->NID; \} {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
666                         std::cout << {\cf22 "]"};\par
667                     \}\par
668                 \}\par
669             \}\par
670         \}\par
671     \}\par
672 \par
673     {\cf20 //Outputs the scaffold as character representing the address.}\par
674     {\cf18 void} output_Scaffold_Char()\par
675     \{\par
676         std::cout << {\cf22 "\\n("} << {\cf17 this} << {\cf22 ")\\n"};\par
677         {\cf19 for} ({\cf18 int} cou_T = 0; cou_T < Top_Tier; cou_T++)\par
678         \{\par
679             std::cout << {\cf22 "\\n"};\par
680             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (State_Depth_X - cou_T); cou_X++)\par
681             \{\par
682                 std::cout << {\cf22 "\\n"};\par
683                 {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < (State_Depth_Y - cou_T); cou_Y++)\par
684                 \{\par
685                     std::cout << {\cf22 "\\n["};\par
686                     {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < (State_Depth_Z - cou_T); cou_Z++)\par
687                     \{\par
688                         std::cout << char(Scaffold[cou_T][cou_X][cou_Y][cou_Z]);\par
689                     \}\par
690                     std::cout << {\cf22 "]"};\par
691                 \}\par
692             \}\par
693         \}\par
694     \}\par
695 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_Many_To_One.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN_Many_To_One.h}
{\xe \v include/NT4/c_CAN_Many_To_One.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //This functions to create a trace where all legs are connected to one node.}\par
3 {\cf20 //Load up the input, hit encode(), boom you single permutation of all legs bound to that node.}\par
4 {\cf20 //Most useful when each index in the input is a separate state space from the other indexes, sensors == good, language == shared states across words !good}\par
5 {\cf17 class }c_CAN_Many_To_One : {\cf17 public} c_Base_CAN\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Each CAN node is just a pointer to a node in the network.}\par
10     {\cf20 //For this CAN the scaffold is 2 tiers, the bottom being the state tier, and then one node on tier[1] for the treetop/symbol node.}\par
11     {\cf20 //So for this CAN we don't track the number of tiers, that is always 2, and the number of nodes is equal to the input depth for the state(quanta) tier, and 1 for the treetop.}\par
12     c_Node** Scaffold[2];\par
13     {\cf18 int} State_Depth; {\cf20 //We track this so that if the input is changed we can still properly delete the scaffold.}\par
14 \par
15     {\cf20 //The temporary buffer used during charging.}\par
16     c_Charging_Buffer tmp_Buffman;\par
17 \par
18     c_CAN_Many_To_One()\par
19     \{\par
20         NNet = NULL;\par
21 \par
22         Input.reset();\par
23         Output = NULL;\par
24         Output_Depth = 0;\par
25 \par
26         Scaffold[0] = NULL;\par
27         State_Depth = 0;\par
28         Scaffold[1] = {\cf17 new} c_Node * [1];\par
29 \par
30         State_Nodes_Index = 0;\par
31     \}\par
32 \par
33     ~c_CAN_Many_To_One()\par
34     \{\par
35         NNet = NULL;\par
36         reset_Scaffold();\par
37         reset_Input();\par
38     \}\par
39 \par
40     {\cf20 //Resets the CAN to NULL, and deletes the state tier + treetop.}\par
41     {\cf18 void} reset_Scaffold()\par
42     \{\par
43         {\cf19 if} (Scaffold[0] != NULL)\par
44         \{\par
45             {\cf20 //Make sure to NULL the scaffold first.}\par
46             {\cf20 //DO NOT DELETE THEM, the addresses are for the node network, deleting them here will cause null pointer deletion in Node_Network.}\par
47             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
48             \{\par
49                 Scaffold[0][cou_Index] = NULL;\par
50             \}\par
51             {\cf17 delete}[] Scaffold[0];\par
52             Scaffold[0] = NULL;\par
53         \}\par
54         Scaffold[1][0] = NULL;\par
55     \}\par
56 \par
57     {\cf20 //This sets up the actual CAN scaffold to use.}\par
58     {\cf20 //It assumes the input array is filled out, the size is based upon that array.}\par
59     {\cf18 void} setup_CAN_Scaffold()\par
60     \{\par
61         {\cf20 //Take it out back and put it down.}\par
62         reset_Scaffold();\par
63 \par
64         {\cf20 //Sizing her up!}\par
65         State_Depth = Input.Depth;\par
66 \par
67         {\cf20 //Setup the lowest tier of the scaffold so that every index in the input has a correlated state tier node position on the scaffold.}\par
68         Scaffold[0] = {\cf17 new} c_Node * [State_Depth];\par
69 \par
70         {\cf20 //Initialize the scaffold.}\par
71         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
72         \{\par
73             Scaffold[0][cou_Index] = NULL;\par
74         \}\par
75         Scaffold[1][0] = NULL;\par
76     \}\par
77 \par
78     {\cf20 //This fills the state tier by querying the node network.}\par
79     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
80     {\cf18 void} fill_State(std::string p_How = {\cf22 "Encode"})\par
81     \{\par
82         std::cout << {\cf22 "\\n Encoding with State_Nodes_Index: "} << State_Nodes_Index;\par
83         {\cf19 if} (p_How == {\cf22 "Encode"})\par
84         \{\par
85             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
86             \{\par
87                 {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
88                 {\cf20 //We have to make sure we request the correct state tree.}\par
89                 Scaffold[0][cou_Index] = NNet->get_State_Node(State_Nodes_Index, Input.Data[cou_Index]);\par
90                 Scaffold[0][cou_Index]->RC++;\par
91 \par
92                 {\cf20 //If the node is also a treetop then set it to state/treetop.}\par
93                 {\cf19 if} ((Scaffold[0][cou_Index]->Type == 2))\par
94                 \{\par
95                     Scaffold[0][cou_Index]->Type = 3;\par
96                 \}\par
97             \}\par
98         \}\par
99         {\cf19 if} (p_How == {\cf22 "Query"})\par
100         \{\par
101             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
102             \{\par
103                 {\cf20 //Request the state node form the node network using get_State_Node so one is created if not found.}\par
104                 {\cf20 //We have to make sure we request the correct state tree.}\par
105                 Scaffold[0][cou_Index] = NNet->does_State_Node_Exist(State_Nodes_Index, Input.Data[cou_Index]);\par
106             \}\par
107         \}\par
108     \}\par
109 \par
110     {\cf20 //Just one node at the tippy top.}\par
111     {\cf20 //p_How: "Encode" == Create the nodes if they aren't found, "Query" == Returns NULL if they aren't found, used for checking if something has been encoded without modifying the network.}\par
112     {\cf18 void} fill_Scaffold(std::string p_How = {\cf22 "Encode"})\par
113     \{\par
114         {\cf19 if} (State_Depth == 0)\par
115         \{\par
116             Scaffold[1][0] = NULL;\par
117 \par
118             {\cf19 return};\par
119         \}\par
120         {\cf19 if} (p_How == {\cf22 "Encode"})\par
121         \{\par
122             {\cf20 //We request a node that links the entire state tier together.}\par
123             Scaffold[1][0] = NNet->get_Upper_Tier_Node(Scaffold[0], State_Depth, 2);\par
124             Scaffold[1][0]->RC++;\par
125         \}\par
126         {\cf19 if} (p_How == {\cf22 "Query"})\par
127         \{\par
128             {\cf20 //We request a node that links the entire state tier together, but do not create them.}\par
129             Scaffold[1][0] = NNet->does_Upper_Tier_Connection_Exist(Scaffold[0], State_Depth);\par
130         \}\par
131     \}\par
132 \par
133     {\cf20 //Encodes a single trace, forcibly.}\par
134     {\cf18 void} encode(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0)\par
135     \{\par
136         std::cout << {\cf22 "\\n\\n<<-- Begin Encoding -->>\\n\\n"};\par
137 \par
138         {\cf20 //Firstly we gather the inputly}\par
139         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
140 \par
141         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
142         setup_CAN_Scaffold();\par
143 \par
144         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
145         fill_State({\cf22 "Encode"});\par
146 \par
147         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
148         fill_Scaffold({\cf22 "Encode"});\par
149 \par
150         {\cf20 //To be removed later after testing.}\par
151         {\cf20 //output_Input();}\par
152         output_Scaffold();\par
153         output_Scaffold_Char();\par
154 \par
155         std::cout << {\cf22 "\\n\\n-- End Encoding --\\n\\n"};\par
156     \}\par
157 \par
158     {\cf20 //Style determines whether it charges with normal submission of raw, or if it does the specific leg charging for Chrono.}\par
159     {\cf18 void} charge_Buffers({\cf18 int} p_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
160     \{\par
161 \par
162         tmp_Buffman.reset();\par
163 \par
164         tmp_Buffman.Input_Position = 0;\par
165 \par
166         tmp_Buffman.charge_Outputs();\par
167 \par
168         {\cf19 for} ({\cf18 int} cou_Input = 0; cou_Input < Input.Depth; cou_Input++)\par
169         \{\par
170             {\cf19 if} (Scaffold[0][cou_Input] != NULL)\par
171             \{\par
172                 std::cout << {\cf22 "\\n\\n ~~++==++~~ Charging Node: CAN[0]["} << cou_Input << {\cf22 "]: "} << Scaffold[0][cou_Input] << {\cf22 " ~ "} << Scaffold[0][cou_Input]->NID;\par
173 \par
174                 {\cf20 //tmp_Buffman.submit(Scaffold[0][cou_Input], (1.0));}\par
175                 {\cf19 if} (p_Style == -1)\par
176                 \{\par
177                     tmp_Buffman.submit(Scaffold[0][cou_Input], (10.0));\par
178                 \}\par
179                 {\cf19 if} (p_Style == 1)\par
180                 \{\par
181                     tmp_Buffman.charge_Given_Leg(Scaffold[0][cou_Input], (10.0), cou_Input);\par
182                 \}\par
183                 {\cf19 if} (p_Style == 2)\par
184                 \{\par
185                     {\cf20 //p_Leg specifies which leg to charge in this function, p_Legs[] being unused.}\par
186                     tmp_Buffman.charge_Given_Leg(Scaffold[0][cou_Input], (10.0), p_Leg);\par
187                 \}\par
188                 {\cf19 if} (p_Style == 3)\par
189                 \{\par
190                     {\cf20 //p_Leg is used here as the count of elements in p_Legs[].}\par
191                     tmp_Buffman.charge_Given_Legs(Scaffold[0][cou_Input], p_Leg, p_Legs, (10.0));\par
192                 \}\par
193             \}\par
194         \}\par
195 \par
196         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ Before ++++++++++++++++++++++++++++++ \\n\\n";}\par
197 \par
198         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
199 \par
200         tmp_Buffman.gather();\par
201 \par
202         {\cf20 //std::cout << "\\n\\n++++++++++++++++++++++++++++++ After ++++++++++++++++++++++++++++++ \\n\\n";}\par
203 \par
204         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
205 \par
206         {\cf19 while} (tmp_Buffman.flg_Not_Done)\par
207         \{\par
208             std::cout << {\cf22 "\\n\\n flg_Not_Done\\n"};\par
209 \par
210             tmp_Buffman.charge_Outputs();\par
211 \par
212             tmp_Buffman.gather();\par
213 \par
214             {\cf20 //tmp_Buffman.output_All_Buffers();}\par
215         \}\par
216 \par
217         std::cout << {\cf22 "\\n\\n Completed:\\n"};\par
218 \par
219         {\cf20 //tmp_Buffman.output_All_Buffers();}\par
220 \par
221         std::cout << {\cf22 "\\n\\n Treetops:\\n"};\par
222         tmp_Buffman.output_Treetops();\par
223 \par
224         c_Charging_Linked_List * tmp_Current_LL = NULL;\par
225         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
226 \par
227         {\cf20 /*}\par
228 {\cf20         while (tmp_Current_LL != NULL)}\par
229 {\cf20         \{}\par
230 {\cf20             tmp_Current_LL->NID->bp_O();}\par
231 {\cf20 }\par
232 {\cf20             tmp_Current_LL = tmp_Current_LL->Next;}\par
233 {\cf20         \}}\par
234 {\cf20         */}\par
235     \}\par
236 \par
237     {\cf18 void} gather_Treetops()\par
238     \{\par
239         std::cout << {\cf22 "\\n\\n Gathering Treetops..."};\par
240 \par
241         c_Charging_Linked_List* tmp_Current_LL = NULL;\par
242         tmp_Current_LL = tmp_Buffman.Treetops.Root;\par
243 \par
244         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
245 \par
246         Output = {\cf17 new} c_Trace[tmp_Buffman.Treetops.Depth];\par
247         Output_Depth = tmp_Buffman.Treetops.Depth;\par
248 \par
249         {\cf18 int} tmp_Current_Index = 0;\par
250 \par
251         c_Linked_List_Handler tmp_Pattern;\par
252 \par
253         c_Linked_List* tmp_LL_Pat = NULL;\par
254 \par
255         {\cf19 while} (tmp_Current_LL != NULL)\par
256         \{\par
257             tmp_Pattern.reset();\par
258 \par
259             {\cf20 //Get the pattern into a linked list}\par
260             tmp_Current_LL->NID->bp_Trace_O(&tmp_Pattern);\par
261 \par
262             std::cout << {\cf22 "\\n NID: "} << tmp_Current_LL->NID->NID;\par
263             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
264             tmp_Pattern.output();\par
265 \par
266             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
267             {\cf20 //Copy the pattern over}\par
268             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
269 \par
270             std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
271 \par
272             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
273 \par
274             tmp_LL_Pat = tmp_Pattern.Root;\par
275 \par
276             {\cf20 //We can iterate through given we know how big the linked list is.}\par
277             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
278             \{\par
279                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
280                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
281             \}\par
282 \par
283             std::cout << {\cf22 "\\n tmp_Current_LL->NID->Current_Charge: "} << tmp_Current_LL->NID->Current_Charge;\par
284             std::cout << {\cf22 "\\n tmp_Current_LL->Charge: "} << tmp_Current_LL->Charge;\par
285             std::cout << {\cf22 "\\n tmp_Current_LL->NID->RC: "} << tmp_Current_LL->NID->RC;\par
286             Output[tmp_Current_Index].set_Charge(tmp_Current_LL->Charge);\par
287             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
288             Output[tmp_Current_Index].set_RC(tmp_Current_LL->NID->RC);\par
289             Output[tmp_Current_Index].set_Treetop(tmp_Current_LL->NID);\par
290 \par
291             tmp_Current_LL = tmp_Current_LL->Next;\par
292             \par
293             Output[tmp_Current_Index].output(0);\par
294             Output[tmp_Current_Index].output(1);\par
295 \par
296             tmp_Current_Index++;\par
297         \}\par
298     \}\par
299 \par
300     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
301     {\cf18 void} gather_All_Traces()\par
302     \{\par
303         std::cout << {\cf22 "\\n\\n Gathering All Traces!!!"};\par
304 \par
305 \par
306 \par
307         c_Node* tmp_Node = NULL;\par
308         tmp_Node = NNet->Root;\par
309 \par
310         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
311 \par
312         Output = {\cf17 new} c_Trace[NNet->Node_Count];\par
313         Output_Depth = NNet->Node_Count;\par
314 \par
315         {\cf18 int} tmp_Current_Index = 0;\par
316 \par
317         c_Linked_List_Handler tmp_Pattern;\par
318 \par
319         c_Linked_List* tmp_LL_Pat = NULL;\par
320 \par
321         {\cf19 while} (tmp_Node != NULL)\par
322         \{\par
323             std::cout << {\cf22 "\\nNode ("} << tmp_Node->NID << {\cf22 ") "};\par
324             tmp_Node->bp_O();\par
325 \par
326 \par
327             tmp_Pattern.reset();\par
328 \par
329             {\cf20 //Get the pattern into a linked list}\par
330             tmp_Node->bp_Trace_O(&tmp_Pattern);\par
331 \par
332             std::cout << {\cf22 "\\n NID: "} << tmp_Node->NID;\par
333             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
334             tmp_Pattern.output();\par
335 \par
336             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
337             {\cf20 //Copy the pattern over}\par
338             Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
339 \par
340             std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
341 \par
342             std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
343 \par
344             tmp_LL_Pat = tmp_Pattern.Root;\par
345 \par
346             {\cf20 //We can iterate through given we know how big the linked list is.}\par
347             {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
348             \{\par
349                 Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
350                 tmp_LL_Pat = tmp_LL_Pat->Next;\par
351             \}\par
352 \par
353             std::cout << {\cf22 "\\n tmp_Current_LL->NID->Current_Charge: "} << tmp_Node->Current_Charge;\par
354             std::cout << {\cf22 "\\n tmp_Current_LL->NID->RC: "} << tmp_Node->RC;\par
355             Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
356             {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
357             Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
358             Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
359 \par
360             Output[tmp_Current_Index].output(0);\par
361             Output[tmp_Current_Index].output(1);\par
362 \par
363             tmp_Current_Index++;\par
364 \par
365             tmp_Node = tmp_Node->Next;\par
366         \}\par
367     \}\par
368 \par
369     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
370     {\cf18 void} gather_Given_Trace(uint64_t p_NID)\par
371     \{\par
372         std::cout << {\cf22 "\\n\\n Gathering Given Trace "} << p_NID << {\cf22 "..."};\par
373 \par
374         c_Node* tmp_Node = NULL;\par
375         tmp_Node = NNet->get_Node_Ref_By_NID(p_NID);\par
376 \par
377         {\cf19 if} (Output != NULL) \{ {\cf17 delete}[] Output; Output = NULL; \}\par
378 \par
379         Output = {\cf17 new} c_Trace[1];\par
380         Output_Depth = 1;\par
381 \par
382         {\cf18 int} tmp_Current_Index = 0;\par
383 \par
384         c_Linked_List_Handler tmp_Pattern;\par
385 \par
386         c_Linked_List* tmp_LL_Pat = NULL;\par
387 \par
388         tmp_Pattern.reset();\par
389 \par
390         {\cf20 //Get the pattern into a linked list}\par
391         tmp_Node->bp_Trace_O(&tmp_Pattern);\par
392 \par
393         std::cout << {\cf22 "\\n NID: "} << tmp_Node->NID;\par
394         std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
395         tmp_Pattern.output();\par
396 \par
397         {\cf20 //Copy the pattern over}\par
398         Output[tmp_Current_Index].set_Depth(tmp_Pattern.Depth);\par
399 \par
400         std::cout << {\cf22 "\\n Output["} << tmp_Current_Index << {\cf22 "].Depth: "} << Output[tmp_Current_Index].Depth;\par
401 \par
402         std::cout << {\cf22 "\\n tmp_Pattern.Depth: "} << tmp_Pattern.Depth;\par
403 \par
404         tmp_LL_Pat = tmp_Pattern.Root;\par
405 \par
406         {\cf20 //We can iterate through given we know how big the linked list is.}\par
407         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Pattern.Depth; cou_Index++)\par
408         \{\par
409             Output[tmp_Current_Index].set_Pattern_Index(tmp_LL_Pat->Quanta, cou_Index);\par
410             tmp_LL_Pat = tmp_LL_Pat->Next;\par
411         \}\par
412 \par
413         std::cout << {\cf22 "\\n tmp_Node->Current_Charge: "} << tmp_Node->Current_Charge;\par
414         std::cout << {\cf22 "\\n tmp_Node->RC: "} << tmp_Node->RC;\par
415         Output[tmp_Current_Index].set_Charge(tmp_Node->Current_Charge);\par
416         {\cf20 //Output[tmp_Current_Index].set_Charge(tmp_Current_LL->NID->Current_Charge);}\par
417         Output[tmp_Current_Index].set_RC(tmp_Node->RC);\par
418         Output[tmp_Current_Index].set_Treetop(tmp_Node);\par
419 \par
420         Output[tmp_Current_Index].output(0);\par
421         Output[tmp_Current_Index].output(1);\par
422 \par
423         tmp_Current_Index++;\par
424     \}\par
425 \par
426 \par
427     {\cf20 //Fills out the NULLCAN, does not forcibly encode, and then charges the network.}\par
428     {\cf20 //Charging style determines leg charging. May move it to be a setting.}\par
429     {\cf20 //     -1: Charge by giving the input node the base charge, normal node charging.}\par
430     {\cf20 //      1: Use leg specific charging to charge every node based on its position in the input array. Node[1] would charge axons on Axon[1][n].}\par
431     {\cf20 //      2: Charge every input on the given p_Leg, used mainly when inputing single values to charge. Allows you to input Node[x] as the only input to the Chrono and charge it using Axon[4][n], or any axon hillock you choose.}\par
432     {\cf20 //       This allows you to search forward by setting a node early in the time series and searching forwards, or setting it late in the time series and searching backwards.}\par
433     {\cf18 void} query(uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int} * p_Legs = NULL)\par
434     \{\par
435         {\cf20 //Firstly we gather the inputly}\par
436         {\cf19 if} ((p_Input != NULL) && (p_Depth > 0)) \{ set_Input(p_Input, p_Depth); \}\par
437 \par
438         {\cf20 //Set up the scaffold for the nodes to reside in as we build the trace.}\par
439         setup_CAN_Scaffold();\par
440 \par
441         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
442         fill_State({\cf22 "Query"});\par
443 \par
444         {\cf20 //Fills the scaffold out by requesting nodes from the NNet and creating them if they aren't found.}\par
445         fill_Scaffold({\cf22 "Query"});\par
446 \par
447         charge_Buffers(p_Charging_Style, p_Leg, p_Legs);\par
448 \par
449         gather_Treetops();\par
450 \par
451 \par
452         {\cf20 //To be removed later after testing.}\par
453         output_Input();\par
454         output_Scaffold();\par
455         output_Scaffold_Char();\par
456         output_Output();\par
457     \}\par
458 \par
459     {\cf20 //This allows for passing unordered sets of nodes}\par
460     {\cf18 void} submit_Set(uint64_t* p_Input, {\cf18 int} p_Depth)\par
461     \{\par
462         {\cf20 //Firstly we gather the inputly}\par
463         set_Input(p_Input, p_Depth);\par
464 \par
465         {\cf20 //We only do the query on the state tier. This is because the nodes will not be in a coherent relationship to each other, only their presence is important.}\par
466         {\cf20 //The node adress being read in as the state means that the unordered set can be read in to the state tier because the shared memory space precludes duplicates, you just ignore any higher tiers than 0.}\par
467         {\cf20 //Work across the state tier to fill it out by requesting state nodes from the NNet, if not found they are created.}\par
468         fill_State({\cf22 "Query"});\par
469 \par
470         {\cf20 //Then charge the buffers as normal.}\par
471         charge_Buffers();\par
472     \}\par
473 \par
474     {\cf20 //Gets the current treetop at the given index.}\par
475     c_Node* get_Treetop({\cf18 int} p_Index = -1)\par
476     \{\par
477         {\cf20 //For this network the treetop is the scaffold[1][0] since all lower nodes link to this higher tier node.}\par
478         {\cf19 return} Scaffold[1][0];\par
479     \}\par
480 \par
481     {\cf20 //Outputs the scaffold.}\par
482     {\cf18 void} output_Scaffold()\par
483     \{\par
484         std::cout << {\cf22 "\\n  --==   CAN_Scaffold   ==--"};\par
485         std::cout << {\cf22 "\\n <- Tier[0] ->"};\par
486         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
487         \{\par
488             std::cout << {\cf22 "\\n   ["} << cou_Index << {\cf22 "] "};\par
489             {\cf19 if} (Scaffold[0][cou_Index] != NULL) \{ std::cout << {\cf22 " <> "} << Scaffold[0][cou_Index]->NID; \} {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
490         \}\par
491         std::cout << {\cf22 "\\n <- Tier[1] ->"};\par
492         std::cout << {\cf22 "\\n   [0] "};\par
493         {\cf19 if} (Scaffold[1][0] != NULL) \{ std::cout << {\cf22 " <> "} << Scaffold[1][0]->NID; \} {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
494     \}\par
495 \par
496 \par
497     {\cf20 //Outputs the scaffold as character representing the address.}\par
498     {\cf18 void} output_Scaffold_Char()\par
499     \{\par
500         std::cout << {\cf22 "\\n\\n("} << {\cf17 this} << {\cf22 ")\\n"};\par
501         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Depth; cou_Index++)\par
502         \{\par
503             std::cout << char(Scaffold[0][cou_Index]);\par
504         \}\par
505         std::cout << {\cf22 "\\n"} << char(Scaffold[1][0]);\par
506     \}\par
507 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_CAN_Multi_Sensory_Construct.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_CAN_Multi_Sensory_Construct.h}
{\xe \v include/NT4/c_CAN_Multi_Sensory_Construct.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid }
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Charging_Array.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Charging_Array.h}
{\xe \v include/NT4/c_Charging_Array.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //These classes handle the charging buffers and charging array.}\par
2 \par
3 \par
4 \par
5 {\cf20 //This is the linked list for the buffer.}\par
6 {\cf17 class }c_Charging_Linked_List\par
7 \{\par
8 {\cf17 public}:\par
9 \par
10     {\cf20 //The next node in the chain.}\par
11     c_Charging_Linked_List* Next;\par
12     c_Charging_Linked_List* Previous;\par
13     {\cf18 double} Charge;\par
14     c_Node* NID;\par
15 \par
16     c_Charging_Linked_List()\par
17     \{\par
18         Next = NULL;\par
19         Previous = NULL;\par
20         Charge = 0;\par
21         NID = NULL;\par
22     \}\par
23 \par
24     ~c_Charging_Linked_List()\par
25     \{\par
26         Charge = 0;\par
27         NID = NULL;\par
28         {\cf20 //delete Next; Handled by the handler.}\par
29     \}\par
30 \par
31     {\cf20 //Outputs the linked list.}\par
32     {\cf20 //-- !WARNING! RECURSIVE FUNCTION ON LINKED LIST! CALLING THIS WILL CAUSE STACK CORRUPTION ERROR WITH ENOUGH NODES!}\par
33     {\cf18 void} output_LL()\par
34     \{\par
35         {\cf20 //---std::cout << " [";}\par
36         {\cf19 if} (NID != NULL) \{ NID->bp_O(); \}\par
37         std::cout << {\cf22 " $"} << Charge << {\cf22 "]  "};\par
38         {\cf19 if} (Next != NULL) \{ Next->output_LL(); \}\par
39     \}\par
40 \};\par
41 \par
42 {\cf20 //This handles the linked list creation and deletion so that recursive destruction does not crash the stack.}\par
43 {\cf17 class }c_Charging_Linked_List_Handler\par
44 \{\par
45 {\cf17 public}:\par
46 \par
47     {\cf20 //The nodes in the linked list.}\par
48     c_Charging_Linked_List* Root;\par
49     c_Charging_Linked_List** Current_LL;\par
50     {\cf18 int} Depth;\par
51 \par
52     c_Charging_Linked_List_Handler()\par
53     \{\par
54         Root = NULL;\par
55         Current_LL = &Root;\par
56         Depth = 0;\par
57     \}\par
58 \par
59     ~c_Charging_Linked_List_Handler()\par
60     \{\par
61         reset();\par
62     \}\par
63 \par
64     {\cf20 //Init}\par
65     {\cf18 void} init()\par
66     \{\par
67         Root = NULL;\par
68         Current_LL = &Root;\par
69         Depth = 0;\par
70     \}\par
71 \par
72     {\cf20 //Adds a node.}\par
73     c_Charging_Linked_List* new_LL(c_Node* p_NID, {\cf18 double} p_Charge)\par
74     \{\par
75         c_Charging_Linked_List* tmp_LL = NULL;\par
76 \par
77         *Current_LL = {\cf17 new} c_Charging_Linked_List;\par
78 \par
79         (*Current_LL)->Charge = p_Charge;\par
80         (*Current_LL)->NID = p_NID;\par
81 \par
82         tmp_LL = *Current_LL;\par
83 \par
84         (*Current_LL)->Previous = tmp_LL;\par
85 \par
86         Current_LL = &(*Current_LL)->Next;\par
87 \par
88         Depth++;\par
89 \par
90         {\cf19 return} tmp_LL;\par
91     \}\par
92 \par
93     {\cf20 //Resets the linked list.}\par
94     {\cf18 void} reset()\par
95     \{\par
96         c_Charging_Linked_List* tmp_LL = Root;\par
97         Root = NULL;\par
98         c_Charging_Linked_List* tmp_LL_Next = NULL;\par
99 \par
100         {\cf19 while} (tmp_LL != NULL)\par
101         \{\par
102             tmp_LL_Next = tmp_LL->Next;\par
103             tmp_LL->Next = NULL;\par
104             tmp_LL->Previous = NULL;\par
105             {\cf17 delete} tmp_LL;\par
106             tmp_LL = NULL;\par
107             tmp_LL = tmp_LL_Next;\par
108         \}\par
109 \par
110         {\cf19 if} (Root != NULL) \{ {\cf17 delete} Root; \}\par
111         Root = NULL;\par
112         Current_LL = &Root;\par
113 \par
114         Depth = 0;\par
115     \}\par
116 \par
117     {\cf20 //Outputs the linked list.}\par
118     {\cf18 void} output()\par
119     \{\par
120         c_Charging_Linked_List* tmp_LL = Root;\par
121         \par
122         c_Charging_Linked_List* tmp_LL_Next = NULL;\par
123 \par
124         std::cout << {\cf22 "\\n ----Charging_Linked_List:"};\par
125         {\cf19 while} (tmp_LL != NULL)\par
126         \{\par
127             tmp_LL_Next = tmp_LL->Next;\par
128 \par
129             {\cf20 //Hmm, might change the tmp_LL->NID to a different name so it isn't NID->NID}\par
130             std::cout << {\cf22 "\\n   -"};\par
131             \par
132             std::cout << tmp_LL->NID->NID;\par
133 \par
134             std::cout << {\cf22 "\\n"};\par
135 \par
136             tmp_LL->NID->bp_O();\par
137 \par
138             tmp_LL = tmp_LL_Next;\par
139         \}\par
140     \}\par
141 \};\par
142 \par
143 \par
144 {\cf17 class }c_Charging_Buffer_Node\par
145 \{\par
146     {\cf17 friend} {\cf17 class }c_Charging_Buffer_Tree;\par
147 {\cf17 private}:\par
148 \par
149     c_Charging_Buffer_Node* Right;\par
150     c_Charging_Buffer_Node* Center;\par
151     c_Charging_Buffer_Node* Left;\par
152 \par
153 {\cf17 public}:\par
154 \par
155     uint64_t Data;\par
156 \par
157     c_Charging_Linked_List* LL; \par
158 \par
159     c_Charging_Buffer_Node()\par
160     \{\par
161         Right = NULL;\par
162         Center = NULL;\par
163         Left = NULL;\par
164         LL = NULL;\par
165         Data = 0;\par
166     \}\par
167 \par
168     ~c_Charging_Buffer_Node()\par
169     \{\par
170         LL = NULL;\par
171         {\cf17 delete} Right; Right = NULL;\par
172         {\cf17 delete} Center; Center = NULL;\par
173         {\cf17 delete} Left; Left = NULL;\par
174     \}\par
175 \par
176 \};\par
177 \par
178 {\cf17 class }c_Charging_Buffer_Tree\par
179 \{\par
180 {\cf17 private}:\par
181 \par
182 \par
183 {\cf17 public}:\par
184     c_Charging_Buffer_Node* Root;\par
185     c_Charging_Buffer_Node** Current;{\cf20 //the current node that will allow referencing outside of the search function}\par
186     {\cf18 bool} flg_Foundit;{\cf20 //the flag that set when a node is found already set}\par
187 \par
188     {\cf20 //For handling the current search.}\par
189     uint64_t tmp_Data;\par
190     uint64_t tmp_SData;\par
191 \par
192     c_Charging_Buffer_Tree()\par
193     \{\par
194         Root = NULL;\par
195         Current = NULL;\par
196         flg_Foundit = {\cf17 false};\par
197     \}\par
198 \par
199     ~c_Charging_Buffer_Tree()\par
200     \{\par
201         {\cf17 delete} Root;\par
202     \}\par
203 \par
204     {\cf18 void} init()\par
205     \{\par
206         Root = NULL;\par
207         Current = NULL;\par
208         flg_Foundit = {\cf17 false};\par
209     \}\par
210 \par
211     {\cf20 //Now returning whether or not the node was found as the foundit flag does not work with multiple threads.}\par
212     {\cf20 //This returns the node at the end of the chain, whether it was found or not does not matter the }\par
213     {\cf20 //buffer node is returned and has to be checked for values.}\par
214     c_Charging_Buffer_Node* search(c_Node* p_Data)\par
215     \{\par
216         flg_Foundit = {\cf17 false};\par
217 \par
218         {\cf19 if} (p_Data == NULL) \{ Current = NULL; {\cf19 return} NULL; \}\par
219 \par
220         uint64_t tmp_SSData;\par
221         tmp_SSData = uint64_t(p_Data);\par
222 \par
223 \par
224 \par
225         {\cf20 //--std::cout << "\\n\\n SEARCHING ->" << tmp_SData.U;}\par
226         {\cf20 //system("PAUSE > NULL");}\par
227         {\cf19 return} query_Node(Root, tmp_SSData, 31);\par
228     \}\par
229 \par
230     c_Charging_Buffer_Node* query_Node(c_Charging_Buffer_Node*& p_Node, uint64_t p_Data, {\cf18 int} p_Shift)\par
231     \{\par
232         {\cf20 //These are used because we have to be carefull not to leave Mutex locked with a return.}\par
233         c_Charging_Buffer_Node* tmp_Return = NULL;\par
234         {\cf18 bool} flg_Done = {\cf17 false};\par
235 \par
236         uint64_t tmp_DData;\par
237         tmp_DData = p_Data;\par
238         tmp_DData = tmp_DData >> p_Shift;\par
239         {\cf20 //--std::cout << "\\n\\n\\n tmp_DData.U = " << tmp_DData.U << " p_Shift = " << p_Shift;}\par
240 \par
241 \par
242         {\cf20 //--std::cout << "\\n\\n\\t __QN__ tmp_DData.U->" << tmp_DData.U << " p_Data.U->" << p_Data.U;}\par
243 \par
244         {\cf19 if} (p_Node == NULL)\par
245         \{\par
246             {\cf20 //--std::cout << "\\n\\t   Node is NULL";}\par
247             p_Node = {\cf17 new} c_Charging_Buffer_Node;\par
248             p_Node->Right = NULL;\par
249             p_Node->Center = NULL;\par
250             p_Node->Left = NULL;\par
251             {\cf19 if} (p_Shift > 1)\par
252             \{\par
253                 {\cf20 //--std::cout << "\\n\\t   tmp_DData.U > 1";}\par
254                 p_Node->Data = tmp_DData;\par
255             \}\par
256             {\cf19 else}\par
257             \{\par
258                 {\cf20 //--std::cout << "\\n\\t   tmp_DData.U !> 1";}\par
259                 p_Node->Data = p_Data;\par
260                 Current = &p_Node;\par
261                 flg_Foundit = {\cf17 false};\par
262                 tmp_Return = p_Node;\par
263                 flg_Done = {\cf17 true};\par
264                 {\cf20 //return 0;}\par
265             \}\par
266         \}\par
267 \par
268         {\cf20 //If the node was not found then return NULL;}\par
269         {\cf19 if} (flg_Done) \{ {\cf19 return} tmp_Return; \}\par
270 \par
271         {\cf20 //If the current data matches the tmp data then another depth is explored.}\par
272         {\cf19 if} (p_Node->Data == tmp_DData && p_Shift > 0)\par
273         \{\par
274             {\cf20 //--std::cout << "\\n\\t   p_Node->Data.U (" << p_Node->Data.U << ") == tmp_DData.U (" << tmp_DData.U << ")";}\par
275 \par
276             {\cf20 //--std::cout << "\\t tmp_DData.U = " << tmp_DData.U;}\par
277 \par
278             {\cf19 return} query_Node(p_Node->Center, p_Data, (p_Shift - 1));\par
279         \}\par
280 \par
281         {\cf20 //If the node data matches the given data exactly the node has been found.}\par
282         {\cf20 //This is not locked because even if the Current & flg_Foundit are overwritten they will not be}\par
283         {\cf20 //used by the threads, but will work with the standard single thread.}\par
284         {\cf19 if} (p_Node->Data == p_Data)\par
285         \{\par
286             {\cf20 //--std::cout << "\\n\\t    p_Node->Data.NR(" << p_Node->Data.NR << ") == p_Data.NR(" << p_Data.NR << ")";}\par
287             Current = &p_Node;\par
288             flg_Foundit = {\cf17 true};\par
289             tmp_Return = p_Node;\par
290             flg_Done = {\cf17 true};\par
291             {\cf20 //return 1;}\par
292         \}\par
293 \par
294         {\cf20 //If the node was found then return tmp_Return;}\par
295         {\cf19 if} (flg_Done) \{ {\cf19 return} tmp_Return; \}\par
296 \par
297         {\cf19 if} (tmp_DData < p_Node->Data)\par
298         \{\par
299             {\cf20 //--std::cout << "\\n\\t    tmp_DData.U (" << tmp_DData.U << ") < p_Node->Data.U(" << p_Node->Data.U << ")";}\par
300             {\cf19 return} query_Node(p_Node->Left, p_Data, p_Shift);\par
301         \}\par
302         {\cf19 if} (tmp_DData > p_Node->Data)\par
303         \{\par
304             {\cf20 //--std::cout << "\\n\\t    tmp_DData.U (" << tmp_DData.U << ") > p_Node->Data.U(" << p_Node->Data.U << ")";}\par
305             {\cf19 return} query_Node(p_Node->Right, p_Data, p_Shift);\par
306         \}\par
307         {\cf19 return} tmp_Return;\par
308     \}\par
309 \par
310     {\cf18 void} output_Tree()\par
311     \{\par
312         output_Node(Root, 0);\par
313     \}\par
314 \par
315     {\cf18 void} output_Node(c_Charging_Buffer_Node*& p_Node, {\cf18 int} p_Tab)\par
316     \{\par
317         {\cf19 if} (p_Node == NULL) \{ {\cf19 return}; \}\par
318         output_Node(p_Node->Left, (p_Tab));\par
319         {\cf20 //---std::cout << "\\n";}\par
320         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Tab; cou_Index++)\par
321         \{\par
322             {\cf20 //---std::cout << "  ";}\par
323         \}\par
324         {\cf20 //---std::cout << p_Node->Data;}\par
325         {\cf19 if} (p_Node->LL != NULL) \{ std::cout << {\cf22 "->"} << p_Node->LL->NID->NID; \}\par
326         output_Node(p_Node->Center, (p_Tab + 1));\par
327         output_Node(p_Node->Right, (p_Tab));\par
328     \}\par
329 \par
330     c_Charging_Linked_List* get_Node_LL(c_Charging_Buffer_Node*& p_Node)\par
331     \{\par
332         {\cf19 if} (p_Node != NULL) \{\par
333             {\cf19 return} p_Node->LL;\par
334         \}\par
335         {\cf19 else} \{\par
336             {\cf19 return} NULL;\par
337         \}\par
338     \}\par
339 \par
340     {\cf18 void} set_Node_LL(c_Charging_Buffer_Node*& p_Node, c_Charging_Linked_List* p_LL)\par
341     \{\par
342         {\cf19 if} (p_Node != NULL)\par
343         \{\par
344             p_Node->LL = p_LL;\par
345         \}\par
346     \}\par
347 \par
348     c_Charging_Linked_List* set_Current_Node_LL(c_Charging_Linked_List* p_LL)\par
349     \{\par
350         set_Node_LL(*Current, p_LL);\par
351         {\cf19 return} p_LL;\par
352     \}\par
353 \par
354     c_Charging_Linked_List* get_Current_Node_LL()\par
355     \{\par
356         {\cf19 return} get_Node_LL(*Current);\par
357     \}\par
358 \par
359 \par
360     {\cf20 //Resets the tree.}\par
361     {\cf18 void} reset()\par
362     \{\par
363         {\cf17 delete} Root;\par
364         Root = NULL;\par
365 \par
366         Current = NULL;\par
367         flg_Foundit = {\cf17 false};\par
368     \}\par
369 \par
370 \};\par
371 \par
372 \par
373 \par
374 {\cf20 //The class that houses the charging buffer tree and the LL.}\par
375 {\cf17 class }c_Charging_Buffer\par
376 \{\par
377 {\cf17 private}:\par
378 \par
379 {\cf17 public}:\par
380 \par
381     {\cf20 //The search tree.}\par
382     c_Charging_Buffer_Tree Tree;\par
383 \par
384     {\cf20 //The linked lists.}\par
385     c_Charging_Linked_List_Handler Current_Charge;\par
386 \par
387     c_Charging_Linked_List_Handler Output;\par
388 \par
389     c_Charging_Linked_List_Handler Treetops;\par
390 \par
391     {\cf20 //Flags}\par
392     {\cf18 bool} flg_Not_Done;\par
393 \par
394     {\cf18 int} Input_Position;\par
395 \par
396     {\cf20 //Settings & trackers for the settings.}\par
397     {\cf18 double} Base_Charge;\par
398     {\cf18 double} Current_Highest_Charge;\par
399     {\cf18 double} Previous_Highest_Charge;\par
400 \par
401     {\cf18 double} Modifier_Charge;\par
402     {\cf18 double} Action_Potential_Threshold;\par
403 \par
404     c_Charging_Buffer()\par
405     \{\par
406         flg_Not_Done = 0;\par
407         Input_Position = 0;\par
408 \par
409         Current_Highest_Charge = 0;\par
410         Previous_Highest_Charge = 0;\par
411         Base_Charge = 10.00;\par
412         Modifier_Charge = 1.0f;\par
413         Action_Potential_Threshold = 0.0f;\par
414     \}\par
415 \par
416     ~c_Charging_Buffer()\par
417     \{\par
418         Current_Charge.reset();\par
419         Output.reset();\par
420         Treetops.reset();\par
421     \}\par
422 \par
423     {\cf18 void} reset()\par
424     \{\par
425         Current_Charge.reset();\par
426         Output.reset();\par
427         Treetops.reset();\par
428 \par
429         flg_Not_Done = 0;\par
430         Input_Position = 0;\par
431     \}\par
432 \par
433     {\cf20 //=====--            --=====//}\par
434     {\cf20 //==--     CHARGING     --==//}\par
435     {\cf20 //=====--            --=====//}\par
436 \par
437 \par
438     {\cf20 //--  CHARGING FOR ORIGINAL ALGO, USED FOR MSC WHERE ALL PATTERNS ARE TO BE FOUND}\par
439 \par
440     {\cf20 //Charges the outputs back into the charging buffer.}\par
441     {\cf20 // //Reinstated the leg charging at this level, this is for charging nodes based on their position, so a state tier node at position 2 charges only axon hillock 2}\par
442     {\cf20 // }\par
443     {\cf20 // -The Following doesn't apply as the method was moved to CAN level leg firing order arrays. Left these comments as the CAN method limits each node to one charging type per charge so it may be reinstated in the future.}\par
444     {\cf20 // --By keeping the leg charging localized to the parameter we can allow different charging methods to be used on the same node during the same run. I don't know why yet, but this preserves that functionality.}\par
445     {\cf20 // --The leg charging determines the hillock to charge by iterating through it.}\par
446     {\cf20 //void charge_Outputs(int * p_Flg_Leg_Charging, int p_Flg_Leg_Charging_Count)}\par
447     {\cf18 void} charge_Outputs()\par
448     \{\par
449         c_Charging_Linked_List* tmp_LL = Output.Root;\par
450 \par
451         Previous_Highest_Charge = Current_Highest_Charge;\par
452         Current_Highest_Charge = 0;\par
453 \par
454         {\cf18 double} tmp_Charge = 0;\par
455         {\cf18 double} tmp_Charge_Percentage = 0.0f;\par
456 \par
457         {\cf19 while} (tmp_LL != NULL)\par
458         \{\par
459             {\cf20 //---std::cout << "\\n " << tmp_LL->NID->NID << " T->" << tmp_LL->NID->Type << " ";}\par
460             {\cf20 //---tmp_LL->NID->bp_O();}\par
461 \par
462             {\cf19 if} (tmp_LL->NID == NULL) \{ tmp_LL = tmp_LL->Next; {\cf19 continue}; \}\par
463 \par
464             {\cf20 //---std::cout << " tmp_Charge = " << " (((" << tmp_LL->Charge << " * " << Modifier_Charge << ") / " << Previous_Highest_Charge << ") * " << Base_Charge << ")";}\par
465 \par
466             tmp_Charge_Percentage = ((tmp_LL->Charge * Modifier_Charge) / Previous_Highest_Charge);\par
467             tmp_Charge = double(tmp_Charge_Percentage * Base_Charge);\par
468 \par
469             {\cf20 //---std::cout << " c->" << tmp_Charge;}\par
470 \par
471             {\cf19 if} (tmp_Charge < (Base_Charge * Action_Potential_Threshold)) \{ tmp_LL = tmp_LL->Next; {\cf19 continue}; \}\par
472 \par
473             {\cf20 //We use leg index selection instead of L/R}\par
474             {\cf19 for} ({\cf18 int} cou_H = 0; cou_H < tmp_LL->NID->Axon_Hillock_Count; cou_H++)\par
475             \{\par
476                 {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < tmp_LL->NID->Axon_Count[cou_H]; cou_A++)\par
477                 \{\par
478                     submit(tmp_LL->NID->Axons[cou_H][cou_A], tmp_Charge);\par
479                     {\cf20 //---std::cout << "\\n ~[" << cou_H << "][" << cou_A << "]~  A->" << tmp_LL->NID->Axons[cou_H][cou_A];}\par
480                     {\cf20 //---tmp_LL->NID->Axons[cou_H][cou_A]->bp_O();}\par
481                 \}\par
482             \}\par
483 \par
484             {\cf19 if} (tmp_LL->NID->Axon_Hillock_Count == 0)\par
485             \{\par
486                 Treetops.new_LL((tmp_LL->NID), (tmp_LL->Charge));\par
487             \}\par
488 \par
489             tmp_LL->NID->output_Node_Raw();\par
490 \par
491             tmp_LL = tmp_LL->Next;\par
492         \}\par
493     \}\par
494 \par
495     {\cf20 //=====--                   --=====//}\par
496     {\cf20 //==--     SUBMISSION NODE     --==//}\par
497     {\cf20 //=====--                   --=====//}\par
498 \par
499     {\cf20 //Accepts a submission of nodes to charge, charges the given leg. Used mainly for Chrono.}\par
500     {\cf20 //Use this then gather and begin charging loop.}\par
501     {\cf18 void} charge_Given_Leg(c_Node* p_Node, {\cf18 double} p_Charge = 10.00, {\cf18 int} p_Leg = 0)\par
502     \{\par
503         {\cf20 //Search for the submitted node, if found add the charge.}\par
504         {\cf19 if} (p_Leg < p_Node->Axon_Hillock_Count)\par
505         \{\par
506             {\cf20 //This shouldn't run if the axon count is 0, meaning if the Axons[p_Leg] == NULL it will be fine.}\par
507             {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < p_Node->Axon_Count[p_Leg]; cou_A++)\par
508             \{\par
509                 submit(p_Node->Axons[p_Leg][cou_A], p_Charge);\par
510                 {\cf20 //---std::cout << "\\n ~[" << p_Leg << "][" << cou_A << "]~  A->" << p_Node->Axons[p_Leg][cou_A];}\par
511                 {\cf20 //---p_Node->Axons[p_Leg][cou_A]->bp_O();}\par
512             \}\par
513         \}\par
514         {\cf19 else}\par
515         \{\par
516             std::cerr << {\cf22 "\\n  Error: p_Leg Exceeds p_Node::Axon_Hillock_Count..."};\par
517         \}\par
518     \}\par
519 \par
520     {\cf20 //Accepts a submission of nodes to charge, charges the given legs. Used mainly for Chrono.}\par
521     {\cf20 //Use this then gather and begin charging loop.}\par
522     {\cf20 //It is assumed p_Leg is the same depth as the input.}\par
523     {\cf18 void} charge_Given_Legs(c_Node* p_Node, {\cf18 int} p_Leg_Count, {\cf18 int}* p_Leg, {\cf18 double} p_Charge = 10.00)\par
524     \{\par
525         {\cf19 if} (p_Node != NULL)\par
526         \{\par
527             {\cf18 int} tmp_Top = p_Node->Axon_Hillock_Count;\par
528             {\cf19 if} (tmp_Top > p_Leg_Count) \{ tmp_Top = p_Leg_Count; \}\par
529 \par
530             {\cf19 for} ({\cf18 int} cou_H = 0; cou_H < tmp_Top; cou_H++)\par
531             \{\par
532                 {\cf19 if} (p_Leg[cou_H])\par
533                 \{\par
534                     {\cf20 //This shouldn't run if the axon count is 0, meaning if the Axons[p_Leg] == NULL it will be fine.}\par
535                     {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < p_Node->Axon_Count[cou_H]; cou_A++)\par
536                     \{\par
537                         submit(p_Node->Axons[cou_H][cou_A], p_Charge);\par
538                         {\cf20 //---std::cout << "\\n ~[" << cou_H << "][" << cou_A << "]~  A->" << p_Node->Axons[cou_H][cou_A];}\par
539                         {\cf20 //---p_Node->Axons[cou_H][cou_A]->bp_O();}\par
540                     \}\par
541                 \}\par
542             \}\par
543         \}\par
544     \}\par
545 \par
546     {\cf20 //=====--              --=====//}\par
547     {\cf20 //==--     SUBMISSION     --==//}\par
548     {\cf20 //=====--              --=====//}\par
549 \par
550     {\cf20 //Accepts a submission of nodes to charge, used for CAN.}\par
551     {\cf18 void} submit(c_Node* p_Node, {\cf18 double} p_Charge = 10.00)\par
552     \{\par
553         {\cf20 //Search for the submitted node, if found add the charge.}\par
554         Tree.search(p_Node);\par
555 \par
556         {\cf19 if} (Tree.flg_Foundit)\par
557         \{\par
558             (Tree.get_Current_Node_LL())->Charge += p_Charge;\par
559             {\cf19 if} ((Tree.get_Current_Node_LL())->Charge > Current_Highest_Charge) \{ Current_Highest_Charge = (Tree.get_Current_Node_LL())->Charge; \}\par
560         \}\par
561 \par
562         {\cf19 if} (!Tree.flg_Foundit && p_Node != NULL)\par
563         \{\par
564             {\cf19 if} (p_Charge > Current_Highest_Charge) \{ Current_Highest_Charge = p_Charge; \}\par
565 \par
566             Tree.set_Current_Node_LL(Current_Charge.new_LL(p_Node, p_Charge));\par
567         \}\par
568     \}\par
569 \par
570     {\cf20 //=====--             --=====//}\par
571     {\cf20 //==--     GATHERING     --==//}\par
572     {\cf20 //=====--             --=====//}\par
573 \par
574     {\cf20 //For gathering the Opp}\par
575     {\cf20 //>Target Tier - 1}\par
576     {\cf20 //>charge}\par
577     {\cf20 //>gather}\par
578     {\cf20 //>flush(Target_Tier)}\par
579 \par
580     {\cf20 //Gathers the output nodes and resets the tree for the next iteration.}\par
581     {\cf18 void} gather()\par
582     \{\par
583         {\cf20 //Delete the old Output.}\par
584         Output.reset();\par
585 \par
586         {\cf20 //Reassign the linked lists.}\par
587         Output.Root = Current_Charge.Root;\par
588         Output.Depth = Current_Charge.Depth;\par
589 \par
590         Current_Charge.Root = NULL;\par
591         Current_Charge.reset();\par
592 \par
593         {\cf20 //Delete the tree.}\par
594         Tree.reset();\par
595 \par
596         {\cf20 //Sets the done flag if Output == NULL.}\par
597         flg_Not_Done = 1;\par
598         {\cf19 if} ((Output.Root == NULL)) \{ flg_Not_Done = 0; \}\par
599     \}\par
600 \par
601     {\cf20 //Charges the outputs back into the charging buffer.}\par
602     {\cf18 double} gather_Treetops()\par
603     \{\par
604         c_Charging_Linked_List* tmp_LL = Treetops.Root;\par
605         c_Charging_Linked_List_Handler tmp_Treetops_LLH;;\par
606         tmp_Treetops_LLH.Root = Treetops.Root;\par
607 \par
608         {\cf18 double} tmp_Current_Highest_Charge = 0;\par
609 \par
610         {\cf18 double} tmp_Charge = 0;\par
611 \par
612         {\cf20 //Find the current highest charge.}\par
613         {\cf19 while} (tmp_LL != NULL)\par
614         \{\par
615             {\cf19 if} (tmp_LL->NID == NULL) \{ tmp_LL = tmp_LL->Next; {\cf19 continue}; \}\par
616 \par
617             {\cf19 if} (tmp_Current_Highest_Charge < tmp_LL->Charge) \{ tmp_Current_Highest_Charge = tmp_LL->Charge; \}\par
618 \par
619             tmp_LL = tmp_LL->Next;\par
620         \}\par
621 \par
622         Treetops.Root = NULL;\par
623         Treetops.reset();\par
624         tmp_LL = tmp_Treetops_LLH.Root;\par
625 \par
626         {\cf19 while} (tmp_LL != NULL)\par
627         \{\par
628             {\cf19 if} (tmp_LL->NID == NULL) \{ tmp_LL = tmp_LL->Next; {\cf19 continue}; \}\par
629 \par
630             tmp_Charge = (((tmp_LL->Charge * Modifier_Charge) / tmp_Current_Highest_Charge) * Base_Charge);\par
631 \par
632             {\cf19 if} (tmp_Charge < (Base_Charge * Action_Potential_Threshold)) \{ tmp_LL = tmp_LL->Next; {\cf19 continue}; \}\par
633 \par
634             Treetops.new_LL(tmp_LL->NID, (tmp_Charge));\par
635 \par
636             tmp_LL = tmp_LL->Next;\par
637         \}\par
638 \par
639         tmp_Treetops_LLH.reset();\par
640 \par
641         {\cf19 return} tmp_Current_Highest_Charge;\par
642     \}\par
643 \par
644     {\cf20 //=====--                       --=====//}\par
645     {\cf20 //==--     CLEANUP & ALLOCATION    --==//}\par
646     {\cf20 //=====--                       --=====//}\par
647 \par
648 \par
649     {\cf20 //Destroys the output buffers.}\par
650     {\cf18 void} destroy_Output_Buffers()\par
651     \{\par
652         {\cf20 //Delete the old Output.}\par
653         Output.reset();\par
654     \}\par
655 \par
656     {\cf20 //=====--          --=====//}\par
657     {\cf20 //==--     OUTPUT     --==//}\par
658     {\cf20 //=====--          --=====//}\par
659 \par
660     {\cf20 //Outputs all of the buffers.}\par
661     {\cf18 void} output_All_Buffers()\par
662     \{\par
663         {\cf20 //system("CLS");}\par
664         std::cout << {\cf22 "\\n Charge_LL->"} << Current_Charge.Depth << {\cf22 " ->"};\par
665         output_Charge_LL();\par
666         std::cout << {\cf22 "\\n Output_LL->"} << Output.Depth << {\cf22 " ->"};\par
667         output_Output_LL();\par
668         std::cout << {\cf22 "\\n Treetops->"} << Treetops.Depth << {\cf22 " ->"};\par
669         output_Treetops();\par
670     \}\par
671 \par
672     {\cf20 //Outputs the buffer.}\par
673     {\cf18 void} output_Tree()\par
674     \{\par
675         Tree.output_Tree();\par
676     \}\par
677 \par
678     {\cf20 //Outputs the Current_Charge_LL.}\par
679     {\cf18 void} output_Charge_LL()\par
680     \{\par
681         {\cf20 //---std::cout << "\\n\\t Current_Charge_LL->";}\par
682         {\cf19 if} (Current_Charge.Root == NULL) \{ std::cout << {\cf22 "empty..."}; {\cf19 return}; \}\par
683         Current_Charge.Root->output_LL();\par
684         {\cf20 //---std::cout << " ~Fing"; std::cout.flush();}\par
685     \}\par
686 \par
687     {\cf20 //Outputs the Output_LL.}\par
688     {\cf18 void} output_Output_LL()\par
689     \{\par
690         {\cf20 //---std::cout << "\\n\\t Output_LL->";}\par
691         {\cf19 if} (Output.Root == NULL) \{ std::cout << {\cf22 "empty..."}; {\cf19 return}; \}\par
692         Output.Root->output_LL();\par
693         {\cf20 //---std::cout << " ~Fing"; std::cout.flush();}\par
694     \}\par
695 \par
696     {\cf20 //Outputs the Treetops.}\par
697     {\cf18 void} output_Treetops()\par
698     \{\par
699         std::cout << {\cf22 "\\n\\t Treetops_LL->"};\par
700         {\cf19 if} (Treetops.Root == NULL) \{ std::cout << {\cf22 "empty..."}; {\cf19 return}; \}\par
701         {\cf20 //Treetops.Root->output_LL();}\par
702         Treetops.output();\par
703         {\cf20 //---std::cout << " ~Fing"; std::cout.flush();}\par
704     \}\par
705 \};\par
706 \par
707 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Construct.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Construct.h}
{\xe \v include/NT4/c_Construct.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
12 {\cf20 //The construct encapsulates the node network, the CANs, I/O, granulation filter, uinterface, actuator interface, and I/O tables.}\par
13 {\cf20 //The result is that after setting up the network the user can use it like a black box.}\par
14 {\cf17 class }c_Construct\par
15 \{\par
16 {\cf17 public}:\par
17 \par
18     {\cf20 //The shared node network.}\par
19     c_Node_Network Nodes;\par
20 \par
21     {\cf20 //The names of each assembly within the construct.}\par
22     std::string* Assembly_Names;\par
23 \par
24     {\cf20 //These are the files each assembly uses for input, defaults to "Input.ssv"}\par
25     std::string* Assembly_Input_Files;\par
26 \par
27     {\cf20 //The file for each assembly to use as output.}\par
28     std::string* Assembly_Output_Files;\par
29 \par
30     {\cf20 //For each assembly we have an index in the State_Tree[], CAN[], etc.}\par
31     {\cf18 int} Assembly_Count;\par
32 \par
33     {\cf20 //This holds the array of CAN scaffold structures.}\par
34     {\cf20 //c_Base_CAN is a base class.}\par
35     c_Base_CAN** CAN; \par
36 \par
37     {\cf20 //This array keeps track of what type each CAN is.}\par
38     std::string* CAN_Type;\par
39 \par
40     c_Construct()\par
41     \{\par
42         Assembly_Count = 0; {\cf20 //Variables dependent on this value: Assembly_Names, CAN}\par
43         Assembly_Names = NULL;\par
44         Assembly_Input_Files = NULL;\par
45         Assembly_Output_Files = NULL;\par
46         CAN = NULL;\par
47         CAN_Type = NULL;\par
48     \}\par
49 \par
50     {\cf20 //I need to refactor this jfc}\par
51     {\cf18 int} add_Assembly(std::string p_Assembly_Name)\par
52     \{\par
53         std::string* tmp_Names;\par
54         tmp_Names = {\cf17 new} std::string[Assembly_Count];\par
55 \par
56         std::string* tmp_Input_Files;\par
57         tmp_Input_Files = {\cf17 new} std::string[Assembly_Count];\par
58 \par
59         std::string* tmp_Output_Files;\par
60         tmp_Output_Files = {\cf17 new} std::string[Assembly_Count];\par
61         \par
62         c_Base_CAN** tmp_CAN;\par
63         tmp_CAN = {\cf17 new} c_Base_CAN * [Assembly_Count];\par
64 \par
65         std::string* tmp_CAN_Type;\par
66         tmp_CAN_Type = {\cf17 new} std::string[Assembly_Count];\par
67 \par
68         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Assembly_Count; cou_Index++)\par
69         \{\par
70             tmp_Names[cou_Index] = Assembly_Names[cou_Index];\par
71 \par
72             tmp_Input_Files[cou_Index] = Assembly_Input_Files[cou_Index];\par
73             tmp_Output_Files[cou_Index] = Assembly_Output_Files[cou_Index];\par
74 \par
75             tmp_CAN_Type[cou_Index] = CAN_Type[cou_Index];\par
76             tmp_CAN[cou_Index] = CAN[cou_Index];\par
77         \}\par
78 \par
79         {\cf19 if} (Assembly_Names != NULL) \{ {\cf17 delete}[] Assembly_Names; \}\par
80         {\cf19 if} (Assembly_Input_Files != NULL) \{ {\cf17 delete}[] Assembly_Input_Files; \}\par
81         {\cf19 if} (Assembly_Output_Files != NULL) \{ {\cf17 delete}[] Assembly_Output_Files; \}\par
82         {\cf19 if} (CAN != NULL) \{ {\cf17 delete}[] CAN; \}\par
83         {\cf19 if} (CAN_Type != NULL) \{ {\cf17 delete}[] CAN_Type; \}\par
84 \par
85         Assembly_Names = {\cf17 new} std::string[Assembly_Count + 1];\par
86         Assembly_Input_Files = {\cf17 new} std::string[Assembly_Count + 1];\par
87         Assembly_Output_Files = {\cf17 new} std::string[Assembly_Count + 1];\par
88         CAN = {\cf17 new} c_Base_CAN * [Assembly_Count + 1];\par
89         CAN_Type = {\cf17 new} std::string[Assembly_Count + 1];\par
90 \par
91 \par
92         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Assembly_Count; cou_Index++)\par
93         \{\par
94             Assembly_Names[cou_Index] = tmp_Names[cou_Index];\par
95 \par
96             Assembly_Input_Files[cou_Index] = tmp_Input_Files[cou_Index];\par
97             Assembly_Output_Files[cou_Index] = tmp_Output_Files[cou_Index];\par
98 \par
99             CAN[cou_Index] = tmp_CAN[cou_Index];\par
100             tmp_CAN[cou_Index] = NULL;\par
101 \par
102             CAN_Type[cou_Index] = tmp_CAN_Type[cou_Index];\par
103         \}\par
104 \par
105         {\cf17 delete}[] tmp_Names; tmp_Names = NULL;\par
106         {\cf17 delete}[] tmp_Input_Files; tmp_Input_Files = NULL;\par
107         {\cf17 delete}[] tmp_Output_Files; tmp_Output_Files = NULL;\par
108         {\cf17 delete}[] tmp_CAN; tmp_CAN = NULL;\par
109         {\cf17 delete}[] tmp_CAN_Type; tmp_CAN_Type = NULL;\par
110 \par
111         Assembly_Names[Assembly_Count] = p_Assembly_Name;\par
112 \par
113         Assembly_Input_Files[Assembly_Count] = {\cf22 "Input\\\\"} + p_Assembly_Name + {\cf22 ".Input.ssv"};\par
114         Assembly_Output_Files[Assembly_Count] = {\cf22 "Output\\\\"} + p_Assembly_Name + {\cf22 ".Output.ssv"};\par
115 \par
116         {\cf20 //The CAN is made later because there are different subtypes.}\par
117         CAN[Assembly_Count] = NULL;\par
118 \par
119         CAN_Type[Assembly_Count] = {\cf22 "NONE"};\par
120 \par
121         Assembly_Count++;\par
122 \par
123         {\cf20 //Return the index of the newly created assembly.}\par
124         {\cf19 return} Assembly_Count - 1;\par
125     \}\par
126 \par
127 \par
128     {\cf20 //==--- DIRECT_HOOK ---==//}\par
129     {\cf20 //This doesn't make sense to run through the API}\par
130     c_Node* get_Node_Ref_By_NID(uint64_t p_NID)\par
131     \{\par
132         {\cf19 return} Nodes.get_Node_Ref_By_NID(p_NID);\par
133     \}\par
134 \par
135     \par
136 \par
137 \par
138 \par
139 \par
140 \par
141 {\cf20 //      ---==================---}\par
142 {\cf20 //     ---====================---}\par
143 {\cf20 //    ---======================---}\par
144 {\cf20 //   ---========================---}\par
145 {\cf20 //  ---==   NT4 Deep Control   ==---}\par
146 {\cf20 //   ---========================---}\par
147 {\cf20 //    ---======================---}\par
148 {\cf20 //     ---====================---}\par
149 {\cf20 //      ---==================---}\par
150   \par
151   \par
152   \par
153 {\cf20 //    ---==========---}\par
154 {\cf20 //   ---============---}\par
155 {\cf20 //  ---==   Node   ==---}\par
156 {\cf20 //   ---============---}\par
157 {\cf20 //    ---==========---}\par
158 \par
159     {\cf20 //==--- DIRECT_HOOK ---==//}\par
160     {\cf20 //(0: State), (1: Branch), (2: Treetop), (3: State/Treetop)}\par
161     {\cf18 void} set_Type(c_Node * p_Node, uint8_t p_Type)\par
162     \{\par
163         {\cf19 if} (p_Node != NULL)\par
164         \{\par
165             p_Node->set_Type(p_Type);\par
166         \}\par
167     \}\par
168 \par
169 \par
170     {\cf20 //==--- DIRECT_HOOK ---==//}\par
171     {\cf20 //Adds an axon to the axon list at the given index, if the index doesn't exist then exist it with resize_Axon_Hillocks()}\par
172     {\cf18 void} add_Axon_Index(c_Node* p_Node, c_Node* p_Axon, {\cf18 int} p_Index)\par
173     \{\par
174         {\cf19 if} (p_Node != NULL)\par
175         \{\par
176             p_Node->add_Axon_Index(p_Axon, p_Index);\par
177         \}\par
178     \}\par
179 \par
180 \par
181     {\cf20 //==--- DIRECT_HOOK ---==//}\par
182     {\cf20 //Sets the dendrites of the node.}\par
183     {\cf20 //This assumes the node has no dendrites yet, if it does you be dangling and jangling}\par
184     {\cf18 void} set_Dendrites(c_Node* p_Node, {\cf18 int} p_Count, c_Node** p_Dendrites)\par
185     \{\par
186         {\cf19 if} (p_Node != NULL)\par
187         \{\par
188             p_Node->set_Dendrites(p_Dendrites, p_Count);\par
189         \}\par
190     \}\par
191 \par
192 \par
193     {\cf20 //==--- DIRECT_HOOK ---==//}\par
194     {\cf20 //Searches the axons to see if an upper tier connection exists.}\par
195     {\cf20 //This is always called from the first leg, that is why we separate _F from normal.}\par
196     c_Node* does_Upper_Tier_Connection_Exist({\cf18 int} p_Count, c_Node** p_Nodes)\par
197     \{\par
198         {\cf19 return} Nodes.does_Upper_Tier_Connection_Exist(p_Nodes, p_Count);\par
199     \}\par
200 \par
201 \par
202     {\cf20 //==--- DIRECT_HOOK ---==//}\par
203     {\cf20 //Checks if the given node matches a dendrite on the right leg.}\par
204     {\cf18 bool} does_Lower_Connection_Exist(c_Node * p_Node, {\cf18 int} p_Count, c_Node** p_Nodes)\par
205     \{\par
206         {\cf19 if} (p_Node != NULL)\par
207         \{\par
208             {\cf19 return} p_Node->does_Lower_Connection_Exist(p_Nodes, p_Count);\par
209         \}\par
210         {\cf19 return} 0;\par
211     \}\par
212 \par
213 \par
214 \par
215     {\cf20 //==--- DIRECT_HOOK ---==//}\par
216     {\cf20 //Binds a node to a quanta of data, the state of the input.}\par
217     {\cf18 void} bind_State(c_Node * p_Node, uint64_t p_State)\par
218     \{\par
219         {\cf19 if} (p_Node != NULL)\par
220         \{\par
221             p_Node->bind_State(p_State);\par
222         \}\par
223     \}\par
224 \par
225 \par
226 \par
227     {\cf20 //==--- DIRECT_HOOK ---==//}\par
228     {\cf20 //Initiates a backpropagation that outputs the pattern represented by this node.}\par
229     {\cf18 void} bp_O(c_Node * p_Node)\par
230     \{\par
231         {\cf19 if} (p_Node != NULL)\par
232         \{\par
233             p_Node->bp_O();\par
234         \}\par
235     \}\par
236 \par
237 \par
238 \par
239     {\cf20 //==--- DIRECT_HOOK ---==//}\par
240     {\cf20 //The CAN handles this for backpropagating a trace into a given CAN input. "gather_Given_Trace(uint64_t p_NID)"}\par
241     {\cf18 void} bp_Trace_O(c_Node * p_Node, c_Linked_List_Handler* p_LL)\par
242     \{\par
243         {\cf19 if} ((p_Node != NULL) && (p_LL != NULL))\par
244         \{\par
245             p_Node->bp_Trace_O(p_LL);\par
246         \}\par
247     \}\par
248 \par
249 \par
250 \par
251     {\cf20 //==--- DIRECT_HOOK ---==//}\par
252     {\cf20 //Outputs the ugly raw info dump for the node.}\par
253     {\cf18 void} output_Node_Raw(c_Node * p_Node)\par
254     \{\par
255         {\cf19 if} (p_Node != NULL)\par
256         \{\par
257             p_Node->output_Node_Raw();\par
258         \}\par
259     \}\par
260 \par
261 \par
262 \par
263     {\cf20 //==--- DIRECT_HOOK ---==//}\par
264     {\cf20 //Casts the node address to char() and outputs it.}\par
265     {\cf18 void} output_Node_Char(c_Node * p_Node)\par
266     \{\par
267         {\cf19 if} (p_Node != NULL)\par
268         \{\par
269             p_Node->output_Node_Char();\par
270         \}\par
271     \}\par
272 \par
273 \par
274     \par
275   \par
276   \par
277 {\cf20 //    ---==================---}\par
278 {\cf20 //   ---====================---}\par
279 {\cf20 //  ---==   Node_Network   ==---}\par
280 {\cf20 //   ---====================---}\par
281 {\cf20 //    ---==================---}\par
282   \par
283     {\cf20 //==--- DIRECT_HOOK ---==//}\par
284     {\cf20 //---==  register_New_Construct  ==---//}\par
285     {\cf18 int} register_New_Construct()\par
286     \{\par
287         {\cf19 return} Nodes.register_New_Construct();\par
288     \}\par
289 \par
290   \par
291     {\cf20 //==--- DIRECT_HOOK ---==//}\par
292     {\cf20 //Creates a new node and adds it to the fractal tree.}\par
293     {\cf20 //Each node is stored as a link in a linked list.}\par
294     c_Node* new_Node()\par
295     \{\par
296         {\cf19 return} Nodes.new_Node();\par
297     \}\par
298   \par
299 \par
300     {\cf20 //==--- DIRECT_HOOK ---==//}\par
301     {\cf20 //Creates a new node, then adds it to the state tree.}\par
302     {\cf20 //Assumes the construct is already registered so the index is valid.}\par
303     c_Node* new_State_Node({\cf18 int} p_Assembly, {\cf18 double} p_State)\par
304     \{\par
305         {\cf19 return} Nodes.new_State_Node(p_Assembly, p_State);\par
306     \}\par
307   \par
308 \par
309     {\cf20 //==--- DIRECT_HOOK ---==//}\par
310     {\cf20 //Creates a connection between nodes.}\par
311     {\cf20 //p_To forms dendritic connections to p_From, and on p_From you have the axonic connections.}\par
312     {\cf18 void} create_Connections(c_Node* p_To, {\cf18 int} p_Count, c_Node** p_From)\par
313     \{\par
314         Nodes.create_Connections(p_To, p_From, p_Count);\par
315     \}\par
316   \par
317 \par
318     {\cf20 //==--- DIRECT_HOOK ---==//}\par
319     {\cf20 //Checks if an upper tier node exists.}\par
320     c_Node* does_Upper_Tier_Connection_Exist_Network({\cf18 int} p_Count, c_Node** p_Legs)\par
321     \{\par
322         {\cf19 return} Nodes.does_Upper_Tier_Connection_Exist(p_Legs, p_Count);\par
323     \}\par
324   \par
325 \par
326     {\cf20 //==--- DIRECT_HOOK ---==//}\par
327     {\cf20 //Gets an upper tier node based on the given legs. Will create it if not found and give it the type 1.}\par
328     c_Node* get_Upper_Tier_Node({\cf18 int} p_Count, c_Node** p_Legs)\par
329     \{\par
330         {\cf19 return} Nodes.get_Upper_Tier_Node(p_Legs, p_Count, 1);\par
331     \}\par
332 \par
333   \par
334     {\cf20 //==--- DIRECT_HOOK ---==//}\par
335     {\cf20 //If a state node exists in the given construct index then return it.}\par
336     {\cf20 //Otherwise return NULL.}\par
337     {\cf20 //This assumes the [Index] is valid}\par
338     c_Node* does_State_Node_Exist({\cf18 int} p_Assembly, uint64_t p_State)\par
339     \{\par
340         {\cf19 return} Nodes.does_State_Node_Exist(p_Assembly, p_State);\par
341     \}\par
342   \par
343 \par
344     {\cf20 //==--- DIRECT_HOOK ---==//}\par
345     {\cf20 //Checks to see if a node in the given assembly is bound to the given state, if not the node is created.}\par
346     c_Node* get_State_Node({\cf18 int} p_Assembly, uint64_t p_State)\par
347     \{\par
348         {\cf19 return} Nodes.get_State_Node(p_Assembly, p_State);\par
349     \}\par
350   \par
351 \par
352     {\cf20 //==--- DIRECT_HOOK ---==//}\par
353     {\cf20 //Iterates through every node and outputs their bp_O()}\par
354     {\cf18 void} output_BP()\par
355     \{\par
356         Nodes.output_BP();\par
357     \}\par
358 \par
359   \par
360     {\cf20 //==--- DIRECT_HOOK ---==//}\par
361     {\cf20 //Finds given NID and outputs the bp_O()}\par
362     {\cf18 void} output_BP_NID({\cf18 int} p_NID)\par
363     \{\par
364         Nodes.output_BP_NID(p_NID);\par
365     \}\par
366 \par
367   \par
368     {\cf20 //---==  DIRECT_HOOK  ==---//}\par
369     {\cf20 //Outputs all of the nodes as raw.}\par
370     {\cf18 void} output_Node_Network()\par
371     \{\par
372         Nodes.output_Raw();\par
373     \}\par
374 \par
375 \par
376 \par
377     {\cf20 //    ---=========---}\par
378     {\cf20 //   ---===========---}\par
379     {\cf20 //  ---==   CAN   ==---}\par
380     {\cf20 //   ---===========---}\par
381     {\cf20 //    ---=========---}\par
382 \par
383     {\cf20 //==--- DIRECT_HOOK ---==//}\par
384     {\cf20 //This encodes the p_Input data, if the nodes aren't found they are created, used for training.}\par
385     {\cf18 void} encode({\cf18 int} p_Assembly, {\cf18 int} p_Depth = 0, uint64_t* p_Input = NULL)\par
386     \{\par
387         CAN[p_Assembly]->encode(p_Input, p_Depth);\par
388     \}\par
389 \par
390 \par
391     {\cf20 //==--- DIRECT_HOOK ---==//}\par
392     {\cf20 //This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN}\par
393     {\cf20 //Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs.}\par
394     {\cf20 //Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.}\par
395     {\cf18 void} query({\cf18 int} p_Assembly, uint64_t* p_Input = NULL, {\cf18 int} p_Depth = 0, {\cf18 int} p_Charging_Style = -1, {\cf18 int} p_Leg = 0, {\cf18 int}* p_Legs = NULL)\par
396     \{\par
397         CAN[p_Assembly]->query(p_Input, p_Depth, p_Charging_Style, p_Leg, p_Legs);\par
398     \}\par
399 \par
400 \par
401     {\cf20 //==--- DIRECT_HOOK ---==//}\par
402     {\cf20 //This allows for passing unordered sets of nodes}\par
403     {\cf18 void} submit_Set({\cf18 int} p_Assembly, {\cf18 int} p_Depth, uint64_t* p_Input)\par
404     \{\par
405         CAN[p_Assembly]->submit_Set(p_Input, p_Depth);\par
406     \}\par
407 \par
408 \par
409     {\cf20 //==--- DIRECT_HOOK ---==//}\par
410     {\cf20 //Gets the treetop node for a given assembly.}\par
411     {\cf20 //This doesn't make sense to create an API for.}\par
412     {\cf20 //This returns the treetop node at a given index, for most structures this will be a single node, but for those like stiched-base networks with a treetop node count equal to the input node count then you can access them by index.}\par
413     c_Node* get_Treetop({\cf18 int} p_Assembly)\par
414     \{\par
415         {\cf19 return} (CAN[p_Assembly]->get_Treetop());\par
416     \}\par
417 \par
418 \par
419     {\cf20 //==--- DIRECT_HOOK ---==//}\par
420     {\cf20 //Gets the treetop node for a given assembly.}\par
421     uint64_t get_Treetop_NID({\cf18 int} p_Assembly)\par
422     \{\par
423         {\cf19 if} (CAN[p_Assembly]->get_Treetop() != NULL)\par
424         \{\par
425             {\cf19 return} (CAN[p_Assembly]->get_Treetop())->NID;\par
426         \}\par
427         {\cf19 return} 0;\par
428     \}\par
429 \par
430 \par
431     {\cf20 //==--- DIRECT_HOOK ---==//}\par
432     {\cf20 //Gets the treetop node for a given assembly.}\par
433     uint64_t get_Treetop_NID_At_Given_Index({\cf18 int} p_Assembly, {\cf18 int} p_Index)\par
434     \{\par
435         {\cf19 if} (CAN[p_Assembly]->get_Treetop(p_Index) != NULL)\par
436         \{\par
437             {\cf19 return} (CAN[p_Assembly]->get_Treetop(p_Index))->NID;\par
438         \}\par
439         {\cf19 return} 0;\par
440     \}\par
441 \par
442 \par
443     {\cf20 //==--- DIRECT_HOOK ---==//}\par
444     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
445     {\cf18 void} gather_Given_Trace({\cf18 int} p_Assembly, uint64_t p_NID)\par
446     \{\par
447         CAN[p_Assembly]->gather_Given_Trace(p_NID);\par
448         \par
449         gather_Output(p_Assembly);\par
450     \}\par
451 \par
452 \par
453     {\cf20 //==--- DIRECT_HOOK ---==//}\par
454     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
455     {\cf18 void} gather_Given_Trace_uint({\cf18 int} p_Assembly, uint64_t p_NID)\par
456     \{\par
457         CAN[p_Assembly]->gather_Given_Trace(p_NID);\par
458         \par
459         gather_Output_uint(p_Assembly);\par
460     \}\par
461 \par
462 \par
463     {\cf20 //==--- DIRECT_HOOK ---==//}\par
464     {\cf20 //Gathers all the traces as it says.}\par
465     {\cf18 void} gather_All_Traces({\cf18 int} p_Assembly)\par
466     \{\par
467         CAN[p_Assembly]->gather_All_Traces();\par
468 \par
469         gather_Output(p_Assembly);\par
470     \}\par
471 \par
472 \par
473     {\cf20 //==--- DIRECT_HOOK ---==//}\par
474     {\cf20 //Gathers all the traces as it says.}\par
475     {\cf18 void} gather_All_Traces_uint({\cf18 int} p_Assembly)\par
476     \{\par
477         CAN[p_Assembly]->gather_All_Traces();\par
478 \par
479         gather_Output_uint(p_Assembly);\par
480     \}\par
481 \par
482 \par
483     {\cf20 //==--- DIRECT_HOOK ---==//}\par
484     {\cf20 //Wipe the input array.}\par
485     {\cf18 void} reset_Input({\cf18 int} p_Assembly)\par
486     \{\par
487         CAN[p_Assembly]->reset_Input();\par
488     \}\par
489 \par
490 \par
491     {\cf20 //==--- DIRECT_HOOK ---==//}\par
492     {\cf20 //Associate the CAN with a network from which to draw nodes.}\par
493     {\cf20 //This doesn't make sense to wrap in the API.}\par
494     {\cf18 void} set_NNet({\cf18 int} p_Assembly, c_Node_Network* p_NNet)\par
495     \{\par
496         CAN[p_Assembly]->set_NNet(p_NNet);\par
497     \}\par
498 \par
499 \par
500     {\cf20 //==--- DIRECT_HOOK ---==//}\par
501     {\cf20 //Sets the index for the state_Node_Tree in the c_Node_Network::State_Nodes[]}\par
502     {\cf18 void} set_State_Nodes_Index({\cf18 int} p_Assembly, {\cf18 int} p_Index)\par
503     \{\par
504         CAN[p_Assembly]->set_State_Nodes_Index(p_Index);\par
505     \}\par
506 \par
507 \par
508     {\cf20 //==--- DIRECT_HOOK ---==//}\par
509     {\cf20 //Sets the input to the given uint64_t array.}\par
510     {\cf20 //The input array is 1D.}\par
511     {\cf18 void} set_Input({\cf18 int} p_Assembly, {\cf18 int} p_Input_Depth, uint64_t* p_Input)\par
512     \{\par
513         CAN[p_Assembly]->set_Input(p_Input, p_Input_Depth);\par
514     \}\par
515 \par
516     {\cf20 //==--- DIRECT_HOOK ---==//}\par
517     {\cf20 //Sets the input to the given uint64_t array.}\par
518     {\cf20 //The input array is 2D.}\par
519     {\cf18 void} set_2D_Input({\cf18 int} p_Assembly, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, uint64_t** p_Input)\par
520     \{\par
521         CAN[p_Assembly]->set_2D_Input(p_Input, p_X_Depth, p_Y_Depth);\par
522     \}\par
523 \par
524     {\cf20 //==--- DIRECT_HOOK ---==//}\par
525     {\cf20 //Sets the input to the given uint64_t array.}\par
526     {\cf20 //The input array is 3D.}\par
527     {\cf18 void} set_3D_Input({\cf18 int} p_Assembly, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, {\cf18 int} p_Z_Depth, uint64_t*** p_Input)\par
528     \{\par
529         CAN[p_Assembly]->set_3D_Input(p_Input, p_X_Depth, p_Y_Depth, p_Z_Depth);\par
530     \}\par
531 \par
532 \par
533     {\cf20 //==--- DIRECT_HOOK ---==//}\par
534     {\cf20 //This is used for setting the input array to reflect a sequence of characters.}\par
535     {\cf18 void} set_Input_String({\cf18 int} p_Assembly, std::string p_Input)\par
536     \{\par
537         CAN[p_Assembly]->set_Input_String(p_Input);\par
538     \}\par
539 \par
540 \par
541     {\cf20 //==--- DIRECT_HOOK ---==//}\par
542     {\cf20 //Outputs the scaffold as addresses.}\par
543     {\cf18 void} output_Scaffold({\cf18 int} p_Assembly)\par
544     \{\par
545         CAN[p_Assembly]->output_Scaffold();\par
546     \}\par
547 \par
548 \par
549     {\cf20 //==--- DIRECT_HOOK ---==// }\par
550     {\cf20 //==--- CLI_HOOK ---==//    }\par
551     {\cf20 //    ---==  output_input [ASSEMBLY_ID]  ==---}\par
552     {\cf20 //      Outputs the input of the given assembly to the console.}\par
553     {\cf20 //Outputs the input for the Assembly.}\par
554     {\cf18 void} output_Input({\cf18 int} p_Assembly)\par
555     \{\par
556         CAN[p_Assembly]->output_Input();\par
557     \}\par
558 \par
559 \par
560     {\cf20 //==--- DIRECT_HOOK ---==// }\par
561     {\cf20 //==--- CLI_HOOK ---==//    }\par
562     {\cf20 //    ---==  output_input [ASSEMBLY_ID]  ==---}\par
563     {\cf20 //      Outputs the input of the given assembly to the console.}\par
564     {\cf20 //Outputs the input for the Assembly.}\par
565     {\cf18 void} output_Input_uint({\cf18 int} p_Assembly)\par
566     \{\par
567         CAN[p_Assembly]->output_Input(1);\par
568     \}\par
569 \par
570 \par
571     {\cf20 //==--- DIRECT_HOOK ---==//}\par
572     {\cf20 //The output trace set is output.}\par
573     {\cf18 void} output_Output({\cf18 int} p_Assembly)\par
574     \{\par
575         CAN[p_Assembly]->output_Output(0);\par
576     \}\par
577 \par
578 \par
579     {\cf20 //==--- DIRECT_HOOK ---==//}\par
580     {\cf20 //The output trace set is output.}\par
581     {\cf18 void} output_Output_uint({\cf18 int} p_Assembly)\par
582     \{\par
583         CAN[p_Assembly]->output_Output(1);\par
584     \}\par
585 \par
586 \par
587     {\cf20 //==--- DIRECT_HOOK ---==//}\par
588     {\cf20 //Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.}\par
589     {\cf18 void} output_Scaffold_Char({\cf18 int} p_Assembly)\par
590     \{\par
591         CAN[p_Assembly]->output_Scaffold_Char();\par
592     \}\par
593 \par
594 \par
595 \par
596 \par
597 \par
598     {\cf20 //      ---====================---}\par
599     {\cf20 //     ---======================---}\par
600     {\cf20 //    ---========================---}\par
601     {\cf20 //   ---==========================---}\par
602     {\cf20 //  ---==   NT4 specific hooks   ==---}\par
603     {\cf20 //   ---==========================---}\par
604     {\cf20 //    ---========================---}\par
605     {\cf20 //     ---======================---}\par
606     {\cf20 //      ---====================---}\par
607 \par
608 \par
609 \par
610     {\cf20 //    ---======================================---}\par
611     {\cf20 //   ---========================================---}\par
612     {\cf20 //  ---==   Used to register new assemblies.   ==---}\par
613     {\cf20 //   ---========================================---}\par
614     {\cf20 //    ---======================================---}\par
615 \par
616         {\cf20 //    ---==  register_assembly [ASSEMBLY_TYPE] [ASSEMBLY_NAME]  ==---}\par
617         {\cf20 //p_Type is the type of CAN to declare. }\par
618         {\cf20 // "Many_To_One" - The I/O tier has every node connected to a single upper tier node.}\par
619     {\cf18 int} register_Assembly(std::string p_Type, std::string p_Assembly_Name)\par
620     \{\par
621         {\cf18 int} tmp_Assembly_ID = add_Assembly(p_Assembly_Name);\par
622         std::cout << {\cf22 "\\n <Register_Assembly> Name: ->"} << p_Assembly_Name << {\cf22 "<- | Type: ->"} << p_Type << {\cf22 "<- | ID: ->"} << tmp_Assembly_ID << {\cf22 "<- "};\par
623 \par
624         {\cf19 if} (p_Type == {\cf22 "Many_To_One"})\par
625         \{\par
626             std::cout << {\cf22 "\\n      -->Created Many_To_One CAN"};\par
627 \par
628             CAN[tmp_Assembly_ID] = {\cf17 new} c_CAN_Many_To_One;\par
629 \par
630             {\cf20 //Make sure we set the node network for the CAN.}\par
631             CAN[tmp_Assembly_ID]->set_NNet(&Nodes);\par
632 \par
633             CAN[tmp_Assembly_ID]->State_Nodes_Index = Nodes.register_New_Construct();\par
634 \par
635             CAN_Type[tmp_Assembly_ID] = {\cf22 "Many_To_One"};\par
636         \}\par
637         {\cf19 if} (p_Type == {\cf22 "1D_Pyramid"})\par
638         \{\par
639             std::cout << {\cf22 "\\n      -->Created 1D_Pyramid CAN"};\par
640 \par
641             CAN[tmp_Assembly_ID] = {\cf17 new} c_CAN_1D_Pyramid;\par
642 \par
643             {\cf20 //Make sure we set the node network for the CAN.}\par
644             CAN[tmp_Assembly_ID]->set_NNet(&Nodes);\par
645 \par
646             CAN[tmp_Assembly_ID]->State_Nodes_Index = Nodes.register_New_Construct();\par
647 \par
648             CAN_Type[tmp_Assembly_ID] = {\cf22 "1D_Pyramid"};\par
649         \}\par
650         {\cf19 if} (p_Type == {\cf22 "2D_Pyramid"})\par
651         \{\par
652             std::cout << {\cf22 "\\n      -->Created 2D_Pyramid CAN"};\par
653 \par
654             CAN[tmp_Assembly_ID] = {\cf17 new} c_CAN_2D_Pyramid;\par
655 \par
656             {\cf20 //Make sure we set the node network for the CAN.}\par
657             CAN[tmp_Assembly_ID]->set_NNet(&Nodes);\par
658 \par
659             CAN[tmp_Assembly_ID]->State_Nodes_Index = Nodes.register_New_Construct();\par
660 \par
661             CAN_Type[tmp_Assembly_ID] = {\cf22 "2D_Pyramid"};\par
662         \}\par
663         {\cf19 if} (p_Type == {\cf22 "3D_Pyramid"})\par
664         \{\par
665             std::cout << {\cf22 "\\n      -->Created 3D_Pyramid CAN"};\par
666 \par
667             CAN[tmp_Assembly_ID] = {\cf17 new} c_CAN_3D_Pyramid;\par
668 \par
669             {\cf20 //Make sure we set the node network for the CAN.}\par
670             CAN[tmp_Assembly_ID]->set_NNet(&Nodes);\par
671 \par
672             CAN[tmp_Assembly_ID]->State_Nodes_Index = Nodes.register_New_Construct();\par
673 \par
674             CAN_Type[tmp_Assembly_ID] = {\cf22 "3D_Pyramid"};\par
675         \}\par
676 \par
677         {\cf19 return} tmp_Assembly_ID;\par
678     \}\par
679 \par
680 \par
681 \par
682 \par
683     {\cf20 //    ---=====================---}\par
684     {\cf20 //   ---=======================---}\par
685     {\cf20 //  ---==   Input handling.   ==---}\par
686     {\cf20 //   ---=======================---}\par
687     {\cf20 //    ---=====================---}\par
688 \par
689 {\cf20 //    ---==  load_input  ==---}\par
690     {\cf18 int} load_Input({\cf18 int} p_Assembly)\par
691     \{\par
692         std::ifstream InputFile(Assembly_Input_Files[p_Assembly]);\par
693 \par
694         std::string tmp_Input_Full = {\cf22 ""};\par
695         std::string tmp_In = {\cf22 ""};\par
696         {\cf18 int} tmp_Count = 0;\par
697 \par
698         {\cf19 if} (InputFile.is_open())\par
699         \{\par
700             {\cf19 while} (!InputFile.eof())\par
701             \{\par
702                 InputFile >> tmp_In;\par
703                 std::cout << {\cf22 "\\n - [ "} << tmp_Count << {\cf22 " ]: "} << tmp_In;\par
704                 tmp_Count++;\par
705 \par
706                 {\cf19 if} (tmp_Input_Full != {\cf22 ""}) \{ tmp_Input_Full = tmp_Input_Full + {\cf22 " "} + tmp_In; \}\par
707                 {\cf19 if} (tmp_Input_Full == {\cf22 ""}) \{ tmp_Input_Full = tmp_In; \}\par
708 \par
709                 {\cf20 //Neuralman.output_Input();}\par
710             \}\par
711 \par
712             std::cout << {\cf22 "\\n Input.ssv contents: "} << tmp_Input_Full << {\cf22 "\\n"};\par
713 \par
714             {\cf20 //set_Input_1D_string(int p_Assembly, std::string p_Input)}\par
715 \par
716             set_Input(p_Assembly, tmp_Input_Full);\par
717 \par
718             {\cf19 return} 1;\par
719         \}\par
720         {\cf19 else}\par
721         \{\par
722             std::cerr << {\cf22 "\\n Unable to open Input.ssv for set_Input_1D_string ...\\n"};\par
723 \par
724             {\cf19 return} 0;\par
725         \}\par
726 \par
727         {\cf19 return} 1;\par
728     \}\par
729     \par
730 {\cf20 //    ---==  load_input  ==---}\par
731     {\cf18 int} load_Input_uint({\cf18 int} p_Assembly)\par
732     \{\par
733         std::ifstream InputFile(Assembly_Input_Files[p_Assembly]);\par
734 \par
735         {\cf18 int} tmp_Count = 0;\par
736         {\cf18 int} tmp_Current = 0;\par
737         uint64_t* tmp_Input = NULL;\par
738 \par
739         {\cf19 if} (InputFile.is_open())\par
740         \{\par
741             {\cf20 //Get the count:}\par
742             {\cf19 if} (!InputFile.eof())\par
743             \{\par
744                 InputFile >> tmp_Count;\par
745             \}\par
746 \par
747             std::cout << {\cf22 "\\n Count: "} << tmp_Count;\par
748 \par
749             {\cf19 if} (tmp_Count > 0) \par
750             \{\par
751                 tmp_Input = {\cf17 new} uint64_t[tmp_Count];\par
752 \par
753                 {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
754                 \{\par
755                     tmp_Input[cou_Index] = 0;\par
756                 \}\par
757 \par
758                 {\cf19 while} (!InputFile.eof())\par
759                 \{\par
760                     InputFile >> tmp_Input[tmp_Current];\par
761 \par
762                     std::cout << {\cf22 "\\n - [ "} << tmp_Current << {\cf22 " ]: "} << tmp_Input[tmp_Current];\par
763                     tmp_Current++;\par
764                 \}\par
765             \}\par
766 \par
767             set_Input_uint(p_Assembly, tmp_Count, tmp_Input);\par
768 \par
769             {\cf19 if} (tmp_Input != NULL) \{ {\cf17 delete}[] tmp_Input; tmp_Input = NULL; \}\par
770 \par
771             {\cf19 return} 1;\par
772         \}\par
773         {\cf19 else}\par
774         \{\par
775             std::cerr << {\cf22 "\\n Unable to open Input.ssv for set_Input_1D_string ...\\n"};\par
776 \par
777             {\cf19 return} 0;\par
778         \}\par
779 \par
780         {\cf19 return} 1;\par
781     \}\par
782 \par
783     {\cf20 //This function moves a uint from a given construct input index to the output of a given construct by appending it. This allows you to take the backpropagated MSC, Chrono, etc pattern of treetops and append each treetop to the output file of the given construct. So you can then run }\par
784     {\cf20 //Comment left here in case I come back to it. Delete if something has superceded it and this comment will not be potentially needed.}\par
785 \par
786     {\cf20 //    ---==  set_input [ASSEMBLY_ID] [INPUT_STRING]  ==---}\par
787         {\cf20 //Set the value to the passed 1D string of uint64_t}\par
788     {\cf18 void} set_Input({\cf18 int} p_Assembly, std::string p_Input)\par
789     \{\par
790         CAN[p_Assembly]->set_Input_String(p_Input);\par
791     \}\par
792 \par
793     {\cf20 //    ---==  set_input_uint [ASSEMBLY_ID] [ARRAY_DEPTH] [UINT_ARRAY]  ==---}\par
794         {\cf20 //Set the value to the passed 1D string of uint64_t}\par
795     {\cf18 void} set_Input_uint({\cf18 int} p_Assembly, {\cf18 int} p_Depth, uint64_t* p_Input)\par
796     \{\par
797         CAN[p_Assembly]->set_Input(p_Input, p_Depth);\par
798     \}\par
799 \par
800 \par
801 \par
802     {\cf20 //    ---==========================================================================---}\par
803     {\cf20 //   ---============================================================================---}\par
804     {\cf20 //  ---==   Different ways of gathering nodes, individually, and the entire set.   ==---}\par
805     {\cf20 //   ---============================================================================---}\par
806     {\cf20 //    ---==========================================================================---}\par
807 \par
808     {\cf20 //    ---==  gather_given_node [ASSEMBLY_ID] [NID]  ==---}\par
809     {\cf20 //      Writes the given node's data down in the Assembly_Output_Files[p_Assembly] file.}\par
810     {\cf18 void} gather_Given_Node({\cf18 int} p_Assembly, uint64_t p_NID)\par
811     \{\par
812         std::ofstream tmp_Output_File;\par
813         c_Node* tmp_Node = NULL;\par
814 \par
815         tmp_Node = Nodes.get_Node_Ref_By_NID(p_NID);\par
816 \par
817         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
818 \par
819         write_Node_To_File(p_Assembly, &tmp_Output_File, tmp_Node);\par
820 \par
821         tmp_Output_File.close();\par
822     \}\par
823 \par
824     {\cf20 //      Writes the given node's data down in the Assembly_Output_Files[p_Assembly] file.}\par
825     {\cf18 void} gather_Given_Node_uint({\cf18 int} p_Assembly, uint64_t p_NID)\par
826     \{\par
827         std::ofstream tmp_Output_File;\par
828         c_Node* tmp_Node = NULL;\par
829 \par
830         tmp_Node = Nodes.get_Node_Ref_By_NID(p_NID);\par
831 \par
832         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
833 \par
834         write_Node_To_File(p_Assembly, &tmp_Output_File, tmp_Node, 1);\par
835 \par
836         tmp_Output_File.close();\par
837     \}\par
838 \par
839     {\cf20 //    ---==  gather_all_nodes [ASSEMBLY_ID]  ==---}\par
840     {\cf20 //      This writes the entire network to the Assembly_Output_Files[p_Assembly] file. Note, the output patterns are treated as character.}\par
841         {\cf20 //It uses the passed assembly to output the nodes by putting it into the output of that assembly, then into the file.}\par
842     {\cf18 void} gather_All_Nodes({\cf18 int} p_Assembly)\par
843     \{\par
844         std::ofstream tmp_Output_File;\par
845 \par
846         c_Node* tmp_Node;\par
847         tmp_Node = Nodes.Root;\par
848 \par
849         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
850 \par
851         {\cf19 while} (tmp_Node != NULL)\par
852         \{\par
853             tmp_Output_File << {\cf22 "\\n"};\par
854 \par
855             write_Node_To_File(p_Assembly, &tmp_Output_File, tmp_Node);\par
856 \par
857             tmp_Node = tmp_Node->Next;\par
858         \}\par
859 \par
860         tmp_Output_File.close();\par
861     \}\par
862 \par
863     {\cf20 //    ---==  gather_all_nodes_uint [ASSEMBLY_ID]  ==---}\par
864     {\cf20 //      This writes the entire network to the Assembly_Output_Files[p_Assembly] file. Note, the output patterns are treated as uint.}\par
865     {\cf18 void} gather_All_Nodes_uint({\cf18 int} p_Assembly)\par
866     \{\par
867         std::ofstream tmp_Output_File;\par
868 \par
869         c_Node* tmp_Node;\par
870         tmp_Node = Nodes.Root;\par
871 \par
872         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
873 \par
874         {\cf19 while} (tmp_Node != NULL)\par
875         \{\par
876             tmp_Output_File << {\cf22 "\\n"};\par
877 \par
878             write_Node_To_File(p_Assembly, &tmp_Output_File, tmp_Node, 1);\par
879 \par
880             tmp_Node = tmp_Node->Next;\par
881         \}\par
882 \par
883         tmp_Output_File.close();\par
884     \}\par
885 \par
886 \par
887     {\cf20 //    ---==================================================================---}\par
888     {\cf20 //   ---====================================================================---}\par
889     {\cf20 //  ---==   The output of a given assembly is read into the output file.   ==---}\par
890     {\cf20 //   ---====================================================================---}\par
891     {\cf20 //    ---==================================================================---}\par
892 \par
893         {\cf20 //==--- DIRECT_HOOK ---==//}\par
894     {\cf18 void} output_Trace_To_File(std::ofstream* p_SF, c_Trace* p_Trace, {\cf18 int} p_Output_Type)\par
895     \{\par
896         std::cout << {\cf22 " NID: "} << p_Trace->Treetop->NID;\par
897         std::cout << {\cf22 " Charge: "} << p_Trace->Charge;\par
898         std::cout << {\cf22 " RC: "} << p_Trace->RC;\par
899         std::cout << {\cf22 " Depth: "} << p_Trace->Depth;\par
900 \par
901         *p_SF << {\cf22 "\\n"};\par
902 \par
903         *p_SF << p_Trace->Treetop->NID;\par
904         *p_SF << {\cf22 " "} << p_Trace->Charge;\par
905         *p_SF << {\cf22 " "} << p_Trace->RC;\par
906         *p_SF << {\cf22 " "} << p_Trace->Depth;\par
907 \par
908         *p_SF << {\cf22 " "};\par
909         std::string tmp_In = {\cf22 ""};\par
910 \par
911         {\cf19 if} (p_Trace->Depth > 0)\par
912         \{\par
913             {\cf19 if} (p_Output_Type == 0)\par
914             \{\par
915                 *p_SF << char(p_Trace->Pattern[0]);\par
916                 std::cout << {\cf22 "  "} << char(p_Trace->Pattern[0]);\par
917             \}\par
918             {\cf19 if} (p_Output_Type == 1)\par
919             \{\par
920                 *p_SF << p_Trace->Pattern[0];\par
921                 std::cout << {\cf22 "  "} << p_Trace->Pattern[0];\par
922             \}\par
923         \}\par
924 \par
925         {\cf19 for} ({\cf18 int} cou_Index = 1; cou_Index < p_Trace->Depth; cou_Index++)\par
926         \{\par
927             {\cf19 if} (p_Output_Type == 0)\par
928             \{\par
929                 *p_SF << char(p_Trace->Pattern[cou_Index]);\par
930                 std::cout << {\cf22 " "} << char(p_Trace->Pattern[cou_Index]);\par
931             \}\par
932             {\cf19 if} (p_Output_Type == 1)\par
933             \{\par
934                 *p_SF << {\cf22 " "} << p_Trace->Pattern[cou_Index];\par
935                 std::cout << {\cf22 " "} << p_Trace->Pattern[cou_Index];\par
936             \}\par
937 \par
938         \}\par
939     \}\par
940 \par
941     {\cf20 //==--- DIRECT_HOOK ---==//}\par
942     {\cf20 //Character output for this one, the default, always string.}\par
943     {\cf20 //p_Output_Type: 0 = string, 1 = uint64_t}\par
944     {\cf18 void} output_Output_To_File({\cf18 int} p_Assembly, {\cf18 int} p_Output_Type = 0)\par
945     \{\par
946         std::ofstream tmp_Output_File;\par
947 \par
948         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
949 \par
950         {\cf20 // Check if the flag file exists and can be opened}\par
951         {\cf19 if} (tmp_Output_File.is_open())\par
952         \{\par
953             {\cf20 //tmp_Output_File << CAN[p_Assembly]->Output_Depth;}\par
954 \par
955             {\cf20 //For every trace write the info to the file}\par
956             {\cf19 for} ({\cf18 int} cou_Trace = 0; cou_Trace < CAN[p_Assembly]->Output_Depth; cou_Trace++)\par
957             \{\par
958                 std::cout << {\cf22 "\\n Trace ["} << cou_Trace << {\cf22 "]"};\par
959 \par
960                 output_Trace_To_File(&tmp_Output_File, &(CAN[p_Assembly]->Output[cou_Trace]), p_Output_Type);\par
961             \}\par
962         \}\par
963         tmp_Output_File.close();\par
964     \}\par
965 \par
966     {\cf20 //    ---==  gather_output [ASSEMBLY_ID]  ==---}\par
967     {\cf20 //      Takes every trace in the given Assemblies output trace array and writes them to the Assembly_Output_Files[p_Assembly] file, note the output state patterns are treated as char.}\par
968     {\cf18 void} gather_Output({\cf18 int} p_Assembly)\par
969     \{\par
970         output_Output_To_File(p_Assembly);\par
971     \}\par
972 \par
973     {\cf20 //    ---==  gather_output_uint [ASSEMBLY_ID]  ==---}\par
974     {\cf20 //      Takes every trace in the given Assemblies output trace array and writes them to the Assembly_Output_Files[p_Assembly] file, note the output state patterns are treated as uint.}\par
975     {\cf18 void} gather_Output_uint({\cf18 int} p_Assembly)\par
976     \{\par
977         output_Output_To_File(p_Assembly, 1);\par
978     \}\par
979 \par
980 \par
981     {\cf20 //    ---=============================---}\par
982     {\cf20 //   ---===============================---}\par
983     {\cf20 //  ---==   Treetop node gathering.   ==---}\par
984     {\cf20 //   ---===============================---}\par
985     {\cf20 //    ---=============================---}\par
986 \par
987 \par
988         {\cf20 //==--- DIRECT_HOOK ---==//}\par
989     {\cf18 void} write_Node_To_File({\cf18 int} p_Assembly, std::ofstream* p_SF, c_Node* p_Node, {\cf18 int} p_Output_Type = 0)\par
990     \{\par
991         {\cf19 if} ((p_SF == NULL) || (p_Node == NULL)) \{ {\cf19 return}; \}\par
992 \par
993         {\cf20 // Check if the flag file exists and can be opened}\par
994         {\cf19 if} (p_SF->is_open())\par
995         \{\par
996             *p_SF << p_Node->NID;\par
997             *p_SF << {\cf22 " "};\par
998             *p_SF << p_Node->RC;\par
999             *p_SF << {\cf22 " "};\par
1000             *p_SF << p_Node->Dendrite_Count;\par
1001             *p_SF << {\cf22 " "};\par
1002             {\cf19 for} ({\cf18 int} cou_D = 0; cou_D < p_Node->Dendrite_Count; cou_D++)\par
1003             \{\par
1004                 *p_SF << p_Node->Dendrites[cou_D]->NID;\par
1005                 *p_SF << {\cf22 " "};\par
1006             \}\par
1007             *p_SF << p_Node->Axon_Hillock_Count;\par
1008             *p_SF << {\cf22 " "};\par
1009             {\cf19 for} ({\cf18 int} cou_H = 0; cou_H < p_Node->Axon_Hillock_Count; cou_H++)\par
1010             \{\par
1011                 *p_SF << p_Node->Axon_Count[cou_H];\par
1012                 *p_SF << {\cf22 " "};\par
1013                 {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < p_Node->Axon_Count[cou_H]; cou_A++)\par
1014                 \{\par
1015                     *p_SF << p_Node->Axons[cou_H][cou_A]->NID;\par
1016                     *p_SF << {\cf22 " "};\par
1017                 \}\par
1018             \}\par
1019 \par
1020             CAN[p_Assembly]->gather_Given_Trace(p_Node->NID);\par
1021 \par
1022             {\cf19 if} (CAN[p_Assembly]->Output_Depth > 0)\par
1023             \{\par
1024                 {\cf20 //The single node should only generate one trace which will be stored in the [0] index.}\par
1025 \par
1026                 *p_SF << CAN[p_Assembly]->Output[0].Depth;\par
1027                 *p_SF << {\cf22 " "};\par
1028                 {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < CAN[p_Assembly]->Output[0].Depth; cou_Index++)\par
1029                 \{\par
1030                     {\cf19 if} (p_Output_Type == 0)\par
1031                     \{\par
1032                         *p_SF << char(CAN[p_Assembly]->Output[0].get_Pattern_Index(cou_Index));\par
1033                     \}\par
1034                     {\cf19 if} (p_Output_Type == 1)\par
1035                     \{\par
1036                         *p_SF << CAN[p_Assembly]->Output[0].get_Pattern_Index(cou_Index) << {\cf22 " "};\par
1037                     \}\par
1038                 \}\par
1039             \}\par
1040         \}\par
1041     \}\par
1042 \par
1043     {\cf18 void} save_Node_To_File(std::ofstream* p_SF, c_Node* p_Node, {\cf18 int} p_Output_Type = 0)\par
1044     \{\par
1045         {\cf19 if} ((p_SF == NULL) || (p_Node == NULL)) \{ {\cf19 return}; \}\par
1046 \par
1047         {\cf20 // Check if the flag file exists and can be opened}\par
1048         {\cf19 if} (p_SF->is_open())\par
1049         \{\par
1050             *p_SF << p_Node->NID;\par
1051             *p_SF << {\cf22 " "};\par
1052             *p_SF << p_Node->RC;\par
1053             *p_SF << {\cf22 " "};\par
1054             *p_SF << p_Node->Type;\par
1055             *p_SF << {\cf22 " "};\par
1056             *p_SF << p_Node->State;\par
1057             *p_SF << {\cf22 " "};\par
1058             *p_SF << p_Node->Dendrite_Count;\par
1059             *p_SF << {\cf22 " "};\par
1060             {\cf19 for} ({\cf18 int} cou_D = 0; cou_D < p_Node->Dendrite_Count; cou_D++)\par
1061             \{\par
1062                 *p_SF << p_Node->Dendrites[cou_D]->NID;\par
1063                 *p_SF << {\cf22 " "};\par
1064             \}\par
1065 \par
1066             {\cf20 //Shouldn't need the axons,}\par
1067             {\cf20 /*}\par
1068 {\cf20             *p_SF << p_Node->Axon_Hillock_Count;}\par
1069 {\cf20             *p_SF << " ";}\par
1070 {\cf20             for (int cou_H = 0; cou_H < p_Node->Axon_Hillock_Count; cou_H++)}\par
1071 {\cf20             \{}\par
1072 {\cf20                 *p_SF << p_Node->Axon_Count[cou_H];}\par
1073 {\cf20                 *p_SF << " ";}\par
1074 {\cf20                 for (int cou_A = 0; cou_A < p_Node->Axon_Count[cou_H]; cou_A++)}\par
1075 {\cf20                 \{}\par
1076 {\cf20                     *p_SF << p_Node->Axons[cou_H][cou_A]->NID;}\par
1077 {\cf20                     *p_SF << " ";}\par
1078 {\cf20                 \}}\par
1079 {\cf20             \}}\par
1080 {\cf20             */}\par
1081         \}\par
1082     \}\par
1083 \par
1084     {\cf18 void} save_Assemblies(std::ofstream* p_SF)\par
1085     \{\par
1086         *p_SF << Assembly_Count;\par
1087 \par
1088         {\cf19 for} ({\cf18 int} cou_Ass=0;cou_Ass<Assembly_Count;cou_Ass++)\par
1089         \{\par
1090             *p_SF << {\cf22 "\\n"};\par
1091             *p_SF << Assembly_Names[cou_Ass] << {\cf22 " "};\par
1092             *p_SF << CAN_Type[cou_Ass] << {\cf22 " "};\par
1093             *p_SF << CAN[cou_Ass]->State_Nodes_Index;\par
1094         \}\par
1095     \}\par
1096 \par
1097     {\cf20 //Save the node network one node at a time.}\par
1098     {\cf18 void} save_Node_Network(std::ofstream* p_SF)\par
1099     \{\par
1100         *p_SF << {\cf22 "\\n"};\par
1101         *p_SF << Nodes.Node_Count;\par
1102 \par
1103         c_Node* tmp_Node;\par
1104         tmp_Node = Nodes.Root;\par
1105 \par
1106         {\cf19 while} (tmp_Node != NULL)\par
1107         \{\par
1108             *p_SF << {\cf22 "\\n"};\par
1109 \par
1110             save_Node_To_File(p_SF, tmp_Node);\par
1111 \par
1112             tmp_Node = tmp_Node->Next;\par
1113         \}\par
1114     \}\par
1115 \par
1116     {\cf18 void} save_State_Trees(std::ofstream* p_SF)\par
1117     \{\par
1118         *p_SF << {\cf22 "\\n"} << Nodes.State_Node_Tree_Count;\par
1119 \par
1120         {\cf19 for} ({\cf18 int} cou_State = 0; cou_State < Nodes.State_Node_Tree_Count; cou_State++)\par
1121         \{\par
1122             Nodes.State_Nodes[cou_State]->save_Tree(p_SF);\par
1123         \}\par
1124     \}\par
1125 \par
1126     {\cf18 void} save(std::string p_FName)\par
1127     \{\par
1128         std::ofstream tmp_Output_File;\par
1129 \par
1130         tmp_Output_File.open(p_FName, std::ios::ate);\par
1131 \par
1132         {\cf19 if} (tmp_Output_File.is_open())\par
1133         \{\par
1134             save_Assemblies(&tmp_Output_File);\par
1135             save_Node_Network(&tmp_Output_File);\par
1136             save_State_Trees(&tmp_Output_File);\par
1137         \}\par
1138 \par
1139         tmp_Output_File.close();\par
1140     \}\par
1141 \par
1142     {\cf18 void} load_Assemblies(std::ifstream* p_SF)\par
1143     \{\par
1144         {\cf18 int} tmp_Assembly_Count;\par
1145         *p_SF >> tmp_Assembly_Count;\par
1146 \par
1147         std::string tmp_Name = {\cf22 ""};\par
1148         std::string tmp_Type = {\cf22 ""};\par
1149         {\cf18 int} tmp_State_Index = 0;\par
1150 \par
1151         {\cf19 for} ({\cf18 int} cou_Ass = 0; cou_Ass < tmp_Assembly_Count; cou_Ass++)\par
1152         \{\par
1153             *p_SF >> tmp_Name;\par
1154             *p_SF >> tmp_Type;\par
1155             *p_SF >> tmp_State_Index;\par
1156 \par
1157             register_Assembly(tmp_Type, tmp_Name);\par
1158             set_State_Nodes_Index(cou_Ass, tmp_State_Index);\par
1159         \}\par
1160     \}\par
1161 \par
1162     {\cf18 void} load_Node(std::ifstream* p_SF)\par
1163     \{\par
1164 \par
1165     \}\par
1166 \par
1167     {\cf18 void} load_Node_Network(std::ifstream* p_SF)\par
1168     \{\par
1169         uint64_t tmp_NID = 0;\par
1170         {\cf18 double} tmp_RC = 0.0;\par
1171         {\cf18 int} tmp_Type = 0.0;\par
1172         uint64_t tmp_State = 0;\par
1173         {\cf18 int} tmp_Dendrite_Count = 0;\par
1174         {\cf18 int} * tmp_Dendrite_NID = NULL;\par
1175 \par
1176         c_Node** tmp_Dendrites = NULL;\par
1177         c_Node* tmp_Node = NULL;\par
1178 \par
1179         uint64_t tmp_Node_Count = 0;\par
1180         \par
1181         *p_SF >> tmp_Node_Count;\par
1182 \par
1183         std::cout << {\cf22 "\\n Found "} << tmp_Node_Count << {\cf22 " nodes."};\par
1184 \par
1185         {\cf19 for} ({\cf18 int} cou_Node = 0; cou_Node < tmp_Node_Count; cou_Node++)\par
1186         \{\par
1187             std::cout << {\cf22 "\\n"};\par
1188             *p_SF >> tmp_NID;\par
1189             std::cout << tmp_NID << {\cf22 " "};\par
1190 \par
1191             *p_SF >> tmp_RC;\par
1192             std::cout << tmp_RC << {\cf22 " "};\par
1193             *p_SF >> tmp_Type;\par
1194             std::cout << tmp_Type << {\cf22 " "};\par
1195             *p_SF >> tmp_State;\par
1196             std::cout << tmp_State << {\cf22 " "};\par
1197 \par
1198             {\cf20 //This is because node 0 is already made}\par
1199             {\cf19 if} (tmp_NID != 0)\par
1200             \{\par
1201                 tmp_Node = new_Node();\par
1202             \}\par
1203 \par
1204 \par
1205             {\cf19 if} (tmp_Node != NULL)\par
1206             \{\par
1207                 tmp_Node->set_Type(tmp_Type);\par
1208                 tmp_Node->RC = tmp_RC;\par
1209             \}\par
1210 \par
1211             *p_SF >> tmp_Dendrite_Count;\par
1212             std::cout << tmp_Dendrite_Count << {\cf22 " "};\par
1213 \par
1214             tmp_Dendrite_NID = {\cf17 new} {\cf18 int}[tmp_Dendrite_Count];\par
1215             tmp_Dendrites = {\cf17 new} c_Node*[tmp_Dendrite_Count];\par
1216 \par
1217             {\cf19 for} ({\cf18 int} cou_D = 0; cou_D < tmp_Dendrite_Count; cou_D++)\par
1218             \{\par
1219                 *p_SF >> tmp_Dendrite_NID[cou_D];\par
1220                 std::cout << tmp_Dendrite_NID[cou_D] << {\cf22 " "};\par
1221 \par
1222                 tmp_Dendrites[cou_D] = Nodes.get_Node_Ref_By_NID(tmp_Dendrite_NID[cou_D]);\par
1223             \}\par
1224 \par
1225             {\cf19 if} (tmp_Dendrite_Count > 0) \{ create_Connections(tmp_Node, tmp_Dendrite_Count, tmp_Dendrites); \}\par
1226         \}\par
1227 \par
1228         {\cf19 if} (tmp_Dendrite_NID != NULL) \{ {\cf17 delete}[] tmp_Dendrite_NID; tmp_Dendrite_NID = NULL; \}\par
1229         {\cf19 if} (tmp_Dendrites != NULL) \{ {\cf17 delete}[] tmp_Dendrites; tmp_Dendrites = NULL; \}\par
1230 \par
1231         {\cf20 //Now gather state nodes.}\par
1232 \par
1233 \par
1234     \}\par
1235 \par
1236     {\cf18 void} load_State_Trees(std::ifstream* p_SF)\par
1237     \{\par
1238         {\cf20 //This number should exist already in this system from registering the constructs, but we gather it here today to say our...}\par
1239         {\cf18 int} tmp_State_Tree_Count = 0;\par
1240 \par
1241         *p_SF >> tmp_State_Tree_Count;\par
1242         \par
1243         std::cout << {\cf22 "\\n Loading [ "} << tmp_State_Tree_Count << {\cf22 " ] State Trees..."};\par
1244 \par
1245         {\cf18 int} tmp_State_Node_Count = 0;\par
1246 \par
1247         uint64_t tmp_NID = 0;\par
1248         uint64_t tmp_State = 0;\par
1249 \par
1250         {\cf19 for} ({\cf18 int} cou_ST = 0; cou_ST < tmp_State_Tree_Count; cou_ST++)\par
1251         \{\par
1252             *p_SF >> tmp_State_Node_Count;\par
1253 \par
1254             std::cout << {\cf22 "\\n Found [ "} << tmp_State_Node_Count << {\cf22 " ] State Bindings..."};\par
1255 \par
1256             {\cf19 for} ({\cf18 int} cou_SN = 0; cou_SN < tmp_State_Node_Count; cou_SN++)\par
1257             \{\par
1258                 *p_SF >> tmp_NID;\par
1259                 *p_SF >> tmp_State;\par
1260 \par
1261                 std::cout << {\cf22 "\\n NID "} << tmp_NID << {\cf22 " State "} << tmp_State;\par
1262                 \par
1263                 Nodes.assign_State_Node(cou_ST, Nodes.get_Node_Ref_By_NID(tmp_NID), tmp_State);\par
1264             \}\par
1265         \}\par
1266     \}\par
1267 \par
1268     {\cf18 void} load(std::string p_FName)\par
1269     \{\par
1270         std::ifstream tmp_Load_File;\par
1271 \par
1272         tmp_Load_File.open(p_FName);\par
1273 \par
1274         {\cf19 if} (tmp_Load_File.is_open())\par
1275         \{\par
1276             load_Assemblies(&tmp_Load_File);\par
1277             load_Node_Network(&tmp_Load_File);\par
1278             load_State_Trees(&tmp_Load_File);\par
1279         \}\par
1280 \par
1281         tmp_Load_File.close();\par
1282     \}\par
1283 \par
1284     {\cf20 //    ---==  gather_treetop_node [ASSEMBLY_ID]  ==---}\par
1285     {\cf20 //      This writes the current treetop node of the given assembly to the Assembly_Output_Files[p_Assembly] file. This does not erase the file.}\par
1286     {\cf18 void} gather_Treetop_Node({\cf18 int} p_Assembly)\par
1287     \{\par
1288         std::ofstream tmp_Output_File;\par
1289         c_Node* tmp_Treetop = NULL;\par
1290 \par
1291         tmp_Treetop = get_Treetop(p_Assembly);\par
1292 \par
1293         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
1294 \par
1295         write_Node_To_File(p_Assembly, &tmp_Output_File, tmp_Treetop);\par
1296 \par
1297         tmp_Output_File.close();\par
1298     \}\par
1299 \par
1300     {\cf20 //    ---==  gather_treetop_node_uint [ASSEMBLY_ID]  ==---}\par
1301     {\cf20 //      This writes the current treetop node of the given assembly to the Assembly_Output_Files[p_Assembly] file. This does not erase the file.}\par
1302     {\cf18 void} gather_Treetop_Node_uint({\cf18 int} p_Assembly)\par
1303     \{\par
1304         std::ofstream tmp_Output_File;\par
1305         c_Node* tmp_Treetop = NULL;\par
1306 \par
1307         tmp_Treetop = get_Treetop(p_Assembly);\par
1308 \par
1309         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
1310 \par
1311         write_Node_To_File(p_Assembly, &tmp_Output_File, tmp_Treetop, 1);\par
1312 \par
1313         tmp_Output_File.close();\par
1314     \}\par
1315 \par
1316     {\cf20 //    ---==  gather_treetop_NID [ASSEMBLY_ID]  ==---}\par
1317     {\cf20 //      This writes only the NID of the current treetop to the file. Does not erase the file.}\par
1318     {\cf18 void} gather_Treetop_NID({\cf18 int} p_Assembly)\par
1319     \{\par
1320         std::ofstream tmp_Output_File;\par
1321         c_Node* tmp_Treetop = NULL;\par
1322 \par
1323         tmp_Treetop = get_Treetop(p_Assembly);\par
1324 \par
1325         tmp_Output_File.open(Assembly_Output_Files[p_Assembly], std::ios::app);\par
1326 \par
1327         {\cf19 if} (tmp_Treetop != NULL)\par
1328         \{\par
1329             tmp_Output_File << tmp_Treetop->NID;\par
1330         \}\par
1331         {\cf19 else}\par
1332         \{\par
1333             tmp_Output_File << {\cf22 "NULL"};\par
1334         \}\par
1335         tmp_Output_File.close();\par
1336     \}\par
1337 \par
1338 \par
1339 \par
1340     {\cf20 //    ---======================================================================---}\par
1341     {\cf20 //   ---========================================================================---}\par
1342     {\cf20 //  ---==   Output the assembly input, output, scaffolds, node network, etc.   ==---}\par
1343     {\cf20 //   ---========================================================================---}\par
1344     {\cf20 //    ---======================================================================---}\par
1345 \par
1346     {\cf20 //    ---==  output_assemblies  ==---}\par
1347     {\cf20 //      Outputs the assemblies currently registered.}\par
1348     {\cf18 void} output_Assemblies()\par
1349     \{\par
1350         {\cf19 for} ({\cf18 int} cou_Ass = 0; cou_Ass < Assembly_Count; cou_Ass++)\par
1351         \{\par
1352             std::cout << {\cf22 "\\n ["} << cou_Ass << {\cf22 "]: "} << Assembly_Names[cou_Ass] << {\cf22 " - "} << CAN_Type[cou_Ass];\par
1353         \}\par
1354     \}\par
1355 \par
1356     {\cf20 //      ---==================================---}\par
1357     {\cf20 //     ---====================================---}\par
1358     {\cf20 //    ---======================================---}\par
1359     {\cf20 //   ---========================================---}\par
1360     {\cf20 //  ---==   Generic commands for the engine.   ==---}\par
1361     {\cf20 //   ---========================================---}\par
1362     {\cf20 //    ---======================================---}\par
1363     {\cf20 //     ---====================================---}\par
1364     {\cf20 //      ---==================================---}\par
1365 \par
1366 \par
1367 \par
1368     {\cf20 //    ---==  clear_output  ==---}\par
1369     {\cf18 int} clear_Output({\cf18 int} p_Assembly)\par
1370     \{\par
1371         std::ofstream clsFlagFile(Assembly_Output_Files[p_Assembly], std::ios::ate);\par
1372 \par
1373         {\cf20 // Check if the flag file exists and can be opened}\par
1374         {\cf19 if} (clsFlagFile.is_open())\par
1375         \{\par
1376             std::cout << {\cf22 "\\n\\n --== Resetting "} << Assembly_Output_Files[p_Assembly] << {\cf22 " File ==--"};\par
1377         \}\par
1378 \par
1379         clsFlagFile.close();\par
1380         {\cf19 return} 1;\par
1381     \}\par
1382 \par
1383 \par
1384     {\cf20 //    ---==  output_newline  ==---}\par
1385     {\cf18 int} output_Newline({\cf18 int} p_Assembly)\par
1386     \{\par
1387         std::ofstream clsFlagFile(Assembly_Output_Files[p_Assembly], std::ios::app);\par
1388 \par
1389         {\cf20 // Check if the flag file exists and can be opened}\par
1390         {\cf19 if} (clsFlagFile.is_open())\par
1391         \{\par
1392             clsFlagFile << {\cf22 "\\n"};\par
1393         \}\par
1394 \par
1395         clsFlagFile.close();\par
1396         {\cf19 return} 1;\par
1397     \}\par
1398 \par
1399 \};\par
1400 \par
1401 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Construct_API.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Construct_API.h}
{\xe \v include/NT4/c_Construct_API.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //It annoys the shit out of me to put the count before the array in the argument list, but the text server is structured as such, mostly because I'm being lazy and don't want to write a complex interpreter atm, so this is structured as such.}\par
2 \par
3 {\cf20 //The construct encapsulates the node network, the CANs, I/O, granulation filter, uinterface, actuator interface, and I/O tables.}\par
4 {\cf20 //The result is that after setting up the network the user can use it like a black box.}\par
5 {\cf17 class }c_Construct_API\par
6 \{\par
7 {\cf17 public}:\par
8     \par
9     c_Construct Base;\par
10 \par
11     c_Construct_API()\par
12     \{\par
13     \}\par
14 \par
15 \par
16 {\cf20 //      ---==================---}\par
17 {\cf20 //     ---====================---}\par
18 {\cf20 //    ---======================---}\par
19 {\cf20 //   ---========================---}\par
20 {\cf20 //  ---==   NT4 Deep Control   ==---}\par
21 {\cf20 //   ---========================---}\par
22 {\cf20 //    ---======================---}\par
23 {\cf20 //     ---====================---}\par
24 {\cf20 //      ---==================---}\par
25   \par
26   \par
27   \par
28 {\cf20 //    ---==========---}\par
29 {\cf20 //   ---============---}\par
30 {\cf20 //  ---==   Node   ==---}\par
31 {\cf20 //   ---============---}\par
32 {\cf20 //    ---==========---}\par
33 \par
34     {\cf20 //---==  set_type [NID] [TYPE]  ==---//}\par
35     {\cf20 //(0: State), (1: Branch), (2: Treetop), (3: State/Treetop)}\par
36     {\cf18 void} set_Type(uint64_t p_NID, uint8_t p_Type)\par
37     \{\par
38         Base.set_Type(Base.get_Node_Ref_By_NID(p_NID), p_Type);\par
39     \}\par
40 \par
41 \par
42     \par
43     {\cf20 //---==  add_axon_index [NID] [Axon_NID] [INDEX]  ==---//}\par
44     {\cf20 //Adds an axon to the axon list at the given index, if the index doesn't exist then exist it with resize_Axon_Hillocks()}\par
45     {\cf18 void} add_Axon_Index(uint64_t p_NID, uint64_t p_Axon_NID, {\cf18 int} p_Index)\par
46     \{\par
47         Base.add_Axon_Index(Base.get_Node_Ref_By_NID(p_NID), Base.get_Node_Ref_By_NID(p_Axon_NID), p_Index);\par
48     \}\par
49 \par
50 \par
51     \par
52     {\cf20 //---==  set_Dendrites [NID] [DENDRITE_IDS[]] [COUNT]  ==---//}\par
53     {\cf20 //Sets the dendrites of the node.}\par
54     {\cf20 //This assumes the node has no dendrites yet, if it does you be dangling and jangling}\par
55     {\cf18 void} set_Dendrites(uint64_t p_NID, {\cf18 int} p_Count, uint64_t* p_Dendrite_NIDs)\par
56     \{\par
57         c_Node** tmp_Dendrites = NULL;\par
58         tmp_Dendrites = {\cf17 new} c_Node*[p_Count];\par
59 \par
60         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
61         \{\par
62             tmp_Dendrites[cou_Index] = Base.get_Node_Ref_By_NID(p_Dendrite_NIDs[cou_Index]);\par
63         \}\par
64 \par
65         Base.set_Dendrites(Base.get_Node_Ref_By_NID(p_NID), p_Count, tmp_Dendrites);\par
66 \par
67         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
68         \{\par
69             tmp_Dendrites[cou_Index] = NULL;\par
70         \}\par
71 \par
72         {\cf19 if} (tmp_Dendrites != NULL) \{ {\cf17 delete}[] tmp_Dendrites; tmp_Dendrites = NULL; \}\par
73     \}\par
74 \par
75 \par
76     {\cf20 //---==  does_Upper_Tier_Connection_Exist NODE_COUNT NODES[]  ==---//}\par
77     {\cf20 //Searches the axons to see if an upper tier connection exists.}\par
78     {\cf20 //This is always called from the first leg, that is why we separate _F from normal.}\par
79     uint64_t does_Upper_Tier_Connection_Exist({\cf18 int} p_Count, uint64_t* p_Nodes)\par
80     \{\par
81         c_Node** tmp_Nodes = NULL;\par
82         tmp_Nodes = {\cf17 new} c_Node*[p_Count];\par
83         c_Node * return_NID = NULL;\par
84 \par
85         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
86         \{\par
87             tmp_Nodes[cou_Index] = Base.get_Node_Ref_By_NID(p_Nodes[cou_Index]);\par
88         \}\par
89 \par
90         return_NID = Base.does_Upper_Tier_Connection_Exist(p_Count, tmp_Nodes);\par
91 \par
92         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
93         \{\par
94             tmp_Nodes[cou_Index] = NULL;\par
95         \}\par
96 \par
97         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
98 \par
99         {\cf19 if} (return_NID != NULL) \{ {\cf19 return} return_NID->NID; \}\par
100         {\cf19 return} 0;\par
101     \}\par
102 \par
103 \par
104     {\cf20 //---==  does_Lower_Connection_Exist [NID] [NODES[]] [NODE_COUNT]  ==---//}\par
105     {\cf20 //Checks if the given node matches a dendrite on the right leg.}\par
106     {\cf18 bool} does_Lower_Connection_Exist(uint64_t p_NID, {\cf18 int} p_Count, uint64_t* p_Nodes)\par
107     \{\par
108         c_Node** tmp_Nodes = NULL;\par
109         tmp_Nodes = {\cf17 new} c_Node*[p_Count];\par
110         {\cf18 bool} return_Result = 0;\par
111 \par
112         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
113         \{\par
114             tmp_Nodes[cou_Index] = Base.get_Node_Ref_By_NID(p_Nodes[cou_Index]);\par
115         \}\par
116 \par
117         return_Result = Base.does_Lower_Connection_Exist(Base.get_Node_Ref_By_NID(p_NID), p_Count, tmp_Nodes);\par
118 \par
119         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
120         \{\par
121             tmp_Nodes[cou_Index] = NULL;\par
122         \}\par
123 \par
124         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
125 \par
126         {\cf19 return} return_Result;\par
127     \}\par
128 \par
129 \par
130 \par
131     {\cf20 //---==  bind_State [NID] [STATE_UINT]  ==---//}\par
132     {\cf20 //Binds a node to a quanta of data, the state of the input.}\par
133     {\cf18 void} bind_State(uint64_t p_NID, uint64_t p_State)\par
134     \{\par
135         Base.bind_State(Base.get_Node_Ref_By_NID(p_NID), p_State);\par
136     \}\par
137 \par
138 \par
139 \par
140     {\cf20 //---==  bp_O [NID]  ==---//}\par
141     {\cf20 //Initiates a backpropagation that outputs the pattern represented by this node.}\par
142     {\cf18 void} bp_O(uint64_t p_NID)\par
143     \{\par
144         Base.bp_O(Base.get_Node_Ref_By_NID(p_NID));\par
145     \}\par
146 \par
147 \par
148 \par
149     {\cf20 //---==  output_Node_Raw [NID]  ==---//}\par
150     {\cf20 //Outputs the ugly raw info dump for the node.}\par
151     {\cf18 void} output_Node_Raw(uint64_t p_NID)\par
152     \{\par
153         Base.output_Node_Raw(Base.get_Node_Ref_By_NID(p_NID));\par
154     \}\par
155 \par
156 \par
157 \par
158     {\cf20 //---==  output_Node_Char [NID]  ==---//}\par
159     {\cf20 //Casts the node address to char() and outputs it.}\par
160     {\cf18 void} output_Node_Char(uint64_t p_NID)\par
161     \{\par
162         Base.output_Node_Char(Base.get_Node_Ref_By_NID(p_NID));\par
163     \}\par
164 \par
165 \par
166     \par
167   \par
168   \par
169 {\cf20 //    ---==================---}\par
170 {\cf20 //   ---====================---}\par
171 {\cf20 //  ---==   Node_Network   ==---}\par
172 {\cf20 //   ---====================---}\par
173 {\cf20 //    ---==================---}\par
174   \par
175     {\cf20 //---==  register_New_Construct  ==---//}\par
176     {\cf18 int} register_New_Construct()\par
177     \{\par
178         {\cf19 return} Base.register_New_Construct();\par
179     \}\par
180 \par
181   \par
182     {\cf20 //---==  new_Node  ==---//}\par
183     {\cf20 //Creates a new node and adds it to the fractal tree.}\par
184     {\cf20 //Each node is stored as a link in a linked list.}\par
185     uint64_t new_Node()\par
186     \{\par
187         {\cf19 return} (Base.new_Node())->NID;\par
188     \}\par
189   \par
190 \par
191     {\cf20 //---==  new_State_Node [ASSEMBLY_ID] [STATE_DOUBLE]  ==---//}\par
192     {\cf20 //Creates a new node, then adds it to the state tree.}\par
193     {\cf20 //Assumes the construct is already registered so the index is valid.}\par
194     uint64_t new_State_Node({\cf18 int} p_Assembly, {\cf18 double} p_State)\par
195     \{\par
196         {\cf19 return} (Base.new_State_Node(p_Assembly, p_State))->NID;\par
197     \}\par
198   \par
199 \par
200     {\cf20 //---==  create_Connections [TO_NID] [FROM_NIDS[]] [COUNT]  ==---//}\par
201     {\cf20 //Creates a connection between nodes.}\par
202     {\cf20 //p_To forms dendritic connections to p_From, and on p_From you have the axonic connections.}\par
203     {\cf18 void} create_Connections(uint64_t p_To_NID, {\cf18 int} p_Count, uint64_t* p_From_NID)\par
204     \{\par
205         c_Node** tmp_From = NULL;\par
206         tmp_From = {\cf17 new} c_Node * [p_Count];\par
207 \par
208         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
209         \{\par
210             tmp_From[cou_Index] = Base.get_Node_Ref_By_NID(p_From_NID[cou_Index]);\par
211         \}\par
212 \par
213         Base.create_Connections(Base.get_Node_Ref_By_NID(p_To_NID), p_Count, tmp_From);\par
214 \par
215         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
216         \{\par
217             tmp_From[cou_Index] = NULL;\par
218         \}\par
219 \par
220         {\cf19 if} (tmp_From != NULL) \{ {\cf17 delete}[] tmp_From; tmp_From = NULL; \}\par
221     \}\par
222   \par
223 \par
224     {\cf20 //---==  does_Upper_Tier_Connection_Exist [LEGS] [LEG_COUNT]  ==---//}\par
225     {\cf20 //Checks if an upper tier node exists.}\par
226     uint64_t does_Upper_Tier_Connection_Exist_Network({\cf18 int} p_Count, uint64_t* p_Legs_NID)\par
227     \{\par
228         c_Node** tmp_Legs = NULL;\par
229         tmp_Legs = {\cf17 new} c_Node * [p_Count];\par
230         c_Node* tmp_Return_Node = NULL;\par
231 \par
232         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
233         \{\par
234             tmp_Legs[cou_Index] = Base.get_Node_Ref_By_NID(p_Legs_NID[cou_Index]);\par
235         \}\par
236 \par
237         tmp_Return_Node = Base.does_Upper_Tier_Connection_Exist(p_Count, tmp_Legs);\par
238 \par
239         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
240         \{\par
241             tmp_Legs[cou_Index] = NULL;\par
242         \}\par
243 \par
244         {\cf19 if} (tmp_Legs != NULL) \{ {\cf17 delete}[] tmp_Legs; tmp_Legs = NULL; \}\par
245 \par
246         {\cf19 if} (tmp_Return_Node != NULL) \{ {\cf19 return} tmp_Return_Node->NID; \}\par
247         {\cf19 return} NULL;\par
248     \}\par
249   \par
250 \par
251     {\cf20 //---==  get_Upper_Tier_Node [LEGS] [LEG_COUNT]  ==---//}\par
252     {\cf20 //Gets an upper tier node based on the given legs. Will create it if not found.}\par
253     uint64_t get_Upper_Tier_Node({\cf18 int} p_Count, uint64_t* p_Legs_NID)\par
254     \{\par
255         c_Node** tmp_Legs = NULL;\par
256         tmp_Legs = {\cf17 new} c_Node * [p_Count];\par
257         c_Node* tmp_Return_Node = NULL;\par
258 \par
259         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
260         \{\par
261             tmp_Legs[cou_Index] = Base.get_Node_Ref_By_NID(p_Legs_NID[cou_Index]);\par
262         \}\par
263 \par
264         tmp_Return_Node = Base.get_Upper_Tier_Node(p_Count, tmp_Legs);\par
265 \par
266         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
267         \{\par
268             tmp_Legs[cou_Index] = NULL;\par
269         \}\par
270 \par
271         {\cf19 if} (tmp_Legs != NULL) \{ {\cf17 delete}[] tmp_Legs; tmp_Legs = NULL; \}\par
272 \par
273         {\cf19 if} (tmp_Return_Node != NULL) \{ {\cf19 return} tmp_Return_Node->NID; \}\par
274         {\cf19 return} NULL;\par
275     \}\par
276 \par
277   \par
278     {\cf20 //---==  does_State_Node_Exist [ASSEMBLY_ID] [STATE]  ==---//}\par
279     {\cf20 //If a state node exists in the given construct index then return it.}\par
280     {\cf20 //Otherwise return NULL.}\par
281     {\cf20 //This assumes the [Index] is valid}\par
282     uint64_t does_State_Node_Exist({\cf18 int} p_Assembly, uint64_t p_State)\par
283     \{\par
284         c_Node* tmp_Node = NULL;\par
285         tmp_Node = Base.does_State_Node_Exist(p_Assembly, p_State);\par
286 \par
287         {\cf19 if} (tmp_Node != NULL) \{ {\cf19 return} tmp_Node->NID; \}\par
288         {\cf19 return} 0;\par
289     \}\par
290   \par
291 \par
292     {\cf20 //---==  get_State_Node [ASSEMBLY_ID] [STATE]  ==---//}\par
293     {\cf20 //Checks to see if a node in the given assembly is bound to the given state, if not the node is created.}\par
294     uint64_t get_State_Node({\cf18 int} p_Assembly, uint64_t p_State)\par
295     \{\par
296         c_Node* tmp_Node = NULL;\par
297         tmp_Node = Base.get_State_Node(p_Assembly, p_State);\par
298 \par
299         {\cf19 if} (tmp_Node != NULL) \{ {\cf19 return} tmp_Node->NID; \}\par
300         {\cf19 return} 0;\par
301     \}\par
302   \par
303 \par
304     {\cf20 //---==  output_BP  ==---//}\par
305     {\cf20 //Iterates through every node and outputs their bp_O()}\par
306     {\cf18 void} output_BP()\par
307     \{\par
308         Base.output_BP();\par
309     \}\par
310 \par
311   \par
312     {\cf20 //---==  output_BP_NID [NID]  ==---//}\par
313     {\cf20 //Finds given NID and outputs the bp_O()}\par
314     {\cf18 void} output_BP_NID({\cf18 int} p_NID)\par
315     \{\par
316         Base.output_BP_NID(p_NID);\par
317     \}\par
318 \par
319   \par
320     {\cf20 //---==  output_Node_Network  ==---//}\par
321     {\cf20 //Outputs all of the nodes as raw.}\par
322     {\cf18 void} output_Node_Network()\par
323     \{\par
324         Base.output_Node_Network();\par
325     \}\par
326 \par
327 \par
328 \par
329     {\cf20 //    ---=========---}\par
330     {\cf20 //   ---===========---}\par
331     {\cf20 //  ---==   CAN   ==---}\par
332     {\cf20 //   ---===========---}\par
333     {\cf20 //    ---=========---}\par
334 \par
335     {\cf20 //---==  encode [ASSEMBLY_ID]  ==---//}\par
336     {\cf20 //This encodes the p_Input data, if the nodes aren't found they are created, used for training.}\par
337     {\cf20 //Encodes the current input of the given assembly. How it does this is determined by what type of assembly it is.}\par
338     {\cf18 void} encode({\cf18 int} p_Assembly)\par
339     \{\par
340         Base.encode(p_Assembly);\par
341     \}\par
342 \par
343 \par
344     {\cf20 //    ---==  query [ASSEMBLY_ID]  ==---}\par
345     {\cf20 //This sets up the scaffold as encode does, but it doesn't create nodes if they aren't found, they remain NULL in the scaffold, this we call a NULLCAN}\par
346     {\cf20 //Used for querying the network, you input, fill the NULLCAN, charge the network, then gather the outputs.}\par
347     {\cf20 //Suggested for use before encoding (if using learning mode and not locked_to_initial_training_mode) otherwise it will also find the current trace as the perfect match.}\par
348     {\cf20 //      Queries the network with the current input set for the given assembly.}\par
349         {\cf20 //Passes the values to an assembly to encode.}\par
350     {\cf18 void} query({\cf18 int} p_Assembly)\par
351     \{\par
352         Base.query(p_Assembly);\par
353     \}\par
354 \par
355     {\cf20 //    ---==  query_spacial [ASSEMBLY_ID]  ==---}\par
356     {\cf20 //      Queries the network with the current input set of the given assembly, but the input index determines what leg is charged. Meaning if an input at index [3] is charged then only upper tier nodes connected on axon hillock [3] will be charged.}\par
357         {\cf20 //Passes the values to an assembly to encode.}\par
358     {\cf18 void} query_Spacial({\cf18 int} p_Assembly)\par
359     \{\par
360         Base.query(p_Assembly, NULL, 0, 1);\par
361     \}\par
362 \par
363     {\cf20 //    ---==  query_given_index [ASSEMBLY_ID] [INDEX]  ==---}\par
364     {\cf20 //      Queries the network with the current input set, however, every input node is charged on the given index. If INDEX is [3] then all nodes in the input set will be charging using axon hillock [3].}\par
365         {\cf20 //Passes the values to an assembly to encode.}\par
366     {\cf18 void} query_Given_Index({\cf18 int} p_Assembly, {\cf18 int} p_Index)\par
367     \{\par
368         Base.query(p_Assembly, NULL, 0, 2, p_Index);\par
369     \}\par
370 \par
371     {\cf20 //    ---==  query_given_legs[ASSEMBLY_ID] [LEG_COUNT] [LEG_0] [LEG_1] [...]  ==---}\par
372     {\cf18 void} query_Given_Legs({\cf18 int} p_Assembly, {\cf18 int} p_Leg_Count, {\cf18 int}* p_Legs)\par
373     \{\par
374         Base.query(p_Assembly, NULL, 0, 3, p_Leg_Count, p_Legs);\par
375     \}\par
376 \par
377 \par
378     {\cf20 //---==  submit_Set [ASSEMBLY_ID] [INPUT_UINT[]] [DEPTH]  ==---//}\par
379     {\cf20 //This allows for passing unordered sets of nodes}\par
380     {\cf18 void} submit_Set({\cf18 int} p_Assembly, {\cf18 int} p_Depth, uint64_t* p_Input)\par
381     \{\par
382         Base.submit_Set(p_Assembly, p_Depth, p_Input);\par
383     \}\par
384 \par
385 \par
386     {\cf20 //---==  get_Treetop [ASSEMBLY_ID]  ==---//}\par
387     {\cf20 //Gets the treetop node for a given assembly.}\par
388     {\cf20 //This returns the treetop node at a given index, for most structures this will be a single node, but for those like stiched-base networks with a treetop node count equal to the input node count then you can access them by index.}\par
389     {\cf20 //Gets the treetop node for a given assembly.}\par
390     uint64_t get_Treetop_NID({\cf18 int} p_Assembly)\par
391     \{\par
392         {\cf19 return} Base.get_Treetop_NID(p_Assembly);\par
393     \}\par
394 \par
395 \par
396     {\cf20 //---==  gather_Given_Trace [ASSEMBLY_ID] [NID]  ==---//}\par
397     {\cf20 //Gets a single trace from a given node. Puts it into the output.}\par
398     {\cf18 void} gather_Given_Trace({\cf18 int} p_Assembly, uint64_t p_NID)\par
399     \{\par
400         Base.gather_Given_Trace(p_Assembly, p_NID);\par
401     \}\par
402 \par
403 \par
404     {\cf20 //---==  gather_All_Traces [ASSEMBLY]  ==---//}\par
405     {\cf20 //Gathers all the traces as it says.}\par
406     {\cf18 void} gather_All_Traces({\cf18 int} p_Assembly)\par
407     \{\par
408         Base.gather_All_Traces(p_Assembly);\par
409     \}\par
410 \par
411 \par
412     {\cf20 //---==  reset_Input [ASSEMBLY_ID]  ==---//}\par
413     {\cf20 //Wipe the input array.}\par
414     {\cf18 void} reset_Input({\cf18 int} p_Assembly)\par
415     \{\par
416         Base.reset_Input(p_Assembly);\par
417     \}\par
418 \par
419 \par
420     {\cf20 //---==  set_State_Nodes_Index [ASSEMBLY_ID] [INDEX]  ==---//}\par
421     {\cf20 //Sets the index for the state_Node_Tree in the c_Node_Network::State_Nodes[]}\par
422     {\cf18 void} set_State_Nodes_Index({\cf18 int} p_Assembly, {\cf18 int} p_Index)\par
423     \{\par
424         Base.set_State_Nodes_Index(p_Assembly, p_Index);\par
425     \}\par
426 \par
427 \par
428     \par
429 \par
430     {\cf20 //---==  output_Scaffold [ASSEMBLY_ID]  ==---//}\par
431     {\cf20 //Outputs the scaffold as addresses.}\par
432     {\cf18 void} output_Scaffold({\cf18 int} p_Assembly)\par
433     \{\par
434         Base.output_Scaffold(p_Assembly);\par
435     \}\par
436 \par
437 \par
438     {\cf20 //---==  output_Input [ASSEMBLY_ID]  ==---//}\par
439     {\cf20 //      Outputs the input of the given assembly to the console.}\par
440     {\cf18 void} output_Input({\cf18 int} p_Assembly)\par
441     \{\par
442         Base.output_Input(p_Assembly);\par
443     \}\par
444 \par
445 \par
446     {\cf20 //---==  output_Input [ASSEMBLY_ID]  ==---//}\par
447     {\cf20 //      Outputs the input of the given assembly to the console.}\par
448     {\cf18 void} output_Input_uint({\cf18 int} p_Assembly)\par
449     \{\par
450         Base.output_Input_uint(p_Assembly);\par
451     \}\par
452 \par
453 \par
454     {\cf20 //---==  output_Output [ASSEMBLY_ID]  ==---//}\par
455     {\cf20 //The output trace set is output.}\par
456     {\cf18 void} output_Output({\cf18 int} p_Assembly)\par
457     \{\par
458         Base.output_Output(p_Assembly);\par
459     \}\par
460 \par
461 \par
462     {\cf20 //---==  output_Output [ASSEMBLY_ID]  ==---//}\par
463     {\cf20 //The output trace set is output.}\par
464     {\cf18 void} output_Output_uint({\cf18 int} p_Assembly)\par
465     \{\par
466         Base.output_Output_uint(p_Assembly);\par
467     \}\par
468 \par
469 \par
470     {\cf20 //---==  output_Scaffold_Char [ASSEMBLY_ID]  ==---//}\par
471     {\cf20 //Each address is typecast to a char to give a pseudo-unique look to each node. For monke brain.}\par
472     {\cf18 void} output_Scaffold_Char({\cf18 int} p_Assembly)\par
473     \{\par
474         Base.output_Scaffold_Char(p_Assembly);\par
475     \}\par
476 \par
477 \par
478 \par
479 \par
480 \par
481     {\cf20 //      ---====================---}\par
482     {\cf20 //     ---======================---}\par
483     {\cf20 //    ---========================---}\par
484     {\cf20 //   ---==========================---}\par
485     {\cf20 //  ---==   NT4 specific hooks   ==---}\par
486     {\cf20 //   ---==========================---}\par
487     {\cf20 //    ---========================---}\par
488     {\cf20 //     ---======================---}\par
489     {\cf20 //      ---====================---}\par
490 \par
491 \par
492 \par
493     {\cf20 //    ---======================================---}\par
494     {\cf20 //   ---========================================---}\par
495     {\cf20 //  ---==   Used to register new assemblies.   ==---}\par
496     {\cf20 //   ---========================================---}\par
497     {\cf20 //    ---======================================---}\par
498 \par
499         {\cf20 //    ---==  register_assembly [ASSEMBLY_TYPE] [ASSEMBLY_NAME]  ==---}\par
500         {\cf20 //p_Type is the type of CAN to declare. }\par
501         {\cf20 // "Many_To_One" - The I/O tier has every node connected to a single upper tier node.}\par
502     {\cf18 int} register_Assembly(std::string p_Type, std::string p_Assembly_Name)\par
503     \{\par
504         {\cf19 return} Base.register_Assembly(p_Type, p_Assembly_Name);\par
505     \}\par
506 \par
507 \par
508 \par
509 \par
510     {\cf20 //    ---=====================---}\par
511     {\cf20 //   ---=======================---}\par
512     {\cf20 //  ---==   Input handling.   ==---}\par
513     {\cf20 //   ---=======================---}\par
514     {\cf20 //    ---=====================---}\par
515 \par
516 {\cf20 //    ---==  load_input  ==---}\par
517     {\cf18 int} load_Input({\cf18 int} p_Assembly)\par
518     \{\par
519         {\cf19 return} Base.load_Input(p_Assembly);\par
520     \}\par
521 \par
522     {\cf18 int} load_Input_uint({\cf18 int} p_Assembly)\par
523     \{\par
524         {\cf19 return} Base.load_Input_uint(p_Assembly);\par
525     \}\par
526 \par
527     {\cf20 //    ---==  set_input [ASSEMBLY_ID] [INPUT_STRING]  ==---}\par
528         {\cf20 //Set the value to the passed 1D string of uint64_t}\par
529     {\cf18 void} set_Input({\cf18 int} p_Assembly, std::string p_Input)\par
530     \{\par
531         Base.set_Input(p_Assembly, p_Input);\par
532     \}\par
533 \par
534     {\cf20 //    ---==  set_input_uint [ASSEMBLY_ID] [ARRAY_DEPTH] [UINT_ARRAY]  ==---}\par
535         {\cf20 //Set the value to the passed 1D string of uint64_t}\par
536     {\cf18 void} set_Input_uint({\cf18 int} p_Assembly, {\cf18 int} p_Depth, uint64_t* p_Input)\par
537     \{\par
538         Base.set_Input_uint(p_Assembly, p_Depth, p_Input);\par
539     \}\par
540 \par
541 \par
542 \par
543 \par
544     {\cf20 //---==  set_Input [ASSEMBLY_ID] [INPUT_UINT[]] [INPUT_DEPTH]  ==---//}\par
545     {\cf20 //Sets the input to the given uint64_t array.}\par
546     {\cf20 //The input array is 1D}\par
547     {\cf18 void} set_Input({\cf18 int} p_Assembly, {\cf18 int} p_Input_Depth, uint64_t* p_Input)\par
548     \{\par
549         Base.set_Input(p_Assembly, p_Input_Depth, p_Input);\par
550     \}\par
551 \par
552 \par
553 \par
554     {\cf20 //Sets the input to the given uint64_t 2d array.}\par
555     {\cf20 //The input array is 2D}\par
556     {\cf18 void} set_2D_Input_uint({\cf18 int} p_Assembly, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, uint64_t** p_Input)\par
557     \{\par
558         Base.set_2D_Input(p_Assembly, p_X_Depth, p_Y_Depth, p_Input);\par
559     \}\par
560 \par
561 \par
562     {\cf20 //Sets the input to the given uint64_t 3d array.}\par
563     {\cf20 //The input array is 3D}\par
564     {\cf18 void} set_3D_Input_uint({\cf18 int} p_Assembly, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, {\cf18 int} p_Z_Depth, uint64_t*** p_Input)\par
565     \{\par
566         Base.set_3D_Input(p_Assembly, p_X_Depth, p_Y_Depth, p_Z_Depth, p_Input);\par
567     \}\par
568 \par
569 \par
570 \par
571     {\cf20 //---==  set_Input_String [ASSEMBLY_ID] [INPUT_STR]  ==---//}\par
572     {\cf20 //This is used for setting the input array to reflect a sequence of characters.}\par
573     {\cf18 void} set_Input_String({\cf18 int} p_Assembly, std::string p_Input)\par
574     \{\par
575         Base.set_Input_String(p_Assembly, p_Input);\par
576     \}\par
577 \par
578     {\cf20 //    ---==========================================================================---}\par
579     {\cf20 //   ---============================================================================---}\par
580     {\cf20 //  ---==   Different ways of gathering nodes, individually, and the entire set.   ==---}\par
581     {\cf20 //   ---============================================================================---}\par
582     {\cf20 //    ---==========================================================================---}\par
583 \par
584     {\cf20 //    ---==  gather_given_node [ASSEMBLY_ID] [NID]  ==---}\par
585     {\cf20 //      Writes the given node's data down in the Assembly_Output_Files[p_Assembly] file.}\par
586     {\cf18 void} gather_Given_Node({\cf18 int} p_Assembly, uint64_t p_NID)\par
587     \{\par
588         Base.gather_Given_Node(p_Assembly, p_NID);\par
589     \}\par
590 \par
591     {\cf20 //      Writes the given node's data down in the Assembly_Output_Files[p_Assembly] file.}\par
592     {\cf18 void} gather_Given_Node_uint({\cf18 int} p_Assembly, uint64_t p_NID)\par
593     \{\par
594         Base.gather_Given_Node_uint(p_Assembly, p_NID);\par
595     \}\par
596 \par
597     {\cf20 //    ---==  gather_all_nodes [ASSEMBLY_ID]  ==---}\par
598     {\cf20 //      This writes the entire network to the Assembly_Output_Files[p_Assembly] file. Note, the output patterns are treated as character.}\par
599         {\cf20 //It uses the passed assembly to output the nodes by putting it into the output of that assembly, then into the file.}\par
600     {\cf18 void} gather_All_Nodes({\cf18 int} p_Assembly)\par
601     \{\par
602         Base.gather_All_Nodes(p_Assembly);\par
603     \}\par
604 \par
605     {\cf20 //    ---==  gather_all_nodes_uint [ASSEMBLY_ID]  ==---}\par
606     {\cf20 //      This writes the entire network to the Assembly_Output_Files[p_Assembly] file. Note, the output patterns are treated as uint.}\par
607     {\cf18 void} gather_All_Nodes_uint({\cf18 int} p_Assembly)\par
608     \{\par
609         Base.gather_All_Nodes_uint(p_Assembly);\par
610     \}\par
611 \par
612 \par
613     {\cf20 //    ---==================================================================---}\par
614     {\cf20 //   ---====================================================================---}\par
615     {\cf20 //  ---==   The output of a given assembly is read into the output file.   ==---}\par
616     {\cf20 //   ---====================================================================---}\par
617     {\cf20 //    ---==================================================================---}\par
618 \par
619 \par
620     {\cf20 //    ---==  gather_output [ASSEMBLY_ID]  ==---}\par
621     {\cf20 //      Takes every trace in the given Assemblies output trace array and writes them to the Assembly_Output_Files[p_Assembly] file, note the output state patterns are treated as char.}\par
622     {\cf18 void} gather_Output({\cf18 int} p_Assembly)\par
623     \{\par
624         Base.gather_Output(p_Assembly);\par
625     \}\par
626 \par
627     {\cf20 //    ---==  gather_output_uint [ASSEMBLY_ID]  ==---}\par
628     {\cf20 //      Takes every trace in the given Assemblies output trace array and writes them to the Assembly_Output_Files[p_Assembly] file, note the output state patterns are treated as uint.}\par
629     {\cf18 void} gather_Output_uint({\cf18 int} p_Assembly)\par
630     \{\par
631         Base.gather_Output_uint(p_Assembly);\par
632     \}\par
633 \par
634 \par
635     {\cf20 //    ---=============================---}\par
636     {\cf20 //   ---===============================---}\par
637     {\cf20 //  ---==   Treetop node gathering.   ==---}\par
638     {\cf20 //   ---===============================---}\par
639     {\cf20 //    ---=============================---}\par
640 \par
641     {\cf20 //    ---==  gather_treetop_node [ASSEMBLY_ID]  ==---}\par
642     {\cf20 //      This writes the current treetop node of the given assembly to the Assembly_Output_Files[p_Assembly] file. This does not erase the file.}\par
643     {\cf18 void} gather_Treetop_Node({\cf18 int} p_Assembly)\par
644     \{\par
645         Base.gather_Treetop_Node(p_Assembly);\par
646     \}\par
647 \par
648     {\cf20 //    ---==  gather_treetop_node_uint [ASSEMBLY_ID]  ==---}\par
649     {\cf20 //      This writes the current treetop node of the given assembly to the Assembly_Output_Files[p_Assembly] file. This does not erase the file.}\par
650     {\cf18 void} gather_Treetop_Node_uint({\cf18 int} p_Assembly)\par
651     \{\par
652         Base.gather_Treetop_Node_uint(p_Assembly);\par
653     \}\par
654 \par
655     {\cf20 //    ---==  gather_treetop_NID [ASSEMBLY_ID]  ==---}\par
656     {\cf20 //      This writes only the NID of the current treetop to the file. Does not erase the file.}\par
657     {\cf18 void} gather_Treetop_NID({\cf18 int} p_Assembly)\par
658     \{\par
659         Base.gather_Treetop_NID(p_Assembly);\par
660     \}\par
661 \par
662 \par
663 \par
664     {\cf20 //    ---======================================================================---}\par
665     {\cf20 //   ---========================================================================---}\par
666     {\cf20 //  ---==   Output the assembly input, output, scaffolds, node network, etc.   ==---}\par
667     {\cf20 //   ---========================================================================---}\par
668     {\cf20 //    ---======================================================================---}\par
669 \par
670     {\cf20 //    ---==  output_assemblies  ==---}\par
671     {\cf20 //      Outputs the assemblies currently registered.}\par
672     {\cf18 void} output_Assemblies()\par
673     \{\par
674         Base.output_Assemblies();\par
675     \}\par
676 \par
677     {\cf20 //      ---==================================---}\par
678     {\cf20 //     ---====================================---}\par
679     {\cf20 //    ---======================================---}\par
680     {\cf20 //   ---========================================---}\par
681     {\cf20 //  ---==   Generic commands for the engine.   ==---}\par
682     {\cf20 //   ---========================================---}\par
683     {\cf20 //    ---======================================---}\par
684     {\cf20 //     ---====================================---}\par
685     {\cf20 //      ---==================================---}\par
686 \par
687 \par
688 \par
689     {\cf20 //    ---==  clear_output  ==---}\par
690     {\cf18 int} clear_Output({\cf18 int} p_Assembly)\par
691     \{\par
692         {\cf19 return} Base.clear_Output(p_Assembly);\par
693     \}\par
694 \par
695 \par
696     {\cf20 //    ---==  output_newline  ==---}\par
697     {\cf18 int} output_Newline({\cf18 int} p_Assembly)\par
698     \{\par
699         {\cf19 return} Base.output_Newline(p_Assembly);\par
700     \}\par
701 \par
702 \par
703     {\cf18 void} save(std::string p_FName)\par
704     \{\par
705         Base.save(p_FName);\par
706     \}\par
707 \par
708     {\cf18 void} load(std::string p_FName)\par
709     \{\par
710         Base.load(p_FName);\par
711     \}\par
712 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Construct_Text_Server.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Construct_Text_Server.h}
{\xe \v include/NT4/c_Construct_Text_Server.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
51 {\cf17 const} std::string RETURN_FILE = {\cf22 "./Output/returned.ssv"};\par
52 {\cf17 class }c_Construct_Text_Server\par
53 \{\par
54 {\cf17 private}:\par
55 \par
56     {\cf20 //The construct to hook into.}\par
57     NT4::c_Construct_API API;\par
58     \par
59     {\cf20 //Current server tick.}\par
60     {\cf18 int} Tick;\par
61 \par
62     {\cf20 //    ---==  write_to_output  ==---}\par
63     {\cf18 int} write_to_output(std::string p_FName, uint64_t p_Data)\par
64     \{\par
65         {\cf20 //std::cout << "\\n\\n __COMMAND__| write_to_output |";}\par
66         {\cf20 //std::cout << " - FName \\"" << p_FName << "\\" Data:" << p_Data;}\par
67         std::ofstream tmp_Out(p_FName, std::ios::app);\par
68 \par
69         {\cf20 // Check if the flag file exists and can be opened}\par
70         {\cf19 if} (tmp_Out.is_open())\par
71         \{\par
72             tmp_Out << p_Data;\par
73         \}\par
74 \par
75         tmp_Out.close();\par
76 \par
77 \par
78         {\cf19 return} 1;\par
79     \}\par
80 \par
81     {\cf20 //    ---==  write_to_output  ==---}\par
82     {\cf18 int} write_to_output(std::string p_FName, std::string p_Data)\par
83     \{\par
84         {\cf20 //std::cout << "\\n\\n __COMMAND__| write_to_output |";}\par
85 \par
86         std::ofstream tmp_Out(p_FName, std::ios::app);\par
87 \par
88         {\cf20 // Check if the flag file exists and can be opened}\par
89         {\cf19 if} (tmp_Out.is_open())\par
90         \{\par
91             tmp_Out << p_Data;\par
92         \}\par
93 \par
94         tmp_Out.close();\par
95 \par
96 \par
97         {\cf19 return} 1;\par
98     \}\par
99 \par
100 \par
101 \par
102 \par
103     {\cf18 int} eval_Command(std::string p_Command, std::ifstream* p_File)\par
104     \{\par
105         {\cf20 //Meta commands for the engine rather than the nodes and internal structures.}\par
106         {\cf19 if} (p_Command == {\cf22 "exit"}) \{ {\cf19 return} -1; \}\par
107 \par
108         {\cf20 //Data Loading and Preparation:}\par
109         {\cf19 if} (p_Command == {\cf22 "reset_Input"}) \{ reset_Input(p_File); {\cf19 return} 1; \}\par
110         {\cf19 if} (p_Command == {\cf22 "set_Input"}) \{ set_Input(p_File); {\cf19 return} 1; \}\par
111         {\cf19 if} (p_Command == {\cf22 "set_Input_uint"}) \{ set_Input_uint(p_File); {\cf19 return} 1; \}\par
112         {\cf19 if} (p_Command == {\cf22 "set_2D_Input_uint"}) \{ set_2D_Input_uint(p_File); {\cf19 return} 1; \}\par
113         {\cf19 if} (p_Command == {\cf22 "set_3D_Input_uint"}) \{ set_3D_Input_uint(p_File); {\cf19 return} 1; \}\par
114         {\cf19 if} (p_Command == {\cf22 "load_Input"}) \{ load_Input(p_File); {\cf19 return} 1; \}\par
115         {\cf19 if} (p_Command == {\cf22 "load_Input_uint"}) \{ load_Input_uint(p_File); {\cf19 return} 1; \}\par
116 \par
117         {\cf20 //Neural Network Construction and Initialization:}\par
118         {\cf19 if} (p_Command == {\cf22 "register_New_Construct"}) \{ register_New_Construct(); {\cf19 return} 1; \}\par
119         {\cf19 if} (p_Command == {\cf22 "register_Assembly"}) \{ register_Assembly(p_File); {\cf19 return} 1; \}\par
120         {\cf19 if} (p_Command == {\cf22 "set_State_Nodes_Index"}) \{ set_State_Nodes_Index(p_File); {\cf19 return} 1; \}\par
121 \par
122         {\cf20 //Saving and loading the whole thing.}\par
123         {\cf19 if} (p_Command == {\cf22 "save"}) \{ save(p_File); {\cf19 return} 1; \}\par
124         {\cf19 if} (p_Command == {\cf22 "load"}) \{ load(p_File); {\cf19 return} 1; \}\par
125 \par
126         {\cf20 //Node Manipulations}\par
127         {\cf19 if} (p_Command == {\cf22 "set_Type"}) \{ set_Type(p_File); {\cf19 return} 1; \}\par
128         {\cf19 if} (p_Command == {\cf22 "add_Axon_Index"}) \{ add_Axon_Index(p_File); {\cf19 return} 1; \}\par
129         {\cf19 if} (p_Command == {\cf22 "set_Dendrites"}) \{ set_Dendrites(p_File); {\cf19 return} 1; \}\par
130         {\cf19 if} (p_Command == {\cf22 "does_Upper_Tier_Connection_Exist"}) \{ does_Upper_Tier_Connection_Exist(p_File); {\cf19 return} 1; \}\par
131         {\cf19 if} (p_Command == {\cf22 "does_Lower_Connection_Exist"}) \{ does_Lower_Connection_Exist(p_File); {\cf19 return} 1; \}\par
132         {\cf19 if} (p_Command == {\cf22 "bind_State"}) \{ bind_State(p_File); {\cf19 return} 1; \}\par
133         {\cf19 if} (p_Command == {\cf22 "bp_O"}) \{ bp_O(p_File); {\cf19 return} 1; \}\par
134 \par
135         {\cf20 //Network Manipulations}\par
136         {\cf19 if} (p_Command == {\cf22 "get_Upper_Tier_Node"}) \{ get_Upper_Tier_Node(p_File); {\cf19 return} 1; \}\par
137         {\cf19 if} (p_Command == {\cf22 "does_State_Node_Exist"}) \{ does_State_Node_Exist(p_File); {\cf19 return} 1; \}\par
138         {\cf19 if} (p_Command == {\cf22 "get_State_Node"}) \{ get_State_Node(p_File); {\cf19 return} 1; \}\par
139         {\cf19 if} (p_Command == {\cf22 "does_Upper_Tier_Connection_Exist_Network"}) \{ does_Upper_Tier_Connection_Exist_Network(p_File); {\cf19 return} 1; \}\par
140         {\cf19 if} (p_Command == {\cf22 "new_Node"}) \{ new_Node(); {\cf19 return} 1; \}\par
141         {\cf19 if} (p_Command == {\cf22 "new_State_Node"}) \{ new_State_Node(p_File); {\cf19 return} 1; \}\par
142         {\cf19 if} (p_Command == {\cf22 "create_Connections"}) \{ create_Connections(p_File); {\cf19 return} 1; \}\par
143 \par
144         {\cf20 //Network Encoding}\par
145         {\cf19 if} (p_Command == {\cf22 "encode"}) \{ encode(p_File); {\cf19 return} 1; \}\par
146 \par
147         {\cf20 //Network Evaluation and Inference:}\par
148         {\cf19 if} (p_Command == {\cf22 "query"}) \{ query(p_File); {\cf19 return} 1; \}\par
149         {\cf19 if} (p_Command == {\cf22 "query_Spacial"}) \{ query_Spacial(p_File); {\cf19 return} 1; \}\par
150         {\cf19 if} (p_Command == {\cf22 "query_Given_Index"}) \{ query_Given_Index(p_File); {\cf19 return} 1; \}\par
151         {\cf19 if} (p_Command == {\cf22 "query_Given_Legs"}) \{ query_Given_Legs(p_File); {\cf19 return} 1; \}\par
152         {\cf19 if} (p_Command == {\cf22 "submit_Set"}) \{ submit_Set(p_File); {\cf19 return} 1; \}\par
153 \par
154         {\cf20 //Network Output Gathering}\par
155         {\cf19 if} (p_Command == {\cf22 "get_Treetop_NID"}) \{ get_Treetop_NID(p_File); {\cf19 return} 1; \}\par
156         {\cf19 if} (p_Command == {\cf22 "gather_Given_Trace"}) \{ gather_Given_Trace(p_File); {\cf19 return} 1; \}\par
157         {\cf19 if} (p_Command == {\cf22 "gather_All_Traces"}) \{ gather_All_Traces(p_File); {\cf19 return} 1; \}\par
158         {\cf19 if} (p_Command == {\cf22 "gather_Given_Node"}) \{ gather_Given_Node(p_File); {\cf19 return} 1; \}\par
159         {\cf19 if} (p_Command == {\cf22 "gather_Given_Node_uint"}) \{ gather_Given_Node_uint(p_File); {\cf19 return} 1; \}\par
160         {\cf19 if} (p_Command == {\cf22 "gather_All_Nodes"}) \{ gather_All_Nodes(p_File); {\cf19 return} 1; \}\par
161         {\cf19 if} (p_Command == {\cf22 "gather_All_Nodes_uint"}) \{ gather_All_Nodes_uint(p_File); {\cf19 return} 1; \}\par
162         {\cf19 if} (p_Command == {\cf22 "gather_Output"}) \{ gather_Output(p_File); {\cf19 return} 1; \}\par
163         {\cf19 if} (p_Command == {\cf22 "gather_Output_uint"}) \{ gather_Output_uint(p_File); {\cf19 return} 1; \}\par
164         {\cf19 if} (p_Command == {\cf22 "gather_Treetop_Node"}) \{ gather_Treetop_Node(p_File); {\cf19 return} 1; \}\par
165         {\cf19 if} (p_Command == {\cf22 "gather_Treetop_Node_uint"}) \{ gather_Treetop_Node_uint(p_File); {\cf19 return} 1; \}\par
166         {\cf19 if} (p_Command == {\cf22 "gather_Treetop_NID"}) \{ gather_Treetop_NID(p_File); {\cf19 return} 1; \}\par
167 \par
168         {\cf20 //File Output:}\par
169         {\cf19 if} (p_Command == {\cf22 "clear_Output"}) \{ clear_Output(p_File); {\cf19 return} 1; \}\par
170         {\cf19 if} (p_Command == {\cf22 "output_Newline"}) \{ output_Newline(p_File); {\cf19 return} 1; \}\par
171 \par
172         {\cf20 //Console Output:}\par
173         {\cf19 if} (p_Command == {\cf22 "output_Node_Raw"}) \{ output_Node_Raw(p_File); {\cf19 return} 1; \}\par
174         {\cf19 if} (p_Command == {\cf22 "output_Node_Char"}) \{ output_Node_Char(p_File); {\cf19 return} 1; \}\par
175         {\cf19 if} (p_Command == {\cf22 "output_BP"}) \{ output_BP(); {\cf19 return} 1; \}\par
176         {\cf19 if} (p_Command == {\cf22 "output_BP_NID"}) \{ output_BP_NID(p_File); {\cf19 return} 1; \}\par
177         {\cf19 if} (p_Command == {\cf22 "output_Scaffold"}) \{ output_Scaffold(p_File); {\cf19 return} 1; \}\par
178         {\cf19 if} (p_Command == {\cf22 "output_Input"}) \{ output_Input(p_File); {\cf19 return} 1; \}\par
179         {\cf19 if} (p_Command == {\cf22 "output_Input_uint"}) \{ output_Input_uint(p_File); {\cf19 return} 1; \}\par
180         {\cf19 if} (p_Command == {\cf22 "output_Output"}) \{ output_Output(p_File); {\cf19 return} 1; \}\par
181         {\cf19 if} (p_Command == {\cf22 "output_Output_uint"}) \{ output_Output_uint(p_File); {\cf19 return} 1; \}\par
182         {\cf19 if} (p_Command == {\cf22 "output_Scaffold_Char"}) \{ output_Scaffold_Char(p_File); {\cf19 return} 1; \}\par
183         {\cf19 if} (p_Command == {\cf22 "output_Node_Network"}) \{ output_Node_Network(); {\cf19 return} 1; \}\par
184         {\cf19 if} (p_Command == {\cf22 "output_Node"}) \{ output_Node(p_File); {\cf19 return} 1; \}\par
185         {\cf19 if} (p_Command == {\cf22 "output_Assemblies"}) \{ output_Assemblies(); {\cf19 return} 1; \}\par
186 \par
187         {\cf20 //See if they submitted a command, these scripts are retrieved from the ./Scripts/ dir.}\par
188         std::string tmp_Command = {\cf22 "./Scripts/"} + p_Command;\par
189         interpret_File(tmp_Command);\par
190 \par
191         {\cf19 return} 0;\par
192     \}\par
193 \par
194 \par
195     {\cf20 // Load Control_Panel.ssc & issue commands}\par
196     {\cf18 int} interpret_File(std::string p_LFName)\par
197     \{\par
198         std::ifstream LF(p_LFName);\par
199 \par
200         std::string tmp_In = {\cf22 ""};\par
201         {\cf18 int} tmp_Count = 0;\par
202 \par
203         {\cf19 if} (LF.is_open())\par
204         \{\par
205             {\cf19 while} (!LF.eof())\par
206             \{\par
207                 tmp_In = {\cf22 ""};\par
208 \par
209                 LF >> tmp_In;\par
210 \par
211                 {\cf19 if} (tmp_In == {\cf22 ""}) \{ {\cf19 continue}; \}\par
212 \par
213                 {\cf20 //std::cout << "\\n - [ " << tmp_Count << " ]: " << tmp_In;}\par
214                 tmp_Count++;\par
215 \par
216 \par
217                 {\cf18 int} tmp_Result = 0;\par
218                 tmp_Result = eval_Command(tmp_In, &LF);\par
219                 \par
220                 {\cf19 if} (tmp_Result == -1) \{ {\cf19 return} -1; \}\par
221             \}\par
222 \par
223             {\cf19 return} 1;\par
224         \}\par
225         {\cf19 else}\par
226         \{\par
227             std::cerr << {\cf22 "\\n Unable to open ScriptFile "} << p_LFName << {\cf22 "...\\n"};\par
228 \par
229             {\cf19 return} 0;\par
230         \}\par
231 \par
232 \par
233         {\cf19 return} 0;\par
234     \}\par
235 \par
236 \par
237     {\cf20 //Control_Panel_Flag.ssv - Used to signal that there is a live message to read. Set by the user or an external program after inputs and controls are set and ready to have a function executed.}\par
238     {\cf18 int} check_Control_Panel_Flag()\par
239     \{\par
240         std::ifstream flagFile({\cf22 "Control_Panel_Flag.ssv"});\par
241         std::string flagValue = {\cf22 ""};\par
242 \par
243         {\cf20 // Check if the flag file exists and can be opened}\par
244         {\cf19 if} (flagFile.is_open())\par
245         \{\par
246             flagFile >> flagValue;\par
247 \par
248             {\cf20 // Read the value from the flag file}\par
249             {\cf19 if} (flagValue != {\cf22 ""})\par
250             \{\par
251                 {\cf20 // Check if the value is 1}\par
252                 {\cf19 if} (flagValue == {\cf22 "1"})\par
253                 \{\par
254                     flagFile.close();\par
255                     {\cf19 return} 1;\par
256                 \}\par
257                 {\cf19 else}\par
258                 \{\par
259                     flagFile.close();\par
260                 \}\par
261             \}\par
262             {\cf19 else}\par
263             \{\par
264                 flagFile.close();\par
265             \}\par
266         \}\par
267         {\cf19 else}\par
268         \{\par
269             std::cerr << {\cf22 "\\nUnable to open flag file.\\n"};\par
270         \}\par
271 \par
272         {\cf19 return} 0;\par
273     \}\par
274 \par
275     {\cf18 int} execute_Control_Panel_Buffer()\par
276     \{\par
277 \par
278         {\cf18 int} tmp_Result = 0;\par
279         {\cf20 //tmp_Result = interpret_Control_Panel();}\par
280         tmp_Result = interpret_File({\cf22 "Control_Panel.ssv"});\par
281 \par
282         {\cf19 if} (tmp_Result)\par
283         \{\par
284             std::ofstream clsFinishFlagFile({\cf22 "Control_Panel_Finished.ssv"}, std::ios::ate);\par
285 \par
286             {\cf20 // Check if the flag file exists and can be opened}\par
287             {\cf19 if} (clsFinishFlagFile.is_open())\par
288             \{\par
289                 clsFinishFlagFile << {\cf22 "1"};\par
290             \}\par
291 \par
292             clsFinishFlagFile.close();\par
293 \par
294         \}\par
295 \par
296         {\cf19 if} (tmp_Result == 0)\par
297         \{\par
298             std::cerr << {\cf22 "\\n\\n >>==-- ERROR: Unable to interpret the control panel file... --==<<\\n"};\par
299 \par
300             {\cf19 return} 0;\par
301         \}\par
302 \par
303         {\cf19 if} (tmp_Result == -1)\par
304         \{\par
305             std::ofstream clsFinishFlagFile({\cf22 "Control_Panel_Finished.ssv"}, std::ios::ate);\par
306 \par
307             {\cf20 // Check if the flag file exists and can be opened}\par
308             {\cf19 if} (clsFinishFlagFile.is_open())\par
309             \{\par
310                 clsFinishFlagFile << {\cf22 "1"};\par
311             \}\par
312 \par
313             clsFinishFlagFile.close();\par
314 \par
315             {\cf19 return} -1;\par
316         \}\par
317 \par
318 \par
319         std::ofstream clsFlagFile({\cf22 "Control_Panel_Flag.ssv"}, std::ios::ate);\par
320 \par
321         {\cf20 //Make sure the file was opened.}\par
322         {\cf19 if} (!clsFlagFile.is_open())\par
323         \{\par
324             std::cerr << {\cf22 "\\n\\n >>==-- ERROR: Unable to interpret the clsFlagFile file for truncation!... --==<<\\n"};\par
325         \}\par
326 \par
327         clsFlagFile.close();\par
328 \par
329         {\cf19 return} 1;\par
330     \}\par
331 \par
332 \par
333     {\cf18 int} view_File(std::string p_FileName)\par
334     \{\par
335         std::ifstream InputFile(p_FileName);\par
336 \par
337         std::string tmp_In = {\cf22 ""};\par
338         {\cf18 int} tmp_Count = 0;\par
339 \par
340         {\cf19 if} (InputFile.is_open())\par
341         \{\par
342             {\cf19 while} (!InputFile.eof())\par
343             \{\par
344                 InputFile >> tmp_In;\par
345                 std::cout << {\cf22 "\\n - [ "} << tmp_Count << {\cf22 " ]: "} << tmp_In;\par
346                 tmp_Count++;\par
347 \par
348                 {\cf20 //Neuralman.output_Input();}\par
349             \}\par
350 \par
351             std::cout << {\cf22 "\\n "} << p_FileName << {\cf22 " loaded successfully.\\n"};\par
352 \par
353             {\cf19 return} 1;\par
354         \}\par
355         {\cf19 else}\par
356         \{\par
357             std::cerr << {\cf22 "\\n Unable to open "} << p_FileName << {\cf22 " ...\\n"};\par
358 \par
359             {\cf19 return} 0;\par
360         \}\par
361     \}\par
362 \par
363 {\cf17 public}:\par
364 \par
365     c_Construct_Text_Server()\par
366     \{\par
367         Tick = 0;\par
368 \par
369         std::cout << {\cf22 "\\n\\n --==<< BOOTING UP >>==--"};\par
370 \par
371         {\cf20 //Load the boot sequence }\par
372         {\cf19 if} (interpret_File({\cf22 "autoexec.ssv"}))\par
373         \{\par
374             std::cout << {\cf22 "\\n\\n --==<< SUCCESSFULLLY BOOTED >>==--"};\par
375         \}\par
376         {\cf19 else}\par
377         \{\par
378             std::cout << {\cf22 "\\n\\n >>==-- FAILED TO BOOT PROPERLY --==<<"};\par
379         \}\par
380     \}\par
381 \par
382 \par
383     {\cf20 //        ---==================---}\par
384     {\cf20 //       ---====================---}\par
385     {\cf20 //      ---======================---}\par
386     {\cf20 //     ---========================---}\par
387     {\cf20 //    ---==   NT4 Deep Control   ==---}\par
388     {\cf20 //     ---========================---}\par
389     {\cf20 //      ---======================---}\par
390     {\cf20 //       ---====================---}\par
391     {\cf20 //        ---==================---}\par
392 \par
393 \par
394     {\cf20 //      ---==========---}\par
395     {\cf20 //     ---============---}\par
396     {\cf20 //    ---==   Node   ==--- }\par
397     {\cf20 //     ---============---}\par
398     {\cf20 //      ---==========---}\par
399 \par
431     {\cf18 void} set_Type(std::ifstream* p_File)\par
432     \{\par
433         std::cout << {\cf22 "\\n __COMMAND__| set_Type NID TYPE |"};\par
434 \par
435         {\cf18 int} tmp_NID = 0;\par
436 \par
437         *p_File >> tmp_NID;\par
438 \par
439         {\cf18 int} tmp_Type = 0;\par
440 \par
441         *p_File >> tmp_Type;\par
442 \par
443         API.set_Type(tmp_NID, tmp_Type);\par
444     \}\par
445 \par
446 \par
447 \par
480     {\cf18 void} add_Axon_Index(std::ifstream* p_File)\par
481     \{\par
482         std::cout << {\cf22 "\\n __COMMAND__| add_axon_index NID Axon_NID HILLOCK_INDEX |"};\par
483 \par
484         uint64_t tmp_NID = 0;\par
485 \par
486         *p_File >> tmp_NID;\par
487 \par
488         uint64_t tmp_Axon_NID = 0;\par
489 \par
490         *p_File >> tmp_Axon_NID;\par
491 \par
492         {\cf18 int} tmp_Index = 0;\par
493 \par
494         *p_File >> tmp_Index;\par
495 \par
496         API.add_Axon_Index(tmp_NID, tmp_Axon_NID, tmp_Index);\par
497     \}\par
498 \par
499 \par
500 \par
534     {\cf18 void} set_Dendrites(std::ifstream* p_File)\par
535     \{\par
536         std::cout << {\cf22 "\\n\\n __COMMAND__| set_Dendrites NID COUNT DENDRITES[] |"};\par
537 \par
538         uint64_t tmp_NID = 0;\par
539 \par
540         *p_File >> tmp_NID;\par
541 \par
542         {\cf18 int} tmp_Count = 0;\par
543 \par
544         *p_File >> tmp_Count;\par
545 \par
546         uint64_t * tmp_Dendrites = NULL;\par
547         tmp_Dendrites = {\cf17 new} uint64_t [tmp_Count];\par
548 \par
549         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
550         \{\par
551             *p_File >> tmp_Dendrites[cou_Index];\par
552         \}\par
553 \par
554         API.set_Dendrites(tmp_NID, tmp_Count, tmp_Dendrites);\par
555 \par
556         {\cf19 if} (tmp_Dendrites != NULL) \{ {\cf17 delete}[] tmp_Dendrites; tmp_Dendrites = NULL; \}\par
557     \}\par
558 \par
559 \par
592     uint64_t does_Upper_Tier_Connection_Exist(std::ifstream* p_File)\par
593     \{\par
594         std::cout << {\cf22 "\\n __COMMAND__| does_Upper_Tier_Connection_Exist NODE_COUNT NODES[] |"};\par
595 \par
596         uint64_t tmp_Return_NID = 0;\par
597 \par
598         {\cf18 int} tmp_Count = 0;\par
599 \par
600         *p_File >> tmp_Count;\par
601 \par
602         uint64_t* tmp_Nodes = NULL;\par
603         tmp_Nodes = {\cf17 new} uint64_t[tmp_Count];\par
604 \par
605         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
606         \{\par
607             *p_File >> tmp_Nodes[cou_Index];\par
608         \}\par
609 \par
610         tmp_Return_NID = API.does_Upper_Tier_Connection_Exist(tmp_Count, tmp_Nodes);\par
611 \par
612         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
613 \par
614         write_to_output(RETURN_FILE, tmp_Return_NID);\par
615 \par
616         {\cf19 return} tmp_Return_NID;\par
617     \}\par
618 \par
619 \par
659     {\cf18 bool} does_Lower_Connection_Exist(std::ifstream* p_File)\par
660     \{\par
661         std::cout << {\cf22 "\\n __COMMAND__| does_Lower_Connection_Exist NID NODE_COUNT NODES[] |"};\par
662 \par
663         {\cf18 bool} tmp_Return_Result = 0;\par
664 \par
665         uint64_t tmp_NID = 0;\par
666 \par
667         *p_File >> tmp_NID;\par
668 \par
669         {\cf18 int} tmp_Count = 0;\par
670 \par
671         *p_File >> tmp_Count;\par
672 \par
673         uint64_t* tmp_Nodes = NULL;\par
674         tmp_Nodes = {\cf17 new} uint64_t[tmp_Count];\par
675 \par
676         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
677         \{\par
678             *p_File >> tmp_Nodes[cou_Index];\par
679         \}\par
680 \par
681         tmp_Return_Result = API.does_Lower_Connection_Exist(tmp_NID, tmp_Count, tmp_Nodes);\par
682 \par
683         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
684 \par
685         write_to_output(RETURN_FILE, tmp_Return_Result);\par
686 \par
687         {\cf19 return} tmp_Return_Result;\par
688     \}\par
689 \par
690 \par
691 \par
724     {\cf18 void} bind_State(std::ifstream* p_File)\par
725     \{\par
726         std::cout << {\cf22 "\\n __COMMAND__| bind_State NID STATE |"};\par
727 \par
728         uint64_t tmp_NID = 0;\par
729 \par
730         *p_File >> tmp_NID;\par
731         \par
732         uint64_t tmp_State = 0;\par
733 \par
734         *p_File >> tmp_NID;\par
735 \par
736         API.bind_State(tmp_NID, tmp_State);\par
737     \}\par
738 \par
739 \par
740 \par
780     {\cf18 void} bp_O(std::ifstream* p_File)\par
781     \{\par
782         std::cout << {\cf22 "\\n __COMMAND__| bp_O NID |"};\par
783 \par
784         uint64_t tmp_NID = 0;\par
785 \par
786         *p_File >> tmp_NID;\par
787 \par
788         API.bp_O(tmp_NID);\par
789     \}\par
790 \par
791 \par
792 \par
860     {\cf18 void} output_Node_Raw(std::ifstream* p_File)\par
861     \{\par
862         std::cout << {\cf22 "\\n __COMMAND__| output_Node_Raw NID |"};\par
863 \par
864         uint64_t tmp_NID = 0;\par
865 \par
866         *p_File >> tmp_NID;\par
867 \par
868         API.output_Node_Raw(tmp_NID);\par
869     \}\par
870 \par
871 \par
872 \par
902     {\cf18 void} output_Node_Char(std::ifstream* p_File)\par
903     \{\par
904         std::cout << {\cf22 "\\n __COMMAND__| output_Node_Char NID |"};\par
905 \par
906         uint64_t tmp_NID = 0;\par
907 \par
908         *p_File >> tmp_NID;\par
909 \par
910         API.output_Node_Char(tmp_NID);\par
911     \}\par
912 \par
913 \par
914 \par
915 \par
916 \par
917     {\cf20 //    ---==================---}\par
918     {\cf20 //   ---====================---}\par
919     {\cf20 //  ---==   Node_Network   ==---}\par
920     {\cf20 //   ---====================---}\par
921     {\cf20 //    ---==================---}\par
922   \par
950     {\cf18 int} register_New_Construct()\par
951     \{\par
952         std::cout << {\cf22 "\\n __COMMAND__| register_New_Construct |"};\par
953 \par
954         {\cf18 int} tmp_Construct_Return_ID = API.register_New_Construct();\par
955 \par
956         write_to_output(RETURN_FILE, tmp_Construct_Return_ID);\par
957 \par
958         {\cf19 return} tmp_Construct_Return_ID;\par
959     \}\par
960 \par
961 \par
989     uint64_t new_Node()\par
990     \{\par
991         std::cout << {\cf22 "\\n __COMMAND__| new_Node |"};\par
992 \par
993         uint64_t tmp_Return_NID = API.new_Node();\par
994 \par
995         write_to_output(RETURN_FILE, tmp_Return_NID);\par
996 \par
997         {\cf19 return} tmp_Return_NID;\par
998     \}\par
999 \par
1000 \par
1030     uint64_t new_State_Node(std::ifstream* p_File)\par
1031     \{\par
1032         std::cout << {\cf22 "\\n __COMMAND__| new_State_Node CONSTRUCT_ID STATE |"};\par
1033 \par
1034         uint64_t tmp_Construct = 0;\par
1035 \par
1036         *p_File >> tmp_Construct;\par
1037         \par
1038         uint64_t tmp_State = 0;\par
1039 \par
1040         *p_File >> tmp_State;\par
1041 \par
1042         uint64_t tmp_Return_NID = API.new_State_Node(tmp_Construct, tmp_State);\par
1043 \par
1044         write_to_output(RETURN_FILE, tmp_Return_NID);\par
1045 \par
1046         {\cf19 return} tmp_Return_NID;\par
1047     \}\par
1048 \par
1049 \par
1106     {\cf18 void} create_Connections(std::ifstream* p_File)\par
1107     \{\par
1108         std::cout << {\cf22 "\\n __COMMAND__| create_Connections TO_NID COUNT FROM_NIDS[] |"};\par
1109 \par
1110         uint64_t tmp_To_NID = 0;\par
1111 \par
1112         *p_File >> tmp_To_NID;\par
1113 \par
1114         {\cf18 int} tmp_Count = 0;\par
1115 \par
1116         *p_File >> tmp_Count;\par
1117 \par
1118         uint64_t* tmp_Nodes = NULL;\par
1119         tmp_Nodes = {\cf17 new} uint64_t[tmp_Count];\par
1120 \par
1121         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
1122         \{\par
1123             *p_File >> tmp_Nodes[cou_Index];\par
1124         \}\par
1125 \par
1126         API.create_Connections(tmp_To_NID, tmp_Count, tmp_Nodes);\par
1127 \par
1128         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
1129     \}\par
1130 \par
1131 \par
1164     uint64_t does_Upper_Tier_Connection_Exist_Network(std::ifstream* p_File)\par
1165     \{\par
1166         std::cout << {\cf22 "\\n __COMMAND__| does_Upper_Tier_Connection_Exist_Network NODE_COUNT NODES[] |"};\par
1167 \par
1168         uint64_t tmp_Return_NID = 0;\par
1169 \par
1170         uint64_t tmp_NID = 0;\par
1171 \par
1172         *p_File >> tmp_NID;\par
1173 \par
1174         {\cf18 int} tmp_Count = 0;\par
1175 \par
1176         *p_File >> tmp_Count;\par
1177 \par
1178         uint64_t* tmp_Nodes = NULL;\par
1179         tmp_Nodes = {\cf17 new} uint64_t[tmp_Count];\par
1180 \par
1181         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
1182         \{\par
1183             *p_File >> tmp_Nodes[cou_Index];\par
1184         \}\par
1185 \par
1186         tmp_Return_NID = API.does_Upper_Tier_Connection_Exist_Network(tmp_Count, tmp_Nodes);\par
1187 \par
1188         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
1189 \par
1190         write_to_output(RETURN_FILE, tmp_Return_NID);\par
1191 \par
1192         {\cf19 return} tmp_Return_NID;\par
1193     \}\par
1194 \par
1195 \par
1228     uint64_t get_Upper_Tier_Node(std::ifstream* p_File)\par
1229     \{\par
1230         std::cout << {\cf22 "\\n __COMMAND__| get_Upper_Tier_Node NODE_COUNT NODES[] |"};\par
1231 \par
1232         uint64_t tmp_Return_NID = 0;\par
1233 \par
1234         uint64_t tmp_NID = 0;\par
1235 \par
1236         *p_File >> tmp_NID;\par
1237 \par
1238         {\cf18 int} tmp_Count = 0;\par
1239 \par
1240         *p_File >> tmp_Count;\par
1241 \par
1242         uint64_t* tmp_Nodes = NULL;\par
1243         tmp_Nodes = {\cf17 new} uint64_t[tmp_Count];\par
1244 \par
1245         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
1246         \{\par
1247             *p_File >> tmp_Nodes[cou_Index];\par
1248         \}\par
1249 \par
1250         tmp_Return_NID = API.get_Upper_Tier_Node(tmp_Count, tmp_Nodes);\par
1251 \par
1252         {\cf19 if} (tmp_Nodes != NULL) \{ {\cf17 delete}[] tmp_Nodes; tmp_Nodes = NULL; \}\par
1253 \par
1254         write_to_output(RETURN_FILE, tmp_Return_NID);\par
1255 \par
1256         {\cf19 return} tmp_Return_NID;\par
1257     \}\par
1258 \par
1259 \par
1288     uint64_t does_State_Node_Exist(std::ifstream* p_File)\par
1289     \{\par
1290         std::cout << {\cf22 "\\n __COMMAND__| does_State_Node_Exist CONSTRUCT_ID STATE |"};\par
1291 \par
1292         uint64_t p_Assembly = 0;\par
1293 \par
1294         *p_File >> p_Assembly;\par
1295 \par
1296         uint64_t tmp_State = 0;\par
1297 \par
1298         *p_File >> tmp_State;\par
1299 \par
1300         uint64_t tmp_Return_NID = API.does_State_Node_Exist(p_Assembly, tmp_State);\par
1301 \par
1302         write_to_output(RETURN_FILE, tmp_Return_NID);\par
1303 \par
1304         {\cf19 return} tmp_Return_NID;\par
1305     \}\par
1306 \par
1307 \par
1337     uint64_t get_State_Node(std::ifstream* p_File)\par
1338     \{\par
1339         std::cout << {\cf22 "\\n __COMMAND__| get_State_Node CONSTRUCT_ID STATE |"};\par
1340 \par
1341         uint64_t p_Assembly = 0;\par
1342 \par
1343         *p_File >> p_Assembly;\par
1344 \par
1345         uint64_t tmp_State = 0;\par
1346 \par
1347         *p_File >> tmp_State;\par
1348 \par
1349         uint64_t tmp_Return_NID = API.get_State_Node(p_Assembly, tmp_State);\par
1350 \par
1351         write_to_output(RETURN_FILE, tmp_Return_NID);\par
1352 \par
1353         {\cf19 return} tmp_Return_NID;\par
1354     \}\par
1355 \par
1356 \par
1388     {\cf18 void} output_BP()\par
1389     \{\par
1390         std::cout << {\cf22 "\\n __COMMAND__| output_BP |"};\par
1391 \par
1392         API.output_BP();\par
1393     \}\par
1394 \par
1395 \par
1422     {\cf18 void} output_BP_NID(std::ifstream* p_File)\par
1423     \{\par
1424         std::cout << {\cf22 "\\n __COMMAND__| output_BP_NID NID |"};\par
1425 \par
1426         uint64_t tmp_NID = 0;\par
1427 \par
1428         *p_File >> tmp_NID;\par
1429 \par
1430         API.output_BP_NID(tmp_NID);\par
1431     \}\par
1432 \par
1433 \par
1434 \par
1435     {\cf20 //    ---=========---}\par
1436     {\cf20 //   ---===========---}\par
1437     {\cf20 //  ---==   CAN   ==---}\par
1438     {\cf20 //   ---===========---}\par
1439     {\cf20 //    ---=========---}\par
1440 \par
1441     {\cf20 //   ---=============================================---}\par
1442     {\cf20 //  ---==   Encoding and querying the assemblies.   ==---}\par
1443     {\cf20 //   ---=============================================---}\par
1444 \par
1540     {\cf18 void} encode(std::ifstream* p_File)\par
1541     \{\par
1542         std::cout << {\cf22 "\\n __COMMAND__| encode CONSTRUCT_ID |"};\par
1543 \par
1544         {\cf18 int} tmp_Construct = 0;\par
1545 \par
1546         *p_File >> tmp_Construct;\par
1547 \par
1548         API.encode(tmp_Construct);\par
1549     \}\par
1550 \par
1551 \par
1552     \par
1553     {\cf20 //      }\par
1554         {\cf20 //Passes the values to an assembly to encode.}\par
1776     {\cf18 void} query(std::ifstream* p_File)\par
1777     \{\par
1778         std::cout << {\cf22 "\\n __COMMAND__| query CONSTRUCT_ID |"};\par
1779 \par
1780         {\cf18 int} tmp_Construct = 0;\par
1781 \par
1782         *p_File >> tmp_Construct;\par
1783 \par
1784         API.query(tmp_Construct);\par
1785     \}\par
1786 \par
2081     {\cf18 void} query_Spacial(std::ifstream* p_File)\par
2082     \{\par
2083         {\cf18 int} tmp_Construct = 0;\par
2084 \par
2085         *p_File >> tmp_Construct;\par
2086 \par
2087         API.query_Spacial(tmp_Construct);\par
2088     \}\par
2089 \par
2310     {\cf18 void} query_Given_Index(std::ifstream* p_File)\par
2311     \{\par
2312         {\cf18 int} tmp_Construct = 0;\par
2313 \par
2314         *p_File >> tmp_Construct;\par
2315 \par
2316         {\cf18 int} tmp_Index = 0;\par
2317 \par
2318         *p_File >> tmp_Index;\par
2319 \par
2320         API.query_Given_Index(tmp_Construct, tmp_Index);\par
2321     \}\par
2322 \par
2446     {\cf18 void} query_Given_Legs(std::ifstream* p_File)\par
2447     \{\par
2448         {\cf18 int} tmp_Construct = 0;\par
2449 \par
2450         *p_File >> tmp_Construct;\par
2451 \par
2452         {\cf18 int} tmp_Count = 0;\par
2453 \par
2454         *p_File >> tmp_Count;\par
2455 \par
2456         {\cf18 int}* tmp_Legs = NULL;\par
2457         tmp_Legs = {\cf17 new} {\cf18 int}[tmp_Count];\par
2458 \par
2459         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
2460         \{\par
2461             *p_File >> tmp_Legs[cou_Index];\par
2462         \}\par
2463 \par
2464         API.query_Given_Legs(tmp_Construct, tmp_Count, tmp_Legs);\par
2465 \par
2466         {\cf19 if} (tmp_Legs != NULL) \{ {\cf17 delete}[] tmp_Legs; tmp_Legs = NULL; \}\par
2467     \}\par
2468 \par
2469 \par
2470     {\cf20 //Disabled this doxygen for the moment, I suspect this function was accidentally brought to the surface while high.}\par
2471     {\cf20 /* This allows for passing unordered sets of node IDs to be charged. }\par
2472 {\cf20 }\par
2473 {\cf20         submit_Set CONSTRUCT_ID COUNT INPUT_UINT[]}\par
2474 {\cf20     \\param int CONSTRUCT_ID The construct who's charging buffer and output will be used.}\par
2475 {\cf20     \\param COUNT The number of node IDs (NIDs) being passed.}\par
2476 {\cf20     \\param INPUT_UINT[] The array of NIDs to charge.}\par
2477 {\cf20     \\retval None This function doesn't return any values.}\par
2478 {\cf20 }\par
2479 {\cf20     This function takes a set of NIDs and then directly submits them to the charging buffers, no input, query, scaffold, etc. If you have the ID of the node(s) and want to directly charge them you can use this function.}\par
2480 {\cf20 }\par
2481 {\cf20     Example Usage:}\par
2482 {\cf20 }\par
2483 {\cf20     To start with we encode a sample dataset, output the node network to get the node IDs to use, and then we can submit_Nodes and gather the output.}\par
2484 {\cf20 }\par
2485 {\cf20     Output:}\par
2486 {\cf20 }\par
2487 {\cf20         output}\par
2488 {\cf20 }\par
2489 {\cf20     Error Handling:}\par
2490 {\cf20 }\par
2491 {\cf20     - No error handling is implemented in this function.}\par
2492 {\cf20 }\par
2493 {\cf20     Additional Notes:}\par
2494 {\cf20 }\par
2495 {\cf20     - None.}\par
2496 {\cf20     */}\par
2497     {\cf18 void} submit_Set(std::ifstream* p_File)\par
2498     \{\par
2499         {\cf18 int} tmp_Construct = 0;\par
2500 \par
2501         *p_File >> tmp_Construct;\par
2502 \par
2503         {\cf18 int} tmp_Count = 0;\par
2504 \par
2505         *p_File >> tmp_Count;\par
2506 \par
2507         uint64_t* tmp_Input = NULL;\par
2508         tmp_Input = {\cf17 new} uint64_t[tmp_Count];\par
2509 \par
2510         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Count; cou_Index++)\par
2511         \{\par
2512             *p_File >> tmp_Input[cou_Index];\par
2513         \}\par
2514 \par
2515         API.submit_Set(tmp_Construct, tmp_Count, tmp_Input);\par
2516 \par
2517         {\cf19 if} (tmp_Input != NULL) \{ {\cf17 delete}[] tmp_Input; tmp_Input = NULL; \}\par
2518     \}\par
2519 \par
2520 \par
2589     uint64_t get_Treetop_NID(std::ifstream* p_File)\par
2590     \{\par
2591         {\cf18 int} tmp_Construct = 0;\par
2592 \par
2593         *p_File >> tmp_Construct;\par
2594 \par
2595         uint64_t tmp_Return_Node = API.get_Treetop_NID(tmp_Construct);\par
2596 \par
2597         write_to_output(RETURN_FILE, tmp_Return_Node);\par
2598 \par
2599         {\cf19 return} tmp_Return_Node;\par
2600     \}\par
2601 \par
2602 \par
2655     {\cf18 void} gather_Given_Trace(std::ifstream* p_File)\par
2656     \{\par
2657         {\cf18 int} tmp_Construct = 0;\par
2658 \par
2659         *p_File >> tmp_Construct;\par
2660         \par
2661         {\cf18 int} tmp_NID = 0;\par
2662 \par
2663         *p_File >> tmp_NID;\par
2664 \par
2665         API.gather_Given_Trace(tmp_Construct, tmp_NID);\par
2666     \}\par
2667 \par
2668 \par
2669     {\cf20 //---==  gather_All_Traces [CONSTRUCT]  ==---//}\par
2670     {\cf20 //}\par
2713     {\cf18 void} gather_All_Traces(std::ifstream* p_File)\par
2714     \{\par
2715         {\cf18 int} tmp_Construct = 0;\par
2716 \par
2717         *p_File >> tmp_Construct;\par
2718 \par
2719         API.gather_All_Traces(tmp_Construct);\par
2720     \}\par
2721 \par
2722 \par
2781     {\cf18 void} reset_Input(std::ifstream* p_File)\par
2782     \{\par
2783         {\cf18 int} tmp_Construct = 0;\par
2784 \par
2785         *p_File >> tmp_Construct;\par
2786 \par
2787         API.reset_Input(tmp_Construct);\par
2788     \}\par
2789 \par
2790 \par
2895     {\cf18 void} set_State_Nodes_Index(std::ifstream* p_File)\par
2896     \{\par
2897         {\cf18 int} tmp_Construct = 0;\par
2898 \par
2899         *p_File >> tmp_Construct;\par
2900         \par
2901         {\cf18 int} tmp_Index = 0;\par
2902 \par
2903         *p_File >> tmp_Index;\par
2904 \par
2905         API.set_State_Nodes_Index(tmp_Construct, tmp_Index);\par
2906     \}\par
2907 \par
2908 \par
2909     {\cf20 //    ---==  set_input [CONSTRUCT_ID] [INPUT_STRING]  ==---}\par
3037     {\cf18 int} set_Input(std::ifstream* p_File)\par
3038     \{\par
3039         std::cout << {\cf22 "\\n\\n __COMMAND__| set_Input CONSTRUCT_ID INPUT |"};\par
3040 \par
3041         std::string tmp_In = {\cf22 ""};\par
3042         std::string tmp_In_Full = {\cf22 ""};\par
3043         {\cf18 int} tmp_Count = 0;\par
3044 \par
3045         {\cf18 int} tmp_Construct = 0;\par
3046 \par
3047         *p_File >> tmp_Construct;\par
3048 \par
3049         {\cf18 bool} flg_Gather_Input = {\cf17 true};\par
3050 \par
3051         {\cf19 while} (flg_Gather_Input)\par
3052         \{\par
3053             tmp_In = {\cf22 ""};\par
3054             *p_File >> tmp_In;\par
3055 \par
3056             std::cout << {\cf22 "\\n I - [ "} << tmp_Count << {\cf22 " ]: >"} << tmp_In << {\cf22 "<"};\par
3057 \par
3058             {\cf19 if} (tmp_In == {\cf22 "/end/"})\par
3059             \{\par
3060                 flg_Gather_Input = {\cf17 false};\par
3061                 {\cf19 continue};\par
3062             \}\par
3063 \par
3064             {\cf19 if} (tmp_In != {\cf22 ""})\par
3065             \{\par
3066 \par
3067                 tmp_Count++;\par
3068 \par
3069                 {\cf19 if} (tmp_In_Full != {\cf22 ""})\par
3070                 \{\par
3071                     tmp_In_Full = tmp_In_Full + {\cf22 " "} + tmp_In;\par
3072                 \}\par
3073                 {\cf19 else}\par
3074                 \{\par
3075                     tmp_In_Full = tmp_In;\par
3076                 \}\par
3077             \}\par
3078 \par
3079             {\cf19 if} (flg_Gather_Input)\par
3080             \{\par
3081                 flg_Gather_Input = (!p_File->eof());\par
3082             \}\par
3083         \}\par
3084         std::cout << {\cf22 "\\n Input_Full: "} << tmp_In_Full;\par
3085         API.set_Input(tmp_Construct, tmp_In_Full);\par
3086         std::cerr << {\cf22 "\\n Done Input Setting String"};\par
3087         {\cf19 return} 1;\par
3088     \}\par
3089 \par
3127     {\cf18 void} set_Input_uint(std::ifstream* p_File)\par
3128     \{\par
3129         std::cout << {\cf22 "\\n __COMMAND__| set_Input_uint CONSTRUCT_ID COUNT INPUT[] |"};\par
3130 \par
3131         {\cf18 int} tmp_Depth = 0;\par
3132         uint64_t* tmp_In_Full = NULL;\par
3133 \par
3134         {\cf18 int} tmp_Construct = 0;\par
3135 \par
3136         *p_File >> tmp_Construct;\par
3137 \par
3138         {\cf20 //Get the depth}\par
3139         *p_File >> tmp_Depth;\par
3140 \par
3141         tmp_In_Full = {\cf17 new} uint64_t[tmp_Depth];\par
3142 \par
3143         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Depth; cou_Index++)\par
3144         \{\par
3145             tmp_In_Full[cou_Index] = 0;\par
3146             *p_File >> tmp_In_Full[cou_Index];\par
3147 \par
3148             std::cout << {\cf22 "\\n I - [ "} << cou_Index << {\cf22 " ]: >"} << tmp_In_Full[cou_Index] << {\cf22 "<"};\par
3149         \}\par
3150 \par
3151         API.set_Input_uint(tmp_Construct, tmp_Depth, tmp_In_Full);\par
3152     \}\par
3153 \par
3154 \par
3155     {\cf18 void} set_2D_Input_uint(std::ifstream* p_File)\par
3156     \{\par
3157         std::cout << {\cf22 "\\n __COMMAND__| set_2D_Input_uint CONSTRUCT_ID X_COUNT Y_COUNT INPUT[][] |"};\par
3158 \par
3159         {\cf18 int} tmp_X_Depth = 0;\par
3160         {\cf18 int} tmp_Y_Depth = 0;\par
3161         uint64_t** tmp_In_Full = NULL;\par
3162 \par
3163         {\cf18 int} tmp_Construct = 0;\par
3164 \par
3165         *p_File >> tmp_Construct;\par
3166 \par
3167         {\cf20 //Get the depth}\par
3168         *p_File >> tmp_X_Depth;\par
3169 \par
3170         {\cf20 //Get the depth}\par
3171         *p_File >> tmp_Y_Depth;\par
3172 \par
3173         tmp_In_Full = {\cf17 new} uint64_t*[tmp_X_Depth];\par
3174         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < tmp_X_Depth; cou_X++)\par
3175         \{\par
3176             tmp_In_Full[cou_X] = {\cf17 new} uint64_t[tmp_Y_Depth];\par
3177 \par
3178             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < tmp_Y_Depth; cou_Y++)\par
3179             \{\par
3180                 tmp_In_Full[cou_X][cou_Y] = 0;\par
3181                 *p_File >> tmp_In_Full[cou_X][cou_Y];\par
3182 \par
3183                 {\cf20 //std::cout << "\\n I - [ " << cou_X << " ][ " << cou_Y << " ]: >" << tmp_In_Full[cou_X][cou_Y] << "<";}\par
3184             \}\par
3185         \}\par
3186 \par
3187         API.set_2D_Input_uint(tmp_Construct, tmp_X_Depth, tmp_Y_Depth, tmp_In_Full);\par
3188     \}\par
3189 \par
3190 \par
3191     {\cf18 void} set_3D_Input_uint(std::ifstream* p_File)\par
3192     \{\par
3193         std::cout << {\cf22 "\\n __COMMAND__| set_2D_Input_uint CONSTRUCT_ID X_COUNT Y_COUNT Z_COUNT INPUT[][] |"};\par
3194 \par
3195         {\cf18 int} tmp_X_Depth = 0;\par
3196         {\cf18 int} tmp_Y_Depth = 0;\par
3197         {\cf18 int} tmp_Z_Depth = 0;\par
3198         uint64_t*** tmp_In_Full = NULL;\par
3199 \par
3200         {\cf18 int} tmp_Construct = 0;\par
3201 \par
3202         *p_File >> tmp_Construct;\par
3203 \par
3204         {\cf20 //Get the depth}\par
3205         *p_File >> tmp_X_Depth;\par
3206 \par
3207         {\cf20 //Get the depth}\par
3208         *p_File >> tmp_Y_Depth;\par
3209 \par
3210         {\cf20 //Get the depth}\par
3211         *p_File >> tmp_Z_Depth;\par
3212 \par
3213         tmp_In_Full = {\cf17 new} uint64_t**[tmp_X_Depth];\par
3214         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < tmp_X_Depth; cou_X++)\par
3215         \{\par
3216             tmp_In_Full[cou_X] = {\cf17 new} uint64_t*[tmp_Y_Depth];\par
3217 \par
3218             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < tmp_Y_Depth; cou_Y++)\par
3219             \{\par
3220                 tmp_In_Full[cou_X][cou_Y] = {\cf17 new} uint64_t [tmp_Z_Depth];\par
3221 \par
3222                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < tmp_Z_Depth; cou_Z++)\par
3223                 \{\par
3224                     tmp_In_Full[cou_X][cou_Y][cou_Z] = 0;\par
3225                     *p_File >> tmp_In_Full[cou_X][cou_Y][cou_Z];\par
3226 \par
3227                     std::cout << {\cf22 "\\n I - [ "} << cou_X << {\cf22 " ][ "} << cou_Y << {\cf22 " ][ "} << cou_Z << {\cf22 " ]: >"} << tmp_In_Full[cou_X][cou_Y][cou_Z] << {\cf22 "<"};\par
3228                 \}\par
3229             \}\par
3230         \}\par
3231 \par
3232         API.set_3D_Input_uint(tmp_Construct, tmp_X_Depth, tmp_Y_Depth, tmp_Z_Depth, tmp_In_Full);\par
3233     \}\par
3234 \par
3235 \par
3236 \par
3237 \par
3281     {\cf18 void} output_Scaffold(std::ifstream* p_File)\par
3282     \{\par
3283         std::cout << {\cf22 "\\n __COMMAND__| output_Scaffold CONSTRUCT_ID |"};\par
3284 \par
3285         {\cf18 int} tmp_Construct = 0;\par
3286 \par
3287         *p_File >> tmp_Construct;\par
3288 \par
3289         API.output_Scaffold(tmp_Construct);\par
3290     \}\par
3291 \par
3292 \par
3327     {\cf18 void} output_Input(std::ifstream* p_File)\par
3328     \{\par
3329         {\cf18 int} tmp_Construct = 0;\par
3330 \par
3331         *p_File >> tmp_Construct;\par
3332 \par
3333         API.output_Input(tmp_Construct);\par
3334     \}\par
3335 \par
3336 \par
3369     {\cf18 void} output_Input_uint(std::ifstream* p_File)\par
3370     \{\par
3371         {\cf18 int} tmp_Construct = 0;\par
3372 \par
3373         *p_File >> tmp_Construct;\par
3374 \par
3375         API.output_Input_uint(tmp_Construct);\par
3376     \}\par
3377 \par
3378 \par
3423     {\cf18 void} output_Output(std::ifstream* p_File)\par
3424     \{\par
3425         {\cf18 int} tmp_Construct = 0;\par
3426 \par
3427         *p_File >> tmp_Construct;\par
3428 \par
3429         API.output_Output(tmp_Construct);\par
3430     \}\par
3431 \par
3432 \par
3476     {\cf18 void} output_Output_uint(std::ifstream* p_File)\par
3477     \{\par
3478         {\cf18 int} tmp_Construct = 0;\par
3479 \par
3480         *p_File >> tmp_Construct;\par
3481 \par
3482         API.output_Output_uint(tmp_Construct);\par
3483     \}\par
3484 \par
3485 \par
3521     {\cf18 void} output_Scaffold_Char(std::ifstream* p_File)\par
3522     \{\par
3523         {\cf18 int} tmp_Construct = 0;\par
3524 \par
3525         *p_File >> tmp_Construct;\par
3526 \par
3527         API.output_Scaffold_Char(tmp_Construct);\par
3528     \}\par
3529 \par
3530 \par
3531 \par
3532 \par
3533 \par
3534     {\cf20 //      ---====================---}\par
3535     {\cf20 //     ---======================---}\par
3536     {\cf20 //    ---========================---}\par
3537     {\cf20 //   ---==========================---}\par
3538     {\cf20 //  ---==   NT4 specific hooks   ==---}\par
3539     {\cf20 //   ---==========================---}\par
3540     {\cf20 //    ---========================---}\par
3541     {\cf20 //     ---======================---}\par
3542     {\cf20 //      ---====================---}\par
3543 \par
3544 \par
3545 \par
3546     {\cf20 //    ---======================================---}\par
3547     {\cf20 //   ---========================================---}\par
3548     {\cf20 //  ---==   Used to register new assemblies.   ==---}\par
3549     {\cf20 //   ---========================================---}\par
3550     {\cf20 //    ---======================================---}\par
3551 \par
3552 \par
3599     {\cf18 int} register_Assembly(std::ifstream* p_File)\par
3600     \{\par
3601         std::cout << {\cf22 "\\n\\n __COMMAND__| register_assembly |"};\par
3602 \par
3603         {\cf20 //int add_Assembly(std::string p_Assembly_Name)}\par
3604 \par
3605         std::string tmp_Construct_Type = {\cf22 ""};\par
3606 \par
3607         *p_File >> tmp_Construct_Type;\par
3608 \par
3609         std::string tmp_Construct_Name = {\cf22 ""};\par
3610 \par
3611         *p_File >> tmp_Construct_Name;\par
3612 \par
3613         {\cf19 return} API.register_Assembly(tmp_Construct_Type, tmp_Construct_Name);\par
3614     \}\par
3615 \par
3616 \par
3617 \par
3618     {\cf20 //    ---=====================---}\par
3619     {\cf20 //   ---=======================---}\par
3620     {\cf20 //  ---==   Input handling.   ==---}\par
3621     {\cf20 //   ---=======================---}\par
3622     {\cf20 //    ---=====================---}\par
3623 \par
3676     {\cf18 int} load_Input(std::ifstream* p_File)\par
3677     \{\par
3678         std::cout << {\cf22 "\\n| load_Input |"};\par
3679 \par
3680         {\cf20 //Outputs the input for the Assembly.}\par
3681         {\cf20 //output_Input(int p_Assembly)}\par
3682 \par
3683         {\cf18 int} tmp_Construct = 0;\par
3684 \par
3685         *p_File >> tmp_Construct;\par
3686 \par
3687         {\cf19 return} API.load_Input(tmp_Construct);\par
3688     \}\par
3689 \par
3735     {\cf18 int} load_Input_uint(std::ifstream* p_File)\par
3736     \{\par
3737         std::cout << {\cf22 "\\n| load_Input_uint |"};\par
3738 \par
3739         {\cf18 int} tmp_Construct = 0;\par
3740 \par
3741         *p_File >> tmp_Construct;\par
3742 \par
3743         {\cf19 return} API.load_Input_uint(tmp_Construct);\par
3744     \}\par
3745 \par
3746 \par
3747     {\cf20 //    ---==========================================================================---}\par
3748     {\cf20 //   ---============================================================================---}\par
3749     {\cf20 //  ---==   Different ways of gathering nodes, individually, and the entire set.   ==---}\par
3750     {\cf20 //   ---============================================================================---}\par
3751     {\cf20 //    ---==========================================================================---}\par
3752 \par
3832     {\cf18 int} gather_Given_Node(std::ifstream* p_File)\par
3833     \{\par
3834         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_given_node |"};\par
3835 \par
3836         {\cf18 int} tmp_Construct = 0;\par
3837 \par
3838         *p_File >> tmp_Construct;\par
3839 \par
3840         {\cf18 int} tmp_NID = 0;\par
3841 \par
3842         *p_File >> tmp_NID;\par
3843 \par
3844         API.gather_Given_Node(tmp_Construct, tmp_NID);\par
3845 \par
3846         {\cf19 return} 1;\par
3847     \}\par
3848 \par
3849 \par
3954     {\cf18 int} gather_Given_Node_uint(std::ifstream* p_File)\par
3955     \{\par
3956         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_Given_Node_uint |"};\par
3957 \par
3958         {\cf18 int} tmp_Construct = 0;\par
3959 \par
3960         *p_File >> tmp_Construct;\par
3961 \par
3962         {\cf18 int} tmp_NID = 0;\par
3963 \par
3964         *p_File >> tmp_NID;\par
3965 \par
3966         API.gather_Given_Node_uint(tmp_Construct, tmp_NID);\par
3967 \par
3968         {\cf19 return} 1;\par
3969     \}\par
3970 \par
4014     {\cf18 int} gather_All_Nodes(std::ifstream* p_File)\par
4015     \{\par
4016         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_all_nodes |"};\par
4017 \par
4018         {\cf18 int} tmp_Construct = 0;\par
4019 \par
4020         *p_File >> tmp_Construct;\par
4021 \par
4022         API.gather_All_Nodes(tmp_Construct);\par
4023 \par
4024         {\cf19 return} 1;\par
4025     \}\par
4026 \par
4027 \par
4068     {\cf18 int} gather_All_Nodes_uint(std::ifstream* p_File)\par
4069     \{\par
4070         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_all_nodes_uint |"};\par
4071 \par
4072         {\cf18 int} tmp_Construct = 0;\par
4073 \par
4074         *p_File >> tmp_Construct;\par
4075 \par
4076         API.gather_All_Nodes_uint(tmp_Construct);\par
4077 \par
4078         {\cf19 return} 1;\par
4079     \}\par
4080 \par
4081 \par
4082     {\cf20 //    ---==================================================================---}\par
4083     {\cf20 //   ---====================================================================---}\par
4084     {\cf20 //  ---==   The output of a given assembly is read into the output file.   ==---}\par
4085     {\cf20 //   ---====================================================================---}\par
4086     {\cf20 //    ---==================================================================---}\par
4087 \par
4088     \par
4139     {\cf18 int} gather_Output(std::ifstream* p_File)\par
4140     \{\par
4141         std::cout << {\cf22 "\\n| gather_Output |"};\par
4142 \par
4143         {\cf18 int} tmp_Construct = 0;\par
4144 \par
4145         *p_File >> tmp_Construct;\par
4146 \par
4147         std::cout << {\cf22 " "} << tmp_Construct << {\cf22 " |"};\par
4148 \par
4149         API.gather_Output(tmp_Construct);\par
4150 \par
4151         {\cf20 //Neuralman.set_Input_1D_string(tmp_Construct, tmp_In_Full);}\par
4152 \par
4153         {\cf19 return} 1;\par
4154     \}\par
4155 \par
4206     {\cf18 int} gather_Output_uint(std::ifstream* p_File)\par
4207     \{\par
4208         std::cout << {\cf22 "\\n| gather_Output_uint |"};\par
4209 \par
4210         {\cf18 int} tmp_Construct = 0;\par
4211 \par
4212         *p_File >> tmp_Construct;\par
4213 \par
4214         std::cout << {\cf22 " "} << tmp_Construct << {\cf22 " |"};\par
4215 \par
4216         API.gather_Output_uint(tmp_Construct);\par
4217 \par
4218         {\cf20 //Neuralman.set_Input_1D_string(tmp_Construct, tmp_In_Full);}\par
4219 \par
4220         {\cf19 return} 1;\par
4221     \}\par
4222 \par
4223 \par
4224     {\cf20 //    ---=============================---}\par
4225     {\cf20 //   ---===============================---}\par
4226     {\cf20 //  ---==   Treetop node gathering.   ==---}\par
4227     {\cf20 //   ---===============================---}\par
4228     {\cf20 //    ---=============================---}\par
4229 \par
4267     {\cf18 int} gather_Treetop_Node(std::ifstream* p_File)\par
4268     \{\par
4269         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_treetop_node |"};\par
4270 \par
4271         {\cf18 int} tmp_Construct = 0;\par
4272 \par
4273         *p_File >> tmp_Construct;\par
4274 \par
4275         {\cf20 //Gathers the treetop node.}\par
4276         API.gather_Treetop_Node(tmp_Construct);\par
4277 \par
4278         {\cf19 return} 1;\par
4279     \}\par
4280 \par
4318     {\cf18 int} gather_Treetop_Node_uint(std::ifstream* p_File)\par
4319     \{\par
4320         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_treetop_node_uint |"};\par
4321 \par
4322         {\cf18 int} tmp_Construct = 0;\par
4323 \par
4324         *p_File >> tmp_Construct;\par
4325 \par
4326         API.gather_Treetop_Node_uint(tmp_Construct);\par
4327 \par
4328         {\cf19 return} 1;\par
4329     \}\par
4330 \par
4446     {\cf18 int} gather_Treetop_NID(std::ifstream* p_File)\par
4447     \{\par
4448         std::cout << {\cf22 "\\n\\n __COMMAND__| gather_Treetop_NID |"};\par
4449 \par
4450         {\cf18 int} tmp_Construct = 0;\par
4451 \par
4452         *p_File >> tmp_Construct;\par
4453 \par
4454         {\cf20 //Passes the values to an assembly to encode.}\par
4455         API.gather_Treetop_NID(tmp_Construct);\par
4456 \par
4457         {\cf19 return} 1;\par
4458     \}\par
4459 \par
4460 \par
4461 \par
4462 \par
4463     {\cf20 //    ---======================================================================---}\par
4464     {\cf20 //   ---========================================================================---}\par
4465     {\cf20 //  ---==   Output the assembly input, output, scaffolds, node network, etc.   ==---}\par
4466     {\cf20 //   ---========================================================================---}\par
4467     {\cf20 //    ---======================================================================---}\par
4468 \par
4518     {\cf18 int} output_Node_Network()\par
4519     \{\par
4520         std::cout << {\cf22 "\\n| output_Node_Network |"};\par
4521 \par
4522         {\cf20 //Passes the values to an assembly to encode.}\par
4523         API.output_Node_Network();\par
4524 \par
4525         {\cf19 return} 1;\par
4526     \}\par
4527 \par
4528     {\cf20 //    ---==  output_node  ==---}\par
4575     {\cf18 int} output_Node(std::ifstream* p_File)\par
4576     \{\par
4577         std::cout << {\cf22 "\\n| output_Node |"};\par
4578 \par
4579         {\cf18 int} tmp_Node = 0;\par
4580 \par
4581         *p_File >> tmp_Node;\par
4582 \par
4583         std::cout << {\cf22 " "} << tmp_Node << {\cf22 " |"};\par
4584 \par
4585         API.output_BP_NID(tmp_Node);\par
4586 \par
4587         {\cf19 return} 1;\par
4588     \}\par
4589 \par
4621     {\cf18 int} output_Assemblies()\par
4622     \{\par
4623         std::cout << {\cf22 "\\n| output_Assemblies |"};\par
4624 \par
4625         API.output_Assemblies();\par
4626 \par
4627         {\cf19 return} 1;\par
4628     \}\par
4629 \par
4630 \par
4631 \par
4632     {\cf20 //      ---==================================---}\par
4633     {\cf20 //     ---====================================---}\par
4634     {\cf20 //    ---======================================---}\par
4635     {\cf20 //   ---========================================---}\par
4636     {\cf20 //  ---==   Generic commands for the engine.   ==---}\par
4637     {\cf20 //   ---========================================---}\par
4638     {\cf20 //    ---======================================---}\par
4639     {\cf20 //     ---====================================---}\par
4640     {\cf20 //      ---==================================---}\par
4641 \par
4642     {\cf20 //    ---==  clear_output  ==---}\par
4685     {\cf18 int} clear_Output(std::ifstream* p_File)\par
4686     \{\par
4687         {\cf18 int} tmp_Construct = 0;\par
4688 \par
4689         *p_File >> tmp_Construct;\par
4690 \par
4691         {\cf20 //Gathers the treetop node.}\par
4692         API.clear_Output(tmp_Construct);\par
4693 \par
4694         {\cf19 return} 1;\par
4695     \}\par
4696 \par
4741     {\cf18 int} output_Newline(std::ifstream* p_File)\par
4742     \{\par
4743         {\cf18 int} tmp_Construct = 0;\par
4744 \par
4745         *p_File >> tmp_Construct;\par
4746 \par
4747         {\cf20 //Gathers the treetop node.}\par
4748         API.output_Newline(tmp_Construct);\par
4749 \par
4750         {\cf19 return} 1;\par
4751     \}\par
4752 \par
4753 \par
4754     {\cf18 void} save(std::ifstream* p_File)\par
4755     \{\par
4756         std::cout << {\cf22 "\\n| save |"};\par
4757 \par
4758         std::string tmp_FName;\par
4759 \par
4760         *p_File >> tmp_FName;\par
4761 \par
4762         std::cout << {\cf22 " "} << tmp_FName << {\cf22 " |"};\par
4763 \par
4764         API.save(tmp_FName);\par
4765     \}\par
4766 \par
4767 \par
4768     {\cf18 void} load(std::ifstream* p_File)\par
4769     \{\par
4770         std::cout << {\cf22 "\\n| load |"};\par
4771 \par
4772         std::string tmp_FName;\par
4773 \par
4774         *p_File >> tmp_FName;\par
4775 \par
4776         std::cout << {\cf22 " "} << tmp_FName << {\cf22 " |"};\par
4777 \par
4778         API.load(tmp_FName);\par
4779     \}\par
4780 \par
4781 \par
4800     {\cf18 int} run()\par
4801     \{\par
4802         {\cf18 int} flg_Direction = 1;\par
4803         {\cf18 int} tmp_Distance = -250;\par
4804         {\cf18 int} tmp_MAX = 250;\par
4805 \par
4806         std::string tmp_Message = {\cf22 "______________________________IDLING______________________________"};\par
4807         std::string tmp_Corrupt_Message = {\cf22 ""};\par
4808 \par
4809         flg_Direction = 1;\par
4810         tmp_Distance = 0;\par
4811         {\cf19 while} (1)\par
4812         \{\par
4813             {\cf19 for} ({\cf18 int} cou_Time = 0; cou_Time < 250; cou_Time++)\par
4814             \{\par
4815                 tmp_Distance += flg_Direction;\par
4816 \par
4817                 {\cf19 if} (tmp_Distance >= tmp_MAX) \{ flg_Direction = -1; \}\par
4818                 {\cf19 if} (tmp_Distance <= (tmp_MAX * -1)) \{ flg_Direction = 1; \}\par
4819 \par
4820                 {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (tmp_Message.length() + 9); cou_Index++)\par
4821                 \{\par
4822                     std::cout << char(8);\par
4823                 \}\par
4824 \par
4825                 tmp_Corrupt_Message = tmp_Message;\par
4826 \par
4827                 {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < tmp_Distance; cou_Index++)\par
4828                 \{\par
4829                     tmp_Corrupt_Message[rand() % tmp_Message.length()] = char((std::rand() % 32) + 32);\par
4830                 \}\par
4831 \par
4832                 std::cout << {\cf22 "STANDBY["} << tmp_Corrupt_Message << {\cf22 "]"};\par
4833             \}\par
4834 \par
4835             {\cf18 int} tmp_Result = check_Control_Panel_Flag();\par
4836 \par
4837             {\cf20 //Check the control panel for an update}\par
4838             {\cf19 if} (tmp_Result)\par
4839             \{\par
4840                 {\cf20 //std::cout << "\\n ~~~Calling control interpreter:";}\par
4841 \par
4842                 {\cf19 if} (execute_Control_Panel_Buffer() == -1)\par
4843                 \{\par
4844                     {\cf19 return} 1;\par
4845                 \}\par
4846 \par
4847                 std::cout << {\cf22 "\\n\\n    (o.O)"};\par
4848 \par
4849                 std::cout << tmp_Message;\par
4850 \par
4851             \}\par
4852 \par
4853             Tick++;\par
4854         \}\par
4855     \}\par
4856 \};\par
4857 \par
4858 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Fractal_Tree.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Fractal_Tree.h}
{\xe \v include/NT4/c_Fractal_Tree.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 \par
3 \par
4 {\cf20 /*}\par
5 {\cf20         When I was building the networks I ran into the problem of searching them for existing state nodes. A state}\par
6 {\cf20     node is the node that associates an input with a node. State nodes allows for storing information in the networks and}\par
7 {\cf20     subsequently retrieving information from them. With the higher networks that used node IDs (NAdd)s from the lower}\par
8 {\cf20     constructs this became an issue because the number of unique nodes input into the network could get into the millions.}\par
9 {\cf20         In building a network you have to first take an input and search the network to see if that state was already}\par
10 {\cf20     associated with a node. Originally this was done with binary trees. The millions of unique inputs into these binary}\par
11 {\cf20     trees caused long search times. When it came to reading the nodes in there was another issue with the NAdds being}\par
12 {\cf20     sequential leading to extremely long branches in the binary tree that stored almost all of the nodes. This led to}\par
13 {\cf20     stack corruption with recusive searches.}\par
14 {\cf20         The first thing done was changing the recursive searches to an iterative one. This solved the issue of stack}\par
15 {\cf20     corruption but did nothing to solve the long search times. So then an optimization function was created which}\par
16 {\cf20     redistributed the nodes evenly along the branches. This function helped but did not fix the issue as the optimization}\par
17 {\cf20     had to be done frequently and was costly in and of itself.}\par
18 {\cf20         In the end I used a trinary tree combined with bit shifting the query. This allowed for a tree that has branches}\par
19 {\cf20     with fixed lengths. With the branches not getting excessive it does not run into the problem of stack corruptions}\par
20 {\cf20     even with millions of entries.}\par
21 {\cf20 */}\par
22 \par
23 \par
24 {\cf20 //This class forms the basic node on which the fractal tree is built.}\par
25 {\cf17 class }c_Fractal_Node\par
26 \{\par
27     {\cf17 friend} {\cf17 class }c_Fractal_Tree;\par
28 {\cf17 private}:\par
29 \par
30     {\cf20 //Legs of the node.}\par
31     c_Fractal_Node* Right;\par
32     c_Fractal_Node* Center;\par
33     c_Fractal_Node* Left;\par
34 \par
35 {\cf17 public}:\par
36 \par
37     {\cf20 //This stores the state||node ID}\par
38     uint64_t Data;\par
39 \par
40     {\cf20 //Pointer to the actual node.}\par
41     c_Node* NAdd;\par
42 \par
43     c_Fractal_Node()\par
44     \{\par
45         Right = NULL;\par
46         Center = NULL;\par
47         Left = NULL;\par
48         Data = 0;\par
49         NAdd = NULL;\par
50     \}\par
51 \par
52     ~c_Fractal_Node()\par
53     \{\par
54         NAdd = NULL;\par
55         {\cf19 if} (Right != NULL) \{ {\cf17 delete} Right; Right = NULL; \}\par
56         {\cf19 if} (Center != NULL) \{ {\cf17 delete} Center; Center = NULL; \}\par
57         {\cf19 if} (Left != NULL) \{ {\cf17 delete} Left; Left = NULL; \}\par
58     \}\par
59 \par
60 \};\par
61 \par
62 {\cf20 //The fractal state tree is a trinary tree that uses a bitshifted input to dtermine which nodes to assign.}\par
63 {\cf17 class }c_Fractal_Tree\par
64 \{\par
65 {\cf17 private}:\par
66 \par
67 \par
68 {\cf17 public}:\par
69 \par
70     {\cf20 //The root node.}\par
71     c_Fractal_Node* Root;\par
72 \par
73     {\cf20 //the current node that will allow referencing outside of the search function.}\par
74     c_Fractal_Node** Current;\par
75 \par
76     {\cf20 //the flag that set when a node is found already set}\par
77     {\cf18 bool} flg_Foundit;\par
78 \par
79     {\cf20 //Holds the bitshifted data to compare to the nodes data.}\par
80     uint64_t tmp_Data;\par
81 \par
82     {\cf20 //This is used for saving and loading, tracks the number of nodes in the tree so the system knows how many nodes to expect during loading.}\par
83     {\cf18 int} State_Count;\par
84 \par
85     c_Fractal_Tree()\par
86     \{\par
87         Root = NULL;\par
88         Current = NULL;\par
89         flg_Foundit = {\cf17 false};\par
90 \par
91         State_Count = 0;\par
92 \par
93         tmp_Data = 0;\par
94     \}\par
95 \par
96     ~c_Fractal_Tree()\par
97     \{\par
98         {\cf19 if} (Root != NULL) \{ {\cf17 delete} Root; Root = NULL; \}\par
99     \}\par
100     \par
101     {\cf20 //Resets the tree.}\par
102     {\cf18 void} reset()\par
103     \{\par
104         {\cf19 if} (Root != NULL) \{ {\cf17 delete} Root; Root = NULL; \}\par
105     \}\par
106 \par
107     {\cf20 //Search for a state.}\par
108     {\cf18 void} search(uint64_t p_Data)\par
109     \{\par
110         {\cf20 //Set the flag to indicate that the data was not found.}\par
111         flg_Foundit = {\cf17 false};\par
112 \par
113         tmp_Data = 0;\par
114 \par
115         {\cf20 //The data is 64 bits deep. So start the shift at 63.}\par
116         query_Node(Root, p_Data, 63);\par
117     \}\par
118 \par
119     {\cf20 //Queries a node. }\par
120     {\cf20 //p_Node is the node to check against the query value.}\par
121     {\cf20 //p_Data is the data that is checked against.}\par
122     {\cf20 //p_Shift is the number of bits to extract for comparison.}\par
123     {\cf18 int} query_Node(c_Fractal_Node*& p_Node, uint64_t p_Data, {\cf18 int} p_Shift)\par
124     \{\par
125         {\cf20 //Shift the data to get the temporary value.}\par
126         tmp_Data = p_Data >> p_Shift;\par
127 \par
128         {\cf20 //If the passed node is NULL create it.}\par
129         {\cf19 if} (p_Node == NULL)\par
130         \{\par
131             p_Node = {\cf17 new} c_Fractal_Node;\par
132             p_Node->Right = NULL;\par
133             p_Node->Center = NULL;\par
134             p_Node->Left = NULL;\par
135             p_Node->NAdd = NULL;\par
136 \par
137             {\cf19 if} (p_Shift >= 1)\par
138             \{\par
139                 {\cf20 //If the query is not at the end set the data to tmp_Data rather than p_Data.}\par
140                 p_Node->Data = tmp_Data;\par
141             \}\par
142             {\cf19 else}\par
143             \{\par
144                 {\cf20 //If the query has reached the end set the data to the full query data.}\par
145                 p_Node->Data = p_Data;\par
146 \par
147                 {\cf20 //Set the current node to the newly created node.}\par
148                 Current = &p_Node;\par
149 \par
150                 {\cf20 //The node was not found, one had to be created.}\par
151                 flg_Foundit = {\cf17 false};\par
152 \par
153                 {\cf20 //We have registered a new leaf.}\par
154                 State_Count++;\par
155 \par
156                 {\cf20 //Return as we are done here.}\par
157                 {\cf19 return} 0;\par
158             \}\par
159         \}\par
160 \par
161         {\cf20 //If the current data matches the tmp data then another depth is explored.}\par
162         {\cf19 if} (p_Node->Data == tmp_Data && p_Shift >= 1)\par
163         \{\par
164             {\cf19 if} (p_Shift == 1) \{ query_Node(p_Node->Center, p_Data, 0); {\cf19 return} 0; \}\par
165             query_Node(p_Node->Center, p_Data, (p_Shift - 2));\par
166             {\cf19 return} 0;\par
167         \}\par
168 \par
169         {\cf20 //If the node data matches the given data exactly the node has been found.}\par
170         {\cf20 //Set Current to the current node.}\par
171         {\cf20 //Set the flg_Foundit to true as the node was found without creating it.}\par
172         {\cf19 if} (p_Node->Data == p_Data)\par
173         \{\par
174             Current = &p_Node;\par
175             {\cf19 if} (p_Node->NAdd != NULL) \{ flg_Foundit = {\cf17 true}; \}\par
176             {\cf19 return} 0;\par
177         \}\par
178 \par
179         {\cf20 //If the tmp_Data is less than the nodes data then look on the left leg.}\par
180         {\cf19 if} (tmp_Data < p_Node->Data)\par
181         \{\par
182             query_Node(p_Node->Left, p_Data, p_Shift);\par
183             {\cf19 return} 0;\par
184         \}\par
185 \par
186         {\cf20 //If the tmp_Data is more than the nodes data then look on the right leg.}\par
187         {\cf19 if} (tmp_Data > p_Node->Data)\par
188         \{\par
189             query_Node(p_Node->Right, p_Data, p_Shift);\par
190             {\cf19 return} 0;\par
191         \}\par
192         {\cf19 return} 0;\par
193     \}\par
194 \par
195     {\cf20 //Outputs the tree starting at the root node.}\par
196     {\cf18 void} output_Tree()\par
197     \{\par
198         output_Node(Root, 0);\par
199     \}\par
200 \par
201     {\cf20 //Outputs a given node. p_Tab determines an offset during output.}\par
202     {\cf18 void} output_Node(c_Fractal_Node * &p_Node, {\cf18 int} p_Tab)\par
203     \{\par
204         {\cf19 if} (p_Node == NULL) \{ {\cf19 return}; \}\par
205         output_Node(p_Node->Left, (p_Tab));\par
206         std::cout << {\cf22 "\\n"};\par
207         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Tab; cou_Index++)\par
208         \{\par
209             std::cout << {\cf22 "  "};\par
210         \}\par
211         std::cout << (p_Node->Data) << {\cf22 "->"};\par
212         {\cf19 if} (p_Node->NAdd != NULL) \par
213         \{ \par
214             std::cout << p_Node->NAdd; \par
215             std::cout << {\cf22 "\\n"};\par
216             (p_Node->NAdd)->output_Node_Raw();\par
217         \}\par
218         {\cf19 else} \{ std::cout << {\cf22 "NULL"}; \}\par
219         output_Node(p_Node->Center, (p_Tab + 1));\par
220         output_Node(p_Node->Right, (p_Tab));\par
221     \}\par
222 \par
223     {\cf20 //Outputs the tree with the backpropagation from the nodes starting at the root node.}\par
224     {\cf18 void} output_Tree_BP()\par
225     \{\par
226         std::cout << {\cf22 "\\n\\t Fractal Tree Backpropagation Station"};\par
227         output_Node_BP(Root);\par
228     \}\par
229 \par
230     {\cf20 //Outputs a given node and backpropagates the node it is linked to.}\par
231     {\cf18 void} output_Node_BP(c_Fractal_Node * &p_Node)\par
232     \{\par
233         {\cf19 if} (p_Node == NULL) \{ {\cf19 return}; \}\par
234         output_Node_BP(p_Node->Left);\par
235         {\cf19 if} ((p_Node->NAdd) != NULL) \{ std::cout << {\cf22 "\\n\\t"} << (p_Node->Data) << {\cf22 "->"} << (p_Node->NAdd); (p_Node->NAdd)->bp_O(); \}\par
236         output_Node_BP(p_Node->Center);\par
237         output_Node_BP(p_Node->Right);\par
238     \}\par
239 \par
240     {\cf20 //Retrieves the NAdd from a given node.}\par
241     c_Node* get_Node_NAdd(c_Fractal_Node * &p_Node)\par
242     \{\par
243         {\cf19 if} (p_Node != NULL)\par
244         \{\par
245             {\cf19 return} p_Node->NAdd;\par
246         \}\par
247         {\cf19 else} \{\par
248             {\cf19 return} NULL;\par
249         \}\par
250     \}\par
251 \par
252     {\cf20 //Sets a node NAdd.}\par
253     {\cf18 void} set_Node_NAdd(c_Fractal_Node * &p_Node, c_Node * p_NAdd)\par
254     \{\par
255         {\cf19 if} (p_Node != NULL)\par
256         \{\par
257             p_Node->NAdd = p_NAdd;\par
258         \}\par
259     \}\par
260 \par
261     {\cf20 //Sets the current nodes NAdd.}\par
262     c_Node* set_Current_Node_NAdd(c_Node * p_NAdd)\par
263     \{\par
264         set_Node_NAdd(*Current, p_NAdd);\par
265         {\cf19 return} p_NAdd;\par
266     \}\par
267 \par
268     {\cf20 //Gets the current nodes NAdd.}\par
269     c_Node* get_Current_Node_NAdd()\par
270     \{\par
271         {\cf19 return} get_Node_NAdd(*Current);\par
272     \}\par
273 \par
274     {\cf20 //Saves the tree as a list of nodes and the state associated.}\par
275     {\cf18 void} save_Tree(std::ofstream* p_SF)\par
276     \{\par
277         *p_SF << {\cf22 "\\n"} << State_Count;\par
278         save_Tree_Node(Root, p_SF);\par
279     \}\par
280 \par
281     {\cf20 //Outputs a given node and backpropagates the node it is linked to.}\par
282     {\cf18 void} save_Tree_Node(c_Fractal_Node * &p_Node, std::ofstream* p_SF)\par
283     \{\par
284         {\cf19 if} (p_Node == NULL) \{ {\cf19 return}; \}\par
285         save_Tree_Node(p_Node->Left, p_SF);\par
286         \par
287         {\cf19 if} ((p_Node->NAdd) != NULL) \par
288         \{ \par
289             *p_SF << {\cf22 "\\n "} << (p_Node->NAdd)->NID << {\cf22 " "} << (p_Node->NAdd)->State;\par
290         \}\par
291 \par
292         save_Tree_Node(p_Node->Center, p_SF);\par
293         save_Tree_Node(p_Node->Right, p_SF);\par
294     \}\par
295 \par
296 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_IO.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_IO.h}
{\xe \v include/NT4/c_IO.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 \par
3 \par
4 {\cf20 //This class serves as the user interface for the actuator I/O}\par
5 {\cf17 class }c_IO_Set\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Data is stored as an array of uint64_t}\par
10     uint64_t* Data;\par
11 \par
12     {\cf20 //The depth of the data.}\par
13     {\cf18 int} Depth;\par
14 \par
15     c_IO_Set()\par
16     \{\par
17         Data = NULL;\par
18 \par
19         Depth = 0;\par
20     \}\par
21 \par
22     {\cf18 void} set_Depth({\cf18 int} p_Depth)\par
23     \{\par
24         {\cf20 //If Data is NULL then everything else should be as well.}\par
25         {\cf19 if} (Data != NULL)\par
26         \{\par
27             {\cf17 delete}[] Data;\par
28             Data = NULL;\par
29         \}\par
30 \par
31         Depth = p_Depth;\par
32 \par
33         Data = {\cf17 new} uint64_t[Depth];\par
34 \par
35         wipe_Data();\par
36     \}\par
37 \par
38 \par
39     {\cf20 //Reset it if need be.}\par
40     {\cf18 void} reset()\par
41     \{\par
42         {\cf19 if} (Data != NULL)\par
43         \{\par
44             {\cf17 delete}[] Data;\par
45             Data = NULL;\par
46             Depth = 0;\par
47         \}\par
48     \}\par
49 \par
50     {\cf20 //This shifts the output from current to 0.}\par
51     {\cf18 void} wipe_Data()\par
52     \{\par
53         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Depth; cou_Index++)\par
54         \{\par
55             Data[cou_Index] = 0;\par
56         \}\par
57     \}\par
58 \par
59     {\cf20 //Accepts an input and updates the correct index with it}\par
60     {\cf18 void} set_Value(uint64_t p_Value, {\cf18 int} p_Index = -1) {\cf20 //p_Index comes after since it may be 0}\par
61     \{\par
62         {\cf19 if} (p_Index == -1)\par
63         \{\par
64             p_Index = Depth - 1;\par
65         \}\par
66 \par
67         {\cf20 //First get the concrete value.}\par
68         Data[p_Index] = p_Value;\par
69     \}\par
70 \par
71     {\cf20 //Accepts an array, resets the data, then reads the array into the data then sets the depth.}\par
72     {\cf18 void} set_Array_Value(uint64_t* p_Data_Array, {\cf18 int} p_Depth)\par
73     \{\par
74         reset();\par
75 \par
76         {\cf20 //Initialize the wiped input array and copy the data to it from the arguments.}\par
77         Depth = p_Depth;\par
78         Data = {\cf17 new} uint64_t[Depth];\par
79         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Depth; cou_Index++)\par
80         \{\par
81             Data[cou_Index] = p_Data_Array[cou_Index];\par
82         \}\par
83     \}\par
84 \par
85     {\cf20 //Returns the value.}\par
86     uint64_t get_Value({\cf18 int} p_Index = -1)\par
87     \{\par
88         {\cf19 if} (p_Index == -1)\par
89         \{\par
90             p_Index = Depth - 1;\par
91         \}\par
92 \par
93         {\cf19 return} Data[p_Index];\par
94     \}\par
95 \par
96     {\cf20 //This shifts the output from current to 0.}\par
97     {\cf18 void} shift_Data()\par
98     \{\par
99         {\cf20 //Shift each array one index towards [0].}\par
100         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (Depth - 1); cou_Index++)\par
101         \{\par
102             Data[cou_Index] = Data[cou_Index + 1];\par
103         \}\par
104 \par
105         {\cf20 //Set the current to 0.0 in preparation for input.}\par
106         Data[Depth - 1] = 0;\par
107     \}\par
108 \par
109     {\cf20 //Outputs the data}\par
110     {\cf18 void} output()\par
111     \{\par
112         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Depth; cou_Index++)\par
113         \{\par
114             std::cout << {\cf22 "\\n["} << cou_Index << {\cf22 "] Data: "} << Data[cou_Index];\par
115         \}\par
116     \}\par
117 \};\par
118 \par
119 \par
120 \par
121 \par
122 \par
123 {\cf20 //This class serves as the user interface for the actuator I/O}\par
124 {\cf17 class }c_2D_IO_Set\par
125 \{\par
126 {\cf17 public}:\par
127 \par
128     {\cf20 //Data is stored as an array of uint64_t}\par
129     uint64_t** Data;\par
130 \par
131     {\cf20 //The depth of the data.}\par
132     {\cf20 //[0] == x}\par
133     {\cf20 //[1] == y}\par
134     {\cf20 //[] Those are arbitrarily chosen but if most follow them it should be easy to share work.}\par
135     {\cf18 int} Depth[2];\par
136 \par
137     c_2D_IO_Set()\par
138     \{\par
139         Data = NULL;\par
140 \par
141         Depth[0] = 0;\par
142         Depth[1] = 0;\par
143     \}\par
144 \par
145     {\cf18 void} set_Depth({\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth)\par
146     \{\par
147         reset();\par
148 \par
149         Depth[0] = p_X_Depth;\par
150         Depth[1] = p_Y_Depth;\par
151 \par
152         Data = {\cf17 new} uint64_t*[Depth[0]];\par
153 \par
154         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
155         \{\par
156             Data[cou_X] = {\cf17 new} uint64_t [Depth[1]];\par
157 \par
158             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
159             \{\par
160                 Data[cou_X][cou_Y] = 0;\par
161             \}\par
162         \}\par
163     \}\par
164 \par
165 \par
166     {\cf20 //Reset it if need be.}\par
167     {\cf18 void} reset()\par
168     \{\par
169         {\cf20 //If Data is NULL then everything else should be as well.}\par
170         {\cf20 //If Data is not NULL then there should be tiers.}\par
171         {\cf19 if} (Data != NULL)\par
172         \{\par
173             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
174             \{\par
175                 {\cf19 if} (Data[cou_X] != NULL)\par
176                 \{\par
177                     {\cf17 delete}[] Data[cou_X];\par
178                     Data[cou_X] = NULL;\par
179                 \}\par
180             \}\par
181 \par
182             {\cf17 delete}[] Data;\par
183             Data = NULL;\par
184         \}\par
185         Depth[0] = 0;\par
186         Depth[1] = 0;\par
187     \}\par
188 \par
189     {\cf20 //This shifts the output from current to 0.}\par
190     {\cf18 void} wipe_Data()\par
191     \{\par
192         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
193         \{\par
194             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
195             \{\par
196                 Data[cou_X][cou_Y] = 0;\par
197             \}\par
198         \}\par
199 \par
200     \}\par
201 \par
202     {\cf20 //Accepts an input and updates the correct index with it}\par
203     {\cf18 void} set_Value(uint64_t p_Value, {\cf18 int} p_X, {\cf18 int} p_Y) {\cf20 //p_Index comes after since it may be 0}\par
204     \{\par
205         {\cf20 //First get the concrete value.}\par
206         Data[p_X][p_Y] = p_Value;\par
207     \}\par
208 \par
209     {\cf20 //Accepts an array, resets the data, then reads the array into the data then sets the depth.}\par
210     {\cf18 void} set_Array_Value(uint64_t** p_Data_Array, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth)\par
211     \{\par
212         reset();\par
213 \par
214         set_Depth(p_X_Depth, p_Y_Depth);\par
215 \par
216         {\cf20 //Initialize the wiped input array and copy the data to it from the arguments.}\par
217         {\cf19 for} ({\cf18 int} cou_X=0;cou_X<Depth[0];cou_X++)\par
218         \{\par
219             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
220             \{\par
221                 Data[cou_X][cou_Y] = p_Data_Array[cou_X][cou_Y];\par
222             \}\par
223         \}\par
224     \}\par
225 \par
226     {\cf20 //Returns the value.}\par
227     uint64_t get_Value({\cf18 int} p_X, {\cf18 int} p_Y)\par
228     \{\par
229         {\cf19 return} Data[p_X][p_Y];\par
230     \}\par
231 \par
232     {\cf20 //This shifts the output from current to 0 for Chrono.}\par
233     {\cf20 //We only shift the X-axis no matter the dimension. A line inches along, an image scrolls, a cube slides, etc.}\par
234     {\cf18 void} shift_Data()\par
235     \{\par
236         {\cf20 //Shift each array one index towards [0].}\par
237         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (Depth[0] - 1); cou_X++)\par
238         \{\par
239             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
240             \{\par
241                 Data[cou_X][cou_Y] = Data[cou_X + 1][cou_Y];\par
242             \}\par
243         \}\par
244         {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
245         \{\par
246             Data[Depth[0] - 1][cou_Y] = 0;\par
247         \}\par
248     \}\par
249 \par
250     {\cf20 //Outputs the data}\par
251     {\cf18 void} output()\par
252     \{\par
253         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
254         \{\par
255             std::cout << {\cf22 "\\n"};\par
256             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
257             \{\par
258                 std::cout << {\cf22 " ["} << cou_X << {\cf22 "]["} << cou_Y << {\cf22 "]: "} << Data[cou_X][cou_Y];\par
259             \}\par
260         \}\par
261     \}\par
262 \};\par
263 \par
264 \par
265 \par
266 \par
267 \par
268 \par
269 \par
270 \par
271 \par
272 \par
273 {\cf20 //This class serves as the user interface for the actuator I/O}\par
274 {\cf17 class }c_3D_IO_Set\par
275 \{\par
276 {\cf17 public}:\par
277 \par
278     {\cf20 //Data is stored as an array of uint64_t}\par
279     uint64_t*** Data;\par
280 \par
281     {\cf20 //The depth of the data.}\par
282     {\cf20 //[0] == x}\par
283     {\cf20 //[1] == y}\par
284     {\cf20 //[2] == z}\par
285     {\cf20 //[] Those are arbitrarily chosen but if most follow them it should be easy to share work.}\par
286     {\cf18 int} Depth[3];\par
287 \par
288     c_3D_IO_Set()\par
289     \{\par
290         Data = NULL;\par
291 \par
292         Depth[0] = 0;\par
293         Depth[1] = 0;\par
294         Depth[2] = 0;\par
295     \}\par
296 \par
297     {\cf18 void} set_Depth({\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, {\cf18 int} p_Z_Depth)\par
298     \{\par
299         reset();\par
300 \par
301         Depth[0] = p_X_Depth;\par
302         Depth[1] = p_Y_Depth;\par
303         Depth[2] = p_Z_Depth;\par
304 \par
305         Data = {\cf17 new} uint64_t ** [Depth[0]];\par
306 \par
307         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
308         \{\par
309             Data[cou_X] = {\cf17 new} uint64_t * [Depth[1]];\par
310 \par
311             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
312             \{\par
313                 Data[cou_X][cou_Y] = {\cf17 new} uint64_t [Depth[2]];\par
314 \par
315                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < Depth[2]; cou_Z++)\par
316                 \{\par
317                     Data[cou_X][cou_Y][cou_Z] = 0;\par
318                 \}\par
319             \}\par
320         \}\par
321     \}\par
322 \par
323 \par
324     {\cf20 //Reset it if need be.}\par
325     {\cf18 void} reset()\par
326     \{\par
327         {\cf20 //If Data is NULL then everything else should be as well.}\par
328         {\cf20 //If Data is not NULL then there should be tiers.}\par
329         {\cf19 if} (Data != NULL)\par
330         \{\par
331             {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
332             \{\par
333                 {\cf19 if} (Data[cou_X] != NULL)\par
334                 \{\par
335                     {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
336                     \{\par
337                         {\cf19 if} (Data[cou_X][cou_Y] != NULL)\par
338                         \{\par
339                             {\cf17 delete}[] Data[cou_X][cou_Y];\par
340                             Data[cou_X][cou_Y] = NULL;\par
341                         \}\par
342                     \}\par
343                     {\cf17 delete}[] Data[cou_X];\par
344                     Data[cou_X] = NULL;\par
345                 \}\par
346             \}\par
347 \par
348             {\cf17 delete}[] Data;\par
349             Data = NULL;\par
350         \}\par
351         Depth[0] = 0;\par
352         Depth[1] = 0;\par
353         Depth[2] = 0;\par
354     \}\par
355 \par
356     {\cf20 //This shifts the output from current to 0.}\par
357     {\cf18 void} wipe_Data()\par
358     \{\par
359         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
360         \{\par
361             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
362             \{\par
363                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < Depth[2]; cou_Z++)\par
364                 \{\par
365                     Data[cou_X][cou_Y][cou_Z] = 0;\par
366                 \}\par
367             \}\par
368         \}\par
369 \par
370     \}\par
371 \par
372     {\cf20 //Accepts an input and updates the correct index with it}\par
373     {\cf18 void} set_Value(uint64_t p_Value, {\cf18 int} p_X, {\cf18 int} p_Y, {\cf18 int} p_Z)\par
374     \{\par
375         {\cf20 //First get the concrete value.}\par
376         Data[p_X][p_Y][p_Z] = p_Value;\par
377     \}\par
378 \par
379     {\cf20 //Accepts an array, resets the data, then reads the array into the data then sets the depth.}\par
380     {\cf18 void} set_Array_Value(uint64_t*** p_Data_Array, {\cf18 int} p_X_Depth, {\cf18 int} p_Y_Depth, {\cf18 int} p_Z_Depth)\par
381     \{\par
382         reset();\par
383 \par
384         set_Depth(p_X_Depth, p_Y_Depth, p_Z_Depth);\par
385 \par
386         {\cf20 //Initialize the wiped input array and copy the data to it from the arguments.}\par
387         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
388         \{\par
389             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
390             \{\par
391                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < Depth[1]; cou_Z++)\par
392                 \{\par
393                     Data[cou_X][cou_Y][cou_Z] = p_Data_Array[cou_X][cou_Y][cou_Z];\par
394                 \}\par
395             \}\par
396         \}\par
397     \}\par
398 \par
399     {\cf20 //Returns the value.}\par
400     uint64_t get_Value({\cf18 int} p_X, {\cf18 int} p_Y, {\cf18 int} p_Z)\par
401     \{\par
402         {\cf19 return} Data[p_X][p_Y][p_Z];\par
403     \}\par
404 \par
405     {\cf20 //This shifts the output from current to 0 for Chrono.}\par
406     {\cf20 //We only shift the X-axis no matter the dimension. A line inches along, an image scrolls, a cube slides, etc.}\par
407     {\cf18 void} shift_Data()\par
408     \{\par
409         {\cf20 //Shift each array one index towards [0].}\par
410         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < (Depth[0] - 1); cou_X++)\par
411         \{\par
412             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
413             \{\par
414                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < Depth[2]; cou_Z++)\par
415                 \{\par
416                     Data[cou_X][cou_Y][cou_Z] = Data[cou_X + 1][cou_Y][cou_Z];\par
417                 \}\par
418             \}\par
419         \}\par
420         {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
421         \{\par
422             {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < Depth[2]; cou_Z++)\par
423             \{\par
424                 Data[Depth[0] - 1][cou_Y][cou_Z] = 0;\par
425             \}\par
426         \}\par
427     \}\par
428 \par
429     {\cf20 //Outputs the data}\par
430     {\cf18 void} output()\par
431     \{\par
432         {\cf19 for} ({\cf18 int} cou_X = 0; cou_X < Depth[0]; cou_X++)\par
433         \{\par
434             std::cout << {\cf22 "\\n"};\par
435             {\cf19 for} ({\cf18 int} cou_Y = 0; cou_Y < Depth[1]; cou_Y++)\par
436             \{\par
437                 std::cout << {\cf22 "\\n"};\par
438                 {\cf19 for} ({\cf18 int} cou_Z = 0; cou_Z < Depth[2]; cou_Z++)\par
439                 \{\par
440                     std::cout << {\cf22 " ["} << cou_X << {\cf22 "]["} << cou_Y << {\cf22 "]["} << cou_Z << {\cf22 "]: "} << Data[cou_X][cou_Y][cou_Z];\par
441                 \}\par
442             \}\par
443         \}\par
444     \}\par
445 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Linked_List_Handler.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Linked_List_Handler.h}
{\xe \v include/NT4/c_Linked_List_Handler.h}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //This is the linked list for the buffer.}\par
3 {\cf17 class }c_Linked_List\par
4 \{\par
5 {\cf17 public}:\par
6 \par
7     {\cf20 //The next node in the chain.}\par
8     c_Linked_List* Next;\par
9     c_Linked_List* Previous;\par
10     uint64_t Quanta;\par
11 \par
12     c_Linked_List()\par
13     \{\par
14         Next = NULL;\par
15         Previous = NULL;\par
16         Quanta = 0;\par
17     \}\par
18 \par
19     ~c_Linked_List()\par
20     \{\par
21         Quanta = 0;\par
22         {\cf20 //delete Next; Handled by the handler.}\par
23     \}\par
24 \par
25     {\cf20 //Outputs the linked list.}\par
26     {\cf20 //-- !WARNING! RECURSIVE FUNCTION ON LINKED LIST! CALLING THIS WILL CAUSE STACK CORRUPTION ERROR WITH ENOUGH NODES!}\par
27     {\cf18 void} output_LL()\par
28     \{\par
29         {\cf20 //*std::cout << " [";}\par
30         std::cout << {\cf22 " $"} << Quanta << {\cf22 "]  "};\par
31         {\cf19 if} (Next != NULL) \{ Next->output_LL(); \}\par
32     \}\par
33 \};\par
34 \par
35 {\cf20 //This handles the linked list creation and deletion so that recursive destruction does not crash the stack.}\par
36 {\cf17 class }c_Linked_List_Handler\par
37 \{\par
38 {\cf17 public}:\par
39 \par
40     {\cf20 //The nodes in the linked list.}\par
41     c_Linked_List* Root;\par
42     c_Linked_List** Current_LL;\par
43     {\cf18 int} Depth;\par
44 \par
45     c_Linked_List_Handler()\par
46     \{\par
47         Root = NULL;\par
48         Current_LL = &Root;\par
49         Depth = 0;\par
50     \}\par
51 \par
52     ~c_Linked_List_Handler()\par
53     \{\par
54         reset();\par
55     \}\par
56 \par
57     {\cf20 //Init}\par
58     {\cf18 void} init()\par
59     \{\par
60         Root = NULL;\par
61         Current_LL = &Root;\par
62         Depth = 0;\par
63     \}\par
64 \par
65     {\cf20 //Adds a node with the quanta of data passed.}\par
66     c_Linked_List* new_LL(uint64_t p_Quanta)\par
67     \{\par
68         c_Linked_List* tmp_LL = NULL;\par
69 \par
70         *Current_LL = {\cf17 new} c_Linked_List;\par
71 \par
72         (*Current_LL)->Quanta = p_Quanta;\par
73 \par
74         tmp_LL = *Current_LL;\par
75 \par
76         (*Current_LL)->Previous = tmp_LL;\par
77 \par
78         Current_LL = &(*Current_LL)->Next;\par
79 \par
80         Depth++;\par
81 \par
82         {\cf19 return} tmp_LL;\par
83     \}\par
84 \par
85     {\cf20 //Resets the linked list.}\par
86     {\cf18 void} reset()\par
87     \{\par
88         c_Linked_List* tmp_LL = Root;\par
89         Root = NULL;\par
90         c_Linked_List* tmp_LL_Next = NULL;\par
91 \par
92         {\cf19 while} (tmp_LL != NULL)\par
93         \{\par
94             tmp_LL_Next = tmp_LL->Next;\par
95             tmp_LL->Next = NULL;\par
96             tmp_LL->Previous = NULL;\par
97             {\cf17 delete} tmp_LL;\par
98             tmp_LL = NULL;\par
99             tmp_LL = tmp_LL_Next;\par
100         \}\par
101 \par
102         {\cf19 if} (Root != NULL) \{ {\cf17 delete} Root; \}\par
103         Root = NULL;\par
104         Current_LL = &Root;\par
105 \par
106         Depth = 0;\par
107     \}\par
108 \par
109     {\cf20 //Outputs the linked list.}\par
110     {\cf18 void} output()\par
111     \{\par
112         c_Linked_List* tmp_LL = Root;\par
113 \par
114         c_Linked_List* tmp_LL_Next = NULL;\par
115 \par
116         std::cout << {\cf22 "\\n Output Linked List:"};\par
117 \par
118         std::cout << {\cf22 " Depth: "} << Depth;\par
119         {\cf19 while} (tmp_LL != NULL)\par
120         \{\par
121             tmp_LL_Next = tmp_LL->Next;\par
122 \par
123             {\cf20 //Hmm, might change the tmp_LL->NID to a different name so it isn't NID->NID}\par
124             std::cout << {\cf22 "\\n   -"};\par
125             \par
126             std::cout << tmp_LL->Quanta;\par
127 \par
128             std::cout << {\cf22 "\\n"};\par
129 \par
130 \par
131             tmp_LL = tmp_LL_Next;\par
132         \}\par
133     \}\par
134 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Node.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Node.h}
{\xe \v include/NT4/c_Node.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //The state is stored as uint64_t so you will need to typecast to appropriate datatype.}\par
2 \par
3 {\cf20 //Quick n dirty to output the double for the node states}\par
4 {\cf17 union }u_Tmp\par
5 \{\par
6     {\cf18 double} D;\par
7     uint64_t U;\par
8 \};\par
9 \par
10 {\cf17 class }c_Node\par
11 \{\par
12 {\cf17 public}:\par
13 \par
14     {\cf20 //The Node ID, used because the raw address may change upon saving/loading and external hooks need a solid grasp.}\par
15     uint64_t NID;\par
16 \par
17     {\cf20 //The next node in the network.}\par
18     c_Node* Next;\par
19 \par
20     {\cf20 //Axons and the counters. Axons[0][] are the ones connected to the first leg, used in finding UTN}\par
21     {\cf20 //Axons are organized by the dendritic index they are connected to, if they connect to leg [0] then they are an axon on hillock [0].}\par
22     c_Node*** Axons;\par
23     {\cf18 int}* Axon_Count;\par
24     {\cf18 int} Axon_Hillock_Count;\par
25 \par
26     {\cf20 //Dendrites, lower connections, leg order is of highest importance.}\par
27     c_Node** Dendrites;\par
28     {\cf18 int} Dendrite_Count;\par
29 \par
30     {\cf20 //The reinforcement counter.}\par
31     {\cf20 //A filter function will be built into the c_Neural_Network that applies:}\par
32     {\cf20 // exponential growth to reduce new trace impact, one offs and flukes get filtered}\par
33     {\cf20 // Sigmoid curve for the top end to prevent extreme bias in highly reinforced nodes.}\par
34     {\cf18 double} RC;\par
35 \par
36     {\cf20 //The current charge of the node.}\par
37     {\cf18 double} Current_Charge;\par
38 \par
39     {\cf20 //The quanta bound to the node.}\par
40     uint64_t State;\par
41 \par
42     {\cf20 //This tracks the node type.}\par
43     {\cf20 //(0: NULL), (1: State), (2: Branch), (3: Treetop), (4: State Treetop)}\par
44     {\cf18 short} {\cf18 int} Type;\par
45 \par
46     c_Node()\par
47     \{\par
48         NID = 0;\par
49 \par
50         {\cf20 //The next node.}\par
51         Next = NULL;\par
52 \par
53         {\cf20 //Axons and their counters.}\par
54 \par
55         Axons = NULL;\par
56         Axon_Count = 0;\par
57         Axon_Hillock_Count = 0;\par
58 \par
59         {\cf20 //Dendrites.}\par
60         Dendrites = NULL;\par
61         Dendrite_Count = 0;\par
62 \par
63         {\cf20 //Reinforcement Counters.}\par
64         RC = 1.0;\par
65 \par
66         {\cf20 //The nodes state.}\par
67         State = 0;\par
68 \par
69         {\cf20 //No charge atm.}\par
70         Current_Charge = 0.0;\par
71 \par
72         {\cf20 //The type is 0 to start with.}\par
73         Type = 0;\par
74     \}\par
75 \par
76     {\cf20 //(0: State), (1: Branch), (2: Treetop), (3: State/Treetop)}\par
77     {\cf18 void} set_Type({\cf18 int} p_Type)\par
78     \{\par
79         Type = p_Type;\par
80     \}\par
81 \par
82     {\cf18 void} resize_Axon_Hillocks({\cf18 int} p_Count)\par
83     \{\par
84         c_Node*** tmp_Axons;\par
85         {\cf18 int}* tmp_Axon_Count;\par
86         tmp_Axons = {\cf17 new} c_Node ** [Axon_Hillock_Count];\par
87         tmp_Axon_Count = {\cf17 new} {\cf18 int} [Axon_Hillock_Count];\par
88 \par
89         {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < Axon_Hillock_Count; cou_A++)\par
90         \{\par
91             tmp_Axons[cou_A] = Axons[cou_A];\par
92             Axons[cou_A] = NULL;\par
93 \par
94             tmp_Axon_Count[cou_A] = Axon_Count[cou_A];\par
95         \}\par
96 \par
97         {\cf17 delete}[] Axons;\par
98         Axons = NULL;\par
99 \par
100         {\cf17 delete}[] Axon_Count;\par
101         Axon_Count = NULL;\par
102 \par
103         Axons = {\cf17 new} c_Node ** [p_Count];\par
104         Axon_Count = {\cf17 new} {\cf18 int} [p_Count];\par
105 \par
106         {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < Axon_Hillock_Count; cou_A++)\par
107         \{\par
108             Axons[cou_A] = tmp_Axons[cou_A];\par
109             tmp_Axons[cou_A] = NULL;\par
110 \par
111             Axon_Count[cou_A] = tmp_Axon_Count[cou_A];\par
112         \}\par
113 \par
114         {\cf17 delete}[] tmp_Axons;\par
115         tmp_Axons = NULL;\par
116 \par
117         {\cf17 delete}[] tmp_Axon_Count;\par
118         tmp_Axon_Count = NULL;\par
119 \par
120         {\cf19 for} ({\cf18 int} cou_A = Axon_Hillock_Count; cou_A < p_Count; cou_A++)\par
121         \{\par
122             Axons[cou_A] = NULL;\par
123             Axon_Count[cou_A] = 0;\par
124         \}\par
125 \par
126         Axon_Hillock_Count = p_Count;\par
127     \}\par
128 \par
129     {\cf20 //Adds an axon to the axon list at the given index, if the index doesn't exist then exist it with resize_Axon_Hillocks()}\par
130     {\cf18 void} add_Axon_Index(c_Node* p_Axon, {\cf18 int} p_Index)\par
131     \{\par
132         {\cf19 if} (p_Index >= Axon_Hillock_Count) \{ resize_Axon_Hillocks(p_Index + 1); \}\par
133 \par
134         c_Node** tmp_Axons;\par
135         tmp_Axons = {\cf17 new} c_Node * [Axon_Count[p_Index]];\par
136         {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < Axon_Count[p_Index]; cou_A++)\par
137         \{\par
138             tmp_Axons[cou_A] = Axons[p_Index][cou_A];\par
139             Axons[p_Index][cou_A] = NULL;\par
140         \}\par
141 \par
142         {\cf17 delete}[] Axons[p_Index];\par
143         Axons[p_Index] = NULL;\par
144 \par
145         Axons[p_Index] = {\cf17 new} c_Node * [Axon_Count[p_Index] + 1];\par
146 \par
147         {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < Axon_Count[p_Index]; cou_A++)\par
148         \{\par
149             Axons[p_Index][cou_A] = tmp_Axons[cou_A];\par
150             tmp_Axons[cou_A] = NULL;\par
151         \}\par
152         {\cf17 delete}[] tmp_Axons;\par
153         tmp_Axons = NULL;\par
154 \par
155         Axons[p_Index][Axon_Count[p_Index]] = p_Axon;\par
156         Axon_Count[p_Index]++;\par
157     \}\par
158 \par
159     {\cf20 //Sets the dendrites of the node.}\par
160     {\cf20 //This assumes the node has no dendrites yet, if it does you be dangling and jangling}\par
161     {\cf18 void} set_Dendrites(c_Node** p_Dendrites, {\cf18 int} p_Count)\par
162     \{\par
163         Dendrites = {\cf17 new} c_Node * [p_Count];\par
164 \par
165         {\cf19 for} ({\cf18 int} cou_D = 0; cou_D < p_Count; cou_D++)\par
166         \{\par
167             Dendrites[cou_D] = p_Dendrites[cou_D];\par
168         \}\par
169 \par
170         Dendrite_Count = p_Count;\par
171     \}\par
172 \par
173     {\cf20 //Searches the axons to see if an upper tier connection exists.}\par
174     {\cf20 //This is always called from the first leg, that is why we separate _F from normal.}\par
175     c_Node* does_Upper_Tier_Connection_Exist(c_Node** p_Nodes, {\cf18 int} p_Count)\par
176     \{\par
177         {\cf19 if} (Axon_Hillock_Count > 0)\par
178         \{\par
179             {\cf20 //std::cout << "\\n Axon_Count[0]: " << Axon_Count[0];}\par
180 \par
181             {\cf20 //Check the axons on the right side for the }\par
182             {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < Axon_Count[0]; cou_A++)\par
183             \{\par
184                 {\cf20 //std::cout << "\\n   Axon_F[" << cou_A << "] " << Axons[0][cou_A];}\par
185                 {\cf19 if} (Axons[0][cou_A]->does_Lower_Connection_Exist(p_Nodes, p_Count))\par
186                 \{\par
187                     {\cf20 //std::cout << "\\n >>>>>>>>>>>>>Foundit: " << Axons[0][cou_A];}\par
188                     {\cf19 return} Axons[0][cou_A];\par
189                 \}\par
190             \}\par
191         \}\par
192         {\cf19 return} NULL;\par
193     \}\par
194 \par
195     {\cf20 //Checks if the given node matches a dendrite on the right leg.}\par
196     {\cf18 bool} does_Lower_Connection_Exist(c_Node ** p_Nodes, {\cf18 int} p_Count)\par
197     \{\par
198         {\cf19 if} (Dendrite_Count != p_Count) \{ {\cf19 return} 0; \}\par
199 \par
200         {\cf20 //Check the lower connections to see if they match.}\par
201         {\cf19 for} ({\cf18 int} cou_C = 1; cou_C < p_Count; cou_C++)\par
202         \{\par
203             {\cf19 if} (Dendrites[cou_C] != p_Nodes[cou_C]) \{ {\cf19 return} 0; \}\par
204         \}\par
205         {\cf19 return} 1;\par
206     \}\par
207 \par
208     {\cf20 //Binds a node to a quanta of data, the state of the input.}\par
209     {\cf18 void} bind_State(uint64_t p_State)\par
210     \{\par
211         State = p_State;\par
212     \}\par
213 \par
214     {\cf20 //Initiates a backpropagation that outputs the pattern represented by this node.}\par
215     {\cf18 void} bp_O()\par
216     \{\par
217         std::cout << {\cf22 "<=- "} << NID << {\cf22 " "};\par
218         {\cf20 //If a left leg exists then initiate a backpropagation along it, then along the right side.}\par
219         {\cf19 if} (Dendrite_Count != 0)\par
220         \{\par
221             std::cout << {\cf22 "*"};\par
222             {\cf19 if} (Dendrites[0] != NULL)\par
223             \{\par
224                 {\cf20 //If not a treetop then call _F}\par
225                 {\cf19 if} ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))\par
226                 \{\par
227                     Dendrites[0]->bp_F();\par
228                 \}\par
229 \par
230                 {\cf20 //If the dendritically connected node is a treetop then call the _O on it.}\par
231                 {\cf19 if} ((Dendrites[0]->Type == 2) || (Dendrites[0]->Type == 3))\par
232                 \{\par
233                     Dendrites[0]->bp_O();\par
234                 \}\par
235             \}\par
236 \par
237             {\cf19 for} ({\cf18 int} cou_D = 1; cou_D < Dendrite_Count; cou_D++)\par
238             \{\par
239                 {\cf19 if} (Dendrites[cou_D] != NULL)\par
240                 \{\par
241                     {\cf20 //If not a treetop then call bp_M()}\par
242                     {\cf19 if} ((Dendrites[cou_D]->Type != 2) && (Dendrites[cou_D]->Type != 3))\par
243                     \{\par
244                         Dendrites[cou_D]->bp_M();\par
245                         {\cf19 continue};\par
246                     \}\par
247 \par
248                     {\cf20 //If the dendritically connected node is a treetop then call the bp_O on it.}\par
249                     {\cf19 if} ((Dendrites[cou_D]->Type == 2) || (Dendrites[cou_D]->Type == 3))\par
250                     \{\par
251                         Dendrites[cou_D]->bp_O();\par
252                     \}\par
253                 \}\par
254             \}\par
255         \}\par
256         {\cf19 else}\par
257         \{\par
258             {\cf20 //Output the state}\par
259             {\cf20 //std::cout << " <" << NID << " :: " << State << "> ";}\par
260 \par
261             {\cf20 //u_Tmp tmp_State; tmp_State.U = State;}\par
262             {\cf20 //std::cout << " [ " << tmp_State.D << ", " << State << " ] ";}\par
263             std::cout << {\cf22 " [ "} << char(State) << {\cf22 ", "} << State << {\cf22 " ] "};\par
264         \}\par
265         std::cout << {\cf22 " -=>"};\par
266     \}\par
267 \par
268     {\cf20 //bp_Output the left node.}\par
269     {\cf18 void} bp_F()\par
270     \{\par
271         {\cf20 //If a left leg exists then initiate a backpropagation along it, then along the right side.}\par
272         {\cf19 if} (Dendrite_Count != 0)\par
273         \{\par
274             {\cf19 if} (Dendrites[0] != NULL) \{ Dendrites[0]->bp_F(); \}\par
275             {\cf19 for} ({\cf18 int} cou_D = 1; cou_D < Dendrite_Count; cou_D++)\par
276             \{\par
277                 {\cf19 if} (Dendrites[cou_D] != NULL) \par
278                 \{\par
279                     Dendrites[cou_D]->bp_M();\par
280                 \}\par
281             \}\par
282         \}\par
283         {\cf19 else}\par
284         \{\par
285             {\cf20 //Output the state}\par
286             {\cf20 //std::cout << " <" << NID << " :: " << State << "> ";}\par
287             u_Tmp tmp_State; tmp_State.U = State;\par
288             {\cf20 //std::cout << " [ " << tmp_State.D << ", " << State << " ] ";}\par
289             std::cout << {\cf22 " [ "} << char(State) << {\cf22 ", "} << State << {\cf22 " ] "};\par
290         \}\par
291     \}\par
292 \par
293     {\cf20 //bp_Output the other nodes, M stands for many.}\par
294     {\cf18 void} bp_M()\par
295     \{\par
296         {\cf20 //If a left leg exists then initiate a backpropagation along it, then along the right side.}\par
297         {\cf19 if} (Dendrite_Count != 0)\par
298         \{\par
299             {\cf19 for} ({\cf18 int} cou_D = 1; cou_D < Dendrite_Count; cou_D++)\par
300             \{\par
301                 {\cf19 if} (Dendrites[cou_D] != NULL)\par
302                 \{\par
303                     Dendrites[cou_D]->bp_M();\par
304                 \}\par
305             \}\par
306         \}\par
307         {\cf19 else}\par
308         \{\par
309             {\cf20 //Output the state}\par
310             {\cf20 //std::cout << " <" << NID << " :: " << State << "> ";}\par
311             u_Tmp tmp_State; tmp_State.U = State;\par
312             {\cf20 //std::cout << " [ " << tmp_State.D << ", " << State << " ] ";}\par
313             std::cout << {\cf22 " [ "} << char(State) << {\cf22 ", "} << State << {\cf22 " ] "};\par
314         \}\par
315     \}\par
316 \par
317     \par
318 \par
319 \par
320     {\cf20 //Initiates a backpropagation that }\par
321     {\cf18 void} bp_Trace_O(c_Linked_List_Handler * p_LL)\par
322     \{\par
323         {\cf20 //---std::cout << "\\n bp_Trace_O <=- " << NID << " ";}\par
324         {\cf20 //If a left leg exists then initiate a backpropagation along it, then along the right side.}\par
325         {\cf19 if} (Dendrite_Count != 0)\par
326         \{\par
327             {\cf20 //---std::cout << "*";}\par
328             {\cf19 if} (Dendrites[0] != NULL)\par
329             \{\par
330                 {\cf20 //If not a treetop then call _F}\par
331                 {\cf19 if} ((Dendrites[0]->Type != 2) && (Dendrites[0]->Type != 3))\par
332                 \{\par
333                     Dendrites[0]->bp_Trace_F(p_LL);\par
334                 \}\par
335 \par
336                 {\cf20 //If the dendritically connected node is a treetop then call the _O on it.}\par
337                 {\cf19 if} ((Dendrites[0]->Type == 2) || (Dendrites[0]->Type == 3))\par
338                 \{\par
339                     Dendrites[0]->bp_Trace_O(p_LL);\par
340                 \}\par
341             \}\par
342 \par
343             {\cf19 for} ({\cf18 int} cou_D = 1; cou_D < Dendrite_Count; cou_D++)\par
344             \{\par
345                 {\cf19 if} (Dendrites[cou_D] != NULL)\par
346                 \{\par
347                     {\cf20 //If not a treetop then call bp_M()}\par
348                     {\cf19 if} ((Dendrites[cou_D]->Type != 2) && (Dendrites[cou_D]->Type != 3))\par
349                     \{\par
350                         Dendrites[cou_D]->bp_Trace_M(p_LL);\par
351                         {\cf19 continue};\par
352                     \}\par
353 \par
354                     {\cf20 //If the dendritically connected node is a treetop then call the bp_O on it.}\par
355                     {\cf19 if} ((Dendrites[cou_D]->Type == 2) || (Dendrites[cou_D]->Type == 3))\par
356                     \{\par
357                         Dendrites[cou_D]->bp_Trace_O(p_LL);\par
358                     \}\par
359                 \}\par
360             \}\par
361         \}\par
362         {\cf19 else}\par
363         \{\par
364             {\cf20 //Output the state}\par
365             std::cout << {\cf22 " <"} << NID << {\cf22 " :: "} << State << {\cf22 "> "};\par
366             p_LL->new_LL(State);\par
367         \}\par
368         {\cf20 //---std::cout << " -=>";}\par
369     \}\par
370 \par
371     {\cf20 //bp_Output the left node.}\par
372     {\cf18 void} bp_Trace_F(c_Linked_List_Handler* p_LL)\par
373     \{\par
374         {\cf20 //If a left leg exists then initiate a backpropagation along it, then along the right side.}\par
375         {\cf19 if} (Dendrite_Count != 0)\par
376         \{\par
377             {\cf19 if} (Dendrites[0] != NULL) \{ Dendrites[0]->bp_Trace_F(p_LL); \}\par
378             {\cf19 for} ({\cf18 int} cou_D = 1; cou_D < Dendrite_Count; cou_D++)\par
379             \{\par
380                 {\cf19 if} (Dendrites[cou_D] != NULL) \par
381                 \{\par
382                     Dendrites[cou_D]->bp_Trace_M(p_LL);\par
383                 \}\par
384             \}\par
385         \}\par
386         {\cf19 else}\par
387         \{\par
388             {\cf20 //Output the state}\par
389             {\cf20 //---std::cout << " <" << NID << " :: " << State << "> ";}\par
390             p_LL->new_LL(State);\par
391         \}\par
392     \}\par
393 \par
394     {\cf20 //bp_Output the other nodes, M stands for many.}\par
395     {\cf18 void} bp_Trace_M(c_Linked_List_Handler* p_LL)\par
396     \{\par
397         {\cf20 //If a left leg exists then initiate a backpropagation along it, then along the right side.}\par
398         {\cf19 if} (Dendrite_Count != 0)\par
399         \{\par
400             {\cf19 for} ({\cf18 int} cou_D = 1; cou_D < Dendrite_Count; cou_D++)\par
401             \{\par
402                 {\cf19 if} (Dendrites[cou_D] != NULL)\par
403                 \{\par
404                     Dendrites[cou_D]->bp_Trace_M(p_LL);\par
405                 \}\par
406             \}\par
407         \}\par
408         {\cf19 else}\par
409         \{\par
410             {\cf20 //Output the state}\par
411             {\cf20 //---std::cout << " <" << NID << " :: " << State << "> ";}\par
412             p_LL->new_LL(State);\par
413         \}\par
414     \}\par
415 \par
416 \par
417     {\cf18 void} output_Node_Raw()\par
418     \{\par
419         std::cout << {\cf22 "\\n Node_ID (NID): "} << NID << {\cf22 " "};\par
420         std::cout << {\cf22 " RC: "} << RC;\par
421         std::cout << {\cf22 " Type: "} << Type;\par
422         std::cout << {\cf22 " State \{ "} << State << {\cf22 " \}"};\par
423         std::cout << {\cf22 " --- Dendrites: "};\par
424         {\cf19 for} ({\cf18 int} cou_D = 0; cou_D < Dendrite_Count; cou_D++)\par
425         \{\par
426             std::cout << {\cf22 " ["} << cou_D << {\cf22 "] "} << Dendrites[cou_D]->NID;\par
427         \}\par
428         std::cout << {\cf22 " --- Axon_Hillock_Count: "} << Axon_Hillock_Count;\par
429         {\cf19 for} ({\cf18 int} cou_H = 0; cou_H < Axon_Hillock_Count; cou_H++)\par
430         \{\par
431             std::cout << {\cf22 " Axons["} << cou_H << {\cf22 "] <"} << Axon_Count[cou_H] << {\cf22 ">: "};\par
432             {\cf19 for} ({\cf18 int} cou_A = 0; cou_A < Axon_Count[cou_H]; cou_A++)\par
433             \{\par
434                 std::cout << {\cf22 " ["} << cou_A << {\cf22 "] "} << Axons[cou_H][cou_A]->NID;\par
435             \}\par
436         \}\par
437     \}\par
438 \par
439     {\cf18 void} output_Node_Char()\par
440     \{\par
441         std::cout << char({\cf17 this});\par
442     \}\par
443 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Node_Network.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Node_Network.h}
{\xe \v include/NT4/c_Node_Network.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf17 class }c_Node_Network\par
3 \{\par
4 {\cf17 public}:\par
5 \par
6     {\cf20 //This is what holds all the nodes. It allows us to search by NID.}\par
7     {\cf20 //A node is created then added here. }\par
8     c_Fractal_Tree Nodes;\par
9 \par
10     {\cf20 //This is the root node of the linked list, the linked list being the node soup.}\par
11     c_Node* Root;\par
12 \par
13     {\cf20 //Tracks the current node in the linked list, the last one in line for creation and appending of new nodes.}\par
14     c_Node** Current_Node;\par
15 \par
16     {\cf20 //We use this to assign Node IDs (NIDs) and then to iteratively delete the allocated nodes by querying the tree and deleting them.}\par
17     {\cf20 //It's slow to do it that way but we won't be killing the network except at shutdown.}\par
18     uint64_t Node_Count;\par
19 \par
20     {\cf20 //This holds the state trees for each construct.}\par
21     {\cf20 //Even if two constructs have the same state input you may want to keep them separate, so you need multiple state trees.}\par
22     {\cf20 //The state tree does not create new nodes, it only tracks them.}\par
23     c_Fractal_Tree** State_Nodes;\par
24     {\cf18 int} State_Node_Tree_Count;\par
25 \par
26     {\cf20 //On creation a default construct at index 0 is registered.}\par
27     c_Node_Network()\par
28     \{\par
29         Node_Count = 0;\par
30         State_Node_Tree_Count = 1;\par
31         State_Nodes = {\cf17 new} c_Fractal_Tree * [1];\par
32         State_Nodes[0] = {\cf17 new} c_Fractal_Tree;\par
33 \par
34         Root = NULL;\par
35         Current_Node = &Root;\par
36 \par
37         {\cf20 //When loading nodes remember that this one is created in the constructor so it will need skipped during the loading/saving phase.}\par
38         new_Node();\par
39     \}\par
40 \par
41 \par
42     ~c_Node_Network()\par
43     \{\par
44         std::cout << {\cf22 "\\n ~c_Node_Network "} << (Node_Count) << {\cf22 " "} << {\cf17 this} << {\cf22 ".........."}; std::cout.flush();\par
45         {\cf20 //delete Root;}\par
46 \par
47         c_Node* tmp_LL = Root;\par
48         Root = NULL;\par
49         c_Node* tmp_LL_Next = NULL;\par
50 \par
51         {\cf19 while} (tmp_LL != NULL)\par
52         \{\par
53             tmp_LL_Next = tmp_LL->Next;\par
54             tmp_LL->Next = NULL;\par
55             {\cf17 delete} tmp_LL;\par
56             tmp_LL = NULL;\par
57             tmp_LL = tmp_LL_Next;\par
58         \}\par
59 \par
60         {\cf17 delete} Root;\par
61         Root = NULL;\par
62 \par
63         std::cout << {\cf22 "\\n ~~~c_Node_Network "} << Node_Count << {\cf22 " "} << {\cf17 this} << {\cf22 ".........."}; std::cout.flush();\par
64     \}\par
65 \par
66     {\cf18 int} register_New_Construct()\par
67     \{\par
68         c_Fractal_Tree** tmp_State_Nodes;\par
69 \par
70         tmp_State_Nodes = {\cf17 new} c_Fractal_Tree * [State_Node_Tree_Count];\par
71 \par
72         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Node_Tree_Count; cou_Index++)\par
73         \{\par
74             tmp_State_Nodes[cou_Index] = State_Nodes[cou_Index];\par
75             State_Nodes[cou_Index] = NULL;\par
76         \}\par
77 \par
78         {\cf19 if} (State_Nodes != NULL) \{ {\cf17 delete}[] State_Nodes; \}\par
79 \par
80         State_Node_Tree_Count++;\par
81 \par
82         State_Nodes = {\cf17 new} c_Fractal_Tree * [State_Node_Tree_Count];\par
83 \par
84         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < State_Node_Tree_Count; cou_Index++)\par
85         \{\par
86             State_Nodes[cou_Index] = NULL;\par
87         \}\par
88 \par
89         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (State_Node_Tree_Count - 1); cou_Index++)\par
90         \{\par
91             State_Nodes[cou_Index] = tmp_State_Nodes[cou_Index];\par
92             tmp_State_Nodes[cou_Index] = NULL;\par
93 \par
94             std::cout << {\cf22 "\\nCon["} << cou_Index << {\cf22 "] "} << State_Nodes[cou_Index];\par
95         \}\par
96 \par
97         {\cf19 if} (tmp_State_Nodes != NULL) \{ {\cf17 delete}[] tmp_State_Nodes; \}\par
98         tmp_State_Nodes = NULL;\par
99 \par
100         State_Nodes[State_Node_Tree_Count - 1] = {\cf17 new} c_Fractal_Tree;\par
101         std::cout << {\cf22 "\\nCon["} << (State_Node_Tree_Count - 1) << {\cf22 "] "} << State_Nodes[State_Node_Tree_Count - 1];\par
102 \par
103         {\cf19 return} (State_Node_Tree_Count - 1);\par
104     \}\par
105 \par
106     {\cf20 //Creates a new node and adds it to the fractal tree.}\par
107     {\cf20 //Each node is stored as a link in a linked list.}\par
108     c_Node* new_Node()\par
109     \{\par
110         {\cf20 //Create the node.}\par
111         *Current_Node = {\cf17 new} c_Node;\par
112 \par
113         {\cf20 //Sets the new nodes ID.}\par
114         (*Current_Node)->NID = Node_Count;\par
115 \par
116         {\cf20 //Queries the node tree with the current NID to get the fractal node ready.}\par
117         Nodes.search(Node_Count);\par
118 \par
119         {\cf20 //Increment the node tracker.}\par
120         Node_Count++;\par
121 \par
122         {\cf20 //Sets the node in the node tree.}\par
123         Nodes.set_Current_Node_NAdd(*Current_Node);\par
124 \par
125         {\cf20 //Set the Current node to the next one in the chain.}\par
126         Current_Node = &(*Current_Node)->Next;\par
127 \par
128         {\cf20 //Return the created state node using the state tree as Current_Node is changed.}\par
129         {\cf19 return} Nodes.get_Current_Node_NAdd();\par
130     \}\par
131 \par
132     {\cf20 //Creates a new node, then adds it to the state tree.}\par
133     {\cf20 //Assumes the construct is already registered so the index is valid.}\par
134     c_Node* new_State_Node({\cf18 int} p_Construct, {\cf18 double} p_State)\par
135     \{\par
136         c_Node* tmp_State_Node = new_Node();\par
137 \par
138         {\cf20 //Enter the state into the tree. The NNet node still needs linked to the pointer in the fractal node.}\par
139         State_Nodes[p_Construct]->search(p_State);\par
140 \par
141         {\cf20 //Assign the newly minted node in the fractal state tree.}\par
142         State_Nodes[p_Construct]->set_Current_Node_NAdd(tmp_State_Node);\par
143 \par
144         tmp_State_Node->State = p_State;\par
145 \par
146         tmp_State_Node->set_Type(0);\par
147 \par
148         {\cf19 return} tmp_State_Node;\par
149     \}\par
150 \par
151     {\cf20 //This is used during loading when you have the node to bind to the state.}\par
152     {\cf18 void} assign_State_Node({\cf18 int} p_State_Tree, c_Node * p_Node, {\cf18 double} p_State)\par
153     \{\par
154         {\cf20 //Enter the state into the tree. The NNet node still needs linked to the pointer in the fractal node.}\par
155         State_Nodes[p_State_Tree]->search(p_State);\par
156 \par
157         {\cf20 //Assign the newly minted node in the fractal state tree.}\par
158         State_Nodes[p_State_Tree]->set_Current_Node_NAdd(p_Node);\par
159 \par
160         p_Node->State = p_State;\par
161 \par
162         p_Node->set_Type(0);\par
163     \}\par
164 \par
165     {\cf20 //Creates a connection between nodes.}\par
166     {\cf20 //p_To forms dendritic connections to p_From, and on p_From you have the axonic connections.}\par
167     {\cf18 void} create_Connections(c_Node* p_To, c_Node** p_From, {\cf18 int} p_Count)\par
168     \{\par
169         p_To->set_Dendrites(p_From, p_Count);\par
170 \par
171         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < p_Count; cou_Index++)\par
172         \{\par
173             p_From[cou_Index]->add_Axon_Index(p_To, cou_Index);\par
174         \}\par
175     \}\par
176 \par
177     {\cf20 //Checks if an upper tier node exists.}\par
178     c_Node* does_Upper_Tier_Connection_Exist(c_Node** p_Legs, {\cf18 int} p_Count)\par
179     \{\par
180         {\cf20 //Search all the _F Axonic processes for the first leg, if found query the node to see if the leg permutations match.}\par
181         {\cf19 if} (p_Legs[0] != NULL)\par
182         \{\par
183             {\cf19 return} p_Legs[0]->does_Upper_Tier_Connection_Exist(p_Legs, p_Count);\par
184         \}\par
185         {\cf19 return} NULL;\par
186     \}\par
187 \par
188     {\cf20 //Gets an upper tier node based on the given legs.}\par
189     c_Node* get_Upper_Tier_Node(c_Node** p_Legs, {\cf18 int} p_Count, {\cf18 int} p_Type)\par
190     \{\par
191         {\cf19 if} (p_Legs == NULL) \{ {\cf19 return} NULL; \}\par
192         {\cf19 if} (p_Count == 0) \{ {\cf19 return} NULL; \}\par
193 \par
194         c_Node* tmp_Node = NULL;\par
195 \par
196         {\cf20 //See if the node exists yet.}\par
197         tmp_Node = does_Upper_Tier_Connection_Exist(p_Legs, p_Count);\par
198 \par
199         {\cf20 /*}\par
200 {\cf20         std::cout << "\\n DUTCE: " << tmp_Node;}\par
201 {\cf20         for (int cou_Leg = 0; cou_Leg < p_Count; cou_Leg++)}\par
202 {\cf20         \{}\par
203 {\cf20             std::cout << "\\n    [" << cou_Leg << "] " << p_Legs[cou_Leg];}\par
204 {\cf20         \}}\par
205 {\cf20         */}\par
206 \par
207         {\cf20 //If the node doesn't exist then we create it, and then create the connection.}\par
208         {\cf19 if} (tmp_Node == NULL)\par
209         \{\par
210             {\cf20 //std::cout << "\\n  New Node";}\par
211 \par
212             tmp_Node = new_Node();\par
213 \par
214             create_Connections(tmp_Node, p_Legs, p_Count);\par
215 \par
216             tmp_Node->set_Type(p_Type);\par
217         \}\par
218 \par
219         {\cf20 //std::cout << "\\n  End: " << tmp_Node;}\par
220         {\cf19 return} tmp_Node;\par
221     \}\par
222 \par
223     {\cf20 //If a state node exists in the given construct index then return it.}\par
224     {\cf20 //Otherwise return NULL.}\par
225     {\cf20 //This assumes the [Index] is valid}\par
226     c_Node* does_State_Node_Exist({\cf18 int} p_Index, uint64_t p_Data)\par
227     \{\par
228         {\cf20 //Search the state tree give.}\par
229         State_Nodes[p_Index]->search(p_Data);\par
230         {\cf19 if} (State_Nodes[p_Index]->flg_Foundit)\par
231         \{\par
232             {\cf19 return} State_Nodes[p_Index]->get_Current_Node_NAdd();\par
233         \}\par
234         {\cf19 return} NULL;\par
235     \}\par
236 \par
237     {\cf20 //Checks to see if a node in the given assembly is bound to the given state, if not the node is created.}\par
238     c_Node* get_State_Node({\cf18 int} p_Index, uint64_t p_Data)\par
239     \{\par
240         {\cf20 //See if the state node exists yet.}\par
241         c_Node* tmp_Node = does_State_Node_Exist(p_Index, p_Data);\par
242         {\cf19 if} (tmp_Node != NULL)\par
243         \{\par
244             {\cf20 //If we found it then we return it.}\par
245             {\cf19 return} tmp_Node;\par
246         \}\par
247 \par
248         {\cf20 //Create the new node and return it, new_State_Node handles the binding.}\par
249         {\cf19 return} new_State_Node(p_Index, p_Data);\par
250     \}\par
251 \par
252 \par
253     {\cf20 //Queries the node tree with the current NID to get the fractal node ready.}\par
254     c_Node* get_Node_Ref_By_NID(uint64_t p_NID)\par
255     \{\par
256 \par
257         {\cf20 //Queries the node tree with the given NID.}\par
258         Nodes.search(p_NID);\par
259 \par
260         {\cf19 if} (Nodes.flg_Foundit)\par
261         \{\par
262             {\cf19 return} Nodes.get_Current_Node_NAdd();\par
263         \}\par
264         {\cf19 return} NULL;\par
265     \}\par
266 \par
267     {\cf20 //Iterates through every node and outputs their bp_O()}\par
268     {\cf18 void} output_BP()\par
269     \{\par
270         c_Node* tmp_Node;\par
271         tmp_Node = Root;\par
272 \par
273         {\cf19 while} (tmp_Node != NULL)\par
274         \{\par
275             std::cout << {\cf22 "\\n"};\par
276             tmp_Node->bp_O();\par
277 \par
278             tmp_Node = tmp_Node->Next;\par
279         \}\par
280     \}\par
281 \par
282     {\cf20 //Iterates through every node and outputs their bp_O()}\par
283     {\cf18 void} output_Raw()\par
284     \{\par
285         c_Node* tmp_Node;\par
286         tmp_Node = Root;\par
287 \par
288         {\cf19 while} (tmp_Node != NULL)\par
289         \{\par
290             tmp_Node->output_Node_Raw();\par
291 \par
292             tmp_Node = tmp_Node->Next;\par
293         \}\par
294     \}\par
295 \par
296     {\cf20 //Finds given NID and outputs the bp_O()}\par
297     {\cf18 void} output_BP_NID(uint64_t p_NID)\par
298     \{\par
299         c_Node* tmp_Node = NULL;\par
300         tmp_Node = get_Node_Ref_By_NID(p_NID);\par
301         {\cf19 if} (tmp_Node != NULL)\par
302         \{\par
303             std::cout << {\cf22 "\\nNID: "} << tmp_Node->NID << {\cf22 " "};\par
304             std::cout << {\cf22 "Type: "} << int(tmp_Node->Type) << {\cf22 " "};\par
305             std::cout << {\cf22 "Symbol: "};\par
306             tmp_Node->bp_O();\par
307         \}\par
308     \}\par
309 \par
310 \par
311 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
c_Trace.h\par \pard\plain 
{\tc\tcl2 \v include/NT4/c_Trace.h}
{\xe \v include/NT4/c_Trace.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 \par
3 \par
4 {\cf20 //This class serves as the user interface for the actuator I/O}\par
5 {\cf17 class }c_Trace\par
6 \{\par
7 {\cf17 public}:\par
8 \par
9     {\cf20 //Data is stored as an array of uint64_t}\par
10     uint64_t* Pattern;\par
11     {\cf18 double} Charge;\par
12     {\cf18 double} RC;\par
13     c_Node* Treetop;\par
14 \par
15     {\cf20 //The depth of the data.}\par
16     {\cf18 int} Depth;\par
17 \par
18     c_Trace()\par
19     \{\par
20         Pattern = NULL;\par
21         reset();\par
22     \}\par
23 \par
24     {\cf18 void} set_Depth({\cf18 int} p_Depth)\par
25     \{\par
26         {\cf20 //If Data is NULL then everything else should be as well.}\par
27         {\cf20 //This assumes that if Pattern is not NULL then it is properly setup as an array.}\par
28         {\cf19 if} (Pattern != NULL)\par
29         \{\par
30             {\cf17 delete}[] Pattern;\par
31             Pattern = NULL;\par
32         \}\par
33 \par
34         Depth = p_Depth;\par
35 \par
36         Pattern = {\cf17 new} uint64_t[Depth];\par
37 \par
38         wipe_Data();\par
39     \}\par
40 \par
41     {\cf20 //This leaves the depth of the pattern alone, useful if you can define one array and reuse it without having to redeclare and resize the array.}\par
42     {\cf20 //Used after set_Depth to intialize the new array.}\par
43     {\cf18 void} wipe_Data()\par
44     \{\par
45         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Depth; cou_Index++)\par
46         \{\par
47             Pattern[cou_Index] = 0;\par
48         \}\par
49 \par
50         Charge = 0.0;\par
51         RC = 0.0;\par
52         Treetop = NULL;\par
53     \}\par
54 \par
55 \par
56     {\cf20 //Reset it if need be.}\par
57     {\cf18 void} reset()\par
58     \{\par
59         wipe_Data();\par
60 \par
61         {\cf19 if} (Pattern != NULL)\par
62         \{\par
63             {\cf17 delete}[] Pattern;\par
64             Pattern = NULL;\par
65         \}\par
66 \par
67         Pattern = NULL;\par
68 \par
69         Charge = 0.0;\par
70         RC = 0.0;\par
71         Treetop = NULL;\par
72 \par
73         Depth = 0;\par
74     \}\par
75 \par
76     {\cf20 //Accepts an input and updates the correct index with it}\par
77     {\cf18 void} set_Pattern_Index(uint64_t p_Value, {\cf18 int} p_Index = -1) {\cf20 //p_Index comes after since it may be 0}\par
78     \{\par
79         {\cf19 if} (p_Index == -1)\par
80         \{\par
81             p_Index = Depth - 1;\par
82         \}\par
83 \par
84         {\cf20 //First get the concrete value.}\par
85         Pattern[p_Index] = p_Value;\par
86     \}\par
87 \par
88     {\cf20 //Sets the Charge}\par
89     {\cf18 void} set_Charge({\cf18 double} p_Charge)\par
90     \{\par
91         Charge = p_Charge;\par
92     \}\par
93 \par
94     {\cf20 //Sets the RC}\par
95     {\cf18 void} set_RC({\cf18 double} p_RC)\par
96     \{\par
97         RC = p_RC;\par
98     \}\par
99 \par
100     {\cf20 //Sets the Charge}\par
101     {\cf18 void} set_Treetop(c_Node * p_Treetop)\par
102     \{\par
103         Treetop = p_Treetop;\par
104     \}\par
105 \par
106     {\cf20 //Accepts an array, resets the data, then reads the array into the data then sets the depth.}\par
107     {\cf18 void} set_Pattern_Array(uint64_t* p_Pattern_Array, {\cf18 int} p_Depth)\par
108     \{\par
109         reset();\par
110 \par
111         {\cf20 //Initialize the wiped input array and copy the data to it from the arguments.}\par
112         set_Depth(p_Depth);\par
113 \par
114         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Depth; cou_Index++)\par
115         \{\par
116             Pattern[cou_Index] = p_Pattern_Array[cou_Index];\par
117         \}\par
118     \}\par
119 \par
120     {\cf20 //Returns the value.}\par
121     uint64_t get_Pattern_Index({\cf18 int} p_Index = -1)\par
122     \{\par
123         {\cf19 if} (p_Index == -1)\par
124         \{\par
125             p_Index = Depth - 1;\par
126         \}\par
127 \par
128         {\cf19 return} Pattern[p_Index];\par
129     \}\par
130 \par
131     {\cf18 double} get_Charge()\par
132     \{\par
133         {\cf19 return} Charge;\par
134     \}\par
135 \par
136     {\cf18 double} get_RC()\par
137     \{\par
138         {\cf19 return} RC;\par
139     \}\par
140 \par
141     c_Node * get_Treetop()\par
142     \{\par
143         {\cf19 return} Treetop;\par
144     \}\par
145 \par
146     {\cf20 //This shifts the output from current to 0.}\par
147     {\cf18 void} shift_Data()\par
148     \{\par
149         {\cf20 //Shift each array one index towards [0].}\par
150         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < (Depth - 1); cou_Index++)\par
151         \{\par
152             Pattern[cou_Index] = Pattern[cou_Index + 1];\par
153         \}\par
154 \par
155         {\cf20 //Set the current to 0.0 in preparation for input.}\par
156         Pattern[Depth - 1] = 0;\par
157     \}\par
158 \par
159     {\cf20 //Outputs the data}\par
160     {\cf18 void} output({\cf18 int} p_Type)\par
161     \{\par
162         uint64_t tmp_Tt_NID = 0;\par
163         {\cf19 if} (Treetop != NULL) \{ tmp_Tt_NID = Treetop->NID; \}\par
164         std::cout << {\cf22 "\\n --  Charge: "} << Charge << {\cf22 " RC: "} << RC << {\cf22 " Treetop: "} << tmp_Tt_NID << {\cf22 " Pattern: "};\par
165         \par
166         {\cf19 for} ({\cf18 int} cou_Index = 0; cou_Index < Depth; cou_Index++)\par
167         \{\par
168             {\cf19 if} (p_Type == 0)\{ std::cout << {\cf22 " "} << char(Pattern[cou_Index]); \}\par
169             {\cf19 if} (p_Type == 1)\{ std::cout << {\cf22 " "} << Pattern[cou_Index]; \}\par
170         \}\par
171     \}\par
172 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NT4_Master.h\par \pard\plain 
{\tc\tcl2 \v include/NT4_Master.h}
{\xe \v include/NT4_Master.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
25 {\cf20 //The NeuroTox 4 library.}\par
26 {\cf17 namespace }NT4\par
27 \{\par
28 \par
29     {\cf20 //Used in the CAN & the Node Network for backprop.}\par
30 {\cf21     #include "NT4/c_IO.h"}\par
31 \par
32 {\cf21     #include "NT4/c_Linked_List_Handler.h"}\par
33 \par
34 {\cf21     #include "NT4/c_Node.h"}\par
35 \par
36 {\cf21     #include "NT4/c_Trace.h"}\par
37 \par
38 {\cf21     #include "NT4/c_Fractal_Tree.h"}\par
39 \par
40 {\cf21     #include "NT4/c_Node_Network.h"}\par
41 \par
42 {\cf21     #include "NT4/c_Charging_Array.h"} \par
43     {\cf20 //#include "NT4/c_Backpropagation_Station}\par
44     {\cf20 // }\par
45     {\cf20 //Both the Charging_Array & Backpropagation_Station have to have members to handle each type of CAN structure.}\par
46 {\cf21     #include "NT4/c_CAN.h"}\par
47 {\cf21     #include "NT4/c_CAN_Many_To_One.h"}\par
48 {\cf21     #include "NT4/c_CAN_1D_Pyramid.h"}\par
49 {\cf21     #include "NT4/c_CAN_2D_Pyramid.h"}\par
50 {\cf21     #include "NT4/c_CAN_3D_Pyramid.h"}\par
51     \par
52 {\cf21     #include "NT4/c_Construct.h"}\par
53 {\cf21     #include "NT4/c_Construct_API.h"}\par
54 {\cf21     #include "NT4/c_Construct_Text_Server.h"}\par
55 \}\par
56 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NT4.h\par \pard\plain 
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // NT4.h : Include file for standard system include files,}\par
2 {\cf20 // or project specific include files.}\par
3 \par
4 {\cf21 #pragma once}\par
5 \par
6 {\cf21 #include <iostream>}\par
7 {\cf21 #include <ctime>} {\cf20 // Include the ctime header for time functionality}\par
8 {\cf21 #include <fstream>}\par
9 {\cf21 #include <string>}\par
10 \par
11 {\cf21 #include "NT4_Master.h"}\par
12 {\cf21 #include "c_Sim.h"}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
